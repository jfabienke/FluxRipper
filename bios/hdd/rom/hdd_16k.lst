     1                                  ;==============================================================================
     2                                  ; FluxRipper HDD BIOS - ROM Entry Point
     3                                  ;==============================================================================
     4                                  ; This is the main entry file for the HDD BIOS Option ROM. It contains:
     5                                  ;   - ROM signature (55 AA)
     6                                  ;   - PnP header (16KB build only)
     7                                  ;   - Initialization entry point
     8                                  ;   - Jump table for internal functions
     9                                  ;
    10                                  ; The ROM is designed to be detected by the system BIOS during POST and
    11                                  ; called for initialization. It then hooks INT 13h to provide hard disk
    12                                  ; services.
    13                                  ;
    14                                  ; SPDX-License-Identifier: BSD-3-Clause
    15                                  ; Copyright (c) 2025 FluxRipper Project
    16                                  ;==============================================================================
    17                                  
    18                                  [BITS 16]
    19                                  [ORG 0]
    20                                  
    21                                  ;------------------------------------------------------------------------------
    22                                  ; Include Configuration
    23                                  ;------------------------------------------------------------------------------
    24                                  %include "config.inc"
     1                              <1> ;==============================================================================
     2                              <1> ; FluxRipper HDD BIOS - Build Configuration
     3                              <1> ;==============================================================================
     4                              <1> ; Defines assembly-time flags for conditional compilation of features.
     5                              <1> ;
     6                              <1> ; SPDX-License-Identifier: BSD-3-Clause
     7                              <1> ; Copyright (c) 2025 FluxRipper Project
     8                              <1> ;==============================================================================
     9                              <1> 
    10                              <1> %ifndef CONFIG_INC
    11                              <1> %define CONFIG_INC
    12                              <1> 
    13                              <1> ;------------------------------------------------------------------------------
    14                              <1> ; Build Target Selection
    15                              <1> ;------------------------------------------------------------------------------
    16                              <1> ; These should be defined on the command line via -D flags:
    17                              <1> ;   -DBUILD_8KB=1 -DBUILD_16KB=0   for 8KB XT-compatible ROM
    18                              <1> ;   -DBUILD_8KB=0 -DBUILD_16KB=1   for 16KB AT ROM with diagnostics
    19                              <1> 
    20                              <1> %ifndef BUILD_8KB
    21                              <1>     %define BUILD_8KB   1       ; Default to 8KB build
    22                              <1> %endif
    23                              <1> 
    24                              <1> %ifndef BUILD_16KB
    25                              <1>     %define BUILD_16KB  0
    26                              <1> %endif
    27                              <1> 
    28                              <1> ;------------------------------------------------------------------------------
    29                              <1> ; ROM Size Constants
    30                              <1> ;------------------------------------------------------------------------------
    31                              <1> %if BUILD_8KB
    32                              <1>     %define ROM_SIZE        8192        ; 8KB ROM
    33                              <1>     %define ROM_BLOCKS      16          ; Size in 512-byte blocks
    34                              <1> %else
    35                              <1>     %define ROM_SIZE        16384       ; 16KB ROM
    36                              <1>     %define ROM_BLOCKS      32          ; Size in 512-byte blocks
    37                              <1> %endif
    38                              <1> 
    39                              <1> ;------------------------------------------------------------------------------
    40                              <1> ; Feature Enables (derived from build target)
    41                              <1> ;------------------------------------------------------------------------------
    42                              <1> 
    43                              <1> ; LBA extensions (INT 13h 41h-48h) - 16KB only
    44                              <1> %if BUILD_16KB
    45                              <1>     %define ENABLE_LBA      1
    46                              <1> %else
    47                              <1>     %define ENABLE_LBA      0
    48                              <1> %endif
    49                              <1> 
    50                              <1> ; Extended INT 13h functions (09h-15h) - 16KB only
    51                              <1> %if BUILD_16KB
    52                              <1>     %define ENABLE_EXTENDED 1
    53                              <1> %else
    54                              <1>     %define ENABLE_EXTENDED 0
    55                              <1> %endif
    56                              <1> 
    57                              <1> ; Diagnostics menu - 16KB only
    58                              <1> %if BUILD_16KB
    59                              <1>     %define ENABLE_DIAG     1
    60                              <1> %else
    61                              <1>     %define ENABLE_DIAG     0
    62                              <1> %endif
    63                              <1> 
    64                              <1> ; Setup utility - 16KB only
    65                              <1> %if BUILD_16KB
    66                              <1>     %define ENABLE_SETUP    1
    67                              <1> %else
    68                              <1>     %define ENABLE_SETUP    0
    69                              <1> %endif
    70                              <1> 
    71                              <1> ; Real-time monitor (F3) - 16KB only
    72                              <1> %if BUILD_16KB
    73                              <1>     %define ENABLE_MONITOR  1
    74                              <1> %else
    75                              <1>     %define ENABLE_MONITOR  0
    76                              <1> %endif
    77                              <1> 
    78                              <1> ; PnP header - 16KB only
    79                              <1> %if BUILD_16KB
    80                              <1>     %define ENABLE_PNP      1
    81                              <1> %else
    82                              <1>     %define ENABLE_PNP      0
    83                              <1> %endif
    84                              <1> 
    85                              <1> ;------------------------------------------------------------------------------
    86                              <1> ; Default I/O Port Addresses
    87                              <1> ;------------------------------------------------------------------------------
    88                              <1> ; These match the FPGA auto-config defaults
    89                              <1> 
    90                              <1> ; WD controller primary base (task file registers 1F0-1F7)
    91                              <1> %define WD_BASE_PRIMARY     0x1F0
    92                              <1> 
    93                              <1> ; WD controller alternate base (3F6-3F7)
    94                              <1> %define WD_BASE_ALTERNATE   0x3F6
    95                              <1> 
    96                              <1> ; WD controller secondary base (170-177) for dual-drive
    97                              <1> %define WD_BASE_SECONDARY   0x170
    98                              <1> 
    99                              <1> ; FDC base (not used by HDD BIOS, but defined for reference)
   100                              <1> %define FDC_BASE            0x3F0
   101                              <1> 
   102                              <1> ;------------------------------------------------------------------------------
   103                              <1> ; FPGA Discovery Register Offsets (from WD_BASE + 0x80)
   104                              <1> ;------------------------------------------------------------------------------
   105                              <1> %define DISC_REG_BASE       0x80        ; Discovery registers at WD_BASE+0x80
   106                              <1> 
   107                              <1> ;------------------------------------------------------------------------------
   108                              <1> ; FPGA Instrumentation Register Offsets (from WD_BASE + 0xC0)
   109                              <1> ;------------------------------------------------------------------------------
   110                              <1> %define INSTR_REG_BASE      0xC0        ; Instrumentation at WD_BASE+0xC0
   111                              <1> 
   112                              <1> ;------------------------------------------------------------------------------
   113                              <1> ; Default IRQ Settings
   114                              <1> ;------------------------------------------------------------------------------
   115                              <1> %define WD_IRQ_PRIMARY      14          ; Primary WD IRQ
   116                              <1> %define WD_IRQ_SECONDARY    15          ; Secondary WD IRQ
   117                              <1> 
   118                              <1> ;------------------------------------------------------------------------------
   119                              <1> ; ROM Base Address
   120                              <1> ;------------------------------------------------------------------------------
   121                              <1> %define ROM_SEGMENT         0xC800      ; Standard Option ROM segment
   122                              <1> %define ROM_BASE            0xC8000     ; ROM linear address
   123                              <1> 
   124                              <1> ;------------------------------------------------------------------------------
   125                              <1> ; Timing Constants (for delay loops)
   126                              <1> ;------------------------------------------------------------------------------
   127                              <1> ; These are conservative and work on 4.77 MHz XT through modern systems
   128                              <1> %define DELAY_SHORT         10          ; ~10us on XT
   129                              <1> %define DELAY_MEDIUM        100         ; ~100us on XT
   130                              <1> %define DELAY_LONG          1000        ; ~1ms on XT
   131                              <1> %define DELAY_VERY_LONG     10000       ; ~10ms on XT
   132                              <1> 
   133                              <1> ;------------------------------------------------------------------------------
   134                              <1> ; Drive Limits
   135                              <1> ;------------------------------------------------------------------------------
   136                              <1> %define MAX_DRIVES          2           ; Maximum hard drives supported
   137                              <1> %define MAX_CYLINDERS       16383       ; Max cylinders (INT 13h limit)
   138                              <1> %define MAX_HEADS           255         ; Max heads
   139                              <1> %define MAX_SECTORS         63          ; Max sectors per track
   140                              <1> 
   141                              <1> ;------------------------------------------------------------------------------
   142                              <1> ; WD Controller Personality Codes
   143                              <1> ;------------------------------------------------------------------------------
   144                              <1> %define PERSONALITY_WD1002  0           ; 8-bit XT, MFM, ST-506
   145                              <1> %define PERSONALITY_WD1003  1           ; 16-bit AT, MFM, ST-506
   146                              <1> %define PERSONALITY_WD1006  2           ; 16-bit AT, RLL 2,7, ST-506
   147                              <1> %define PERSONALITY_WD1007  3           ; 16-bit AT, ESDI
   148                              <1> 
   149                              <1> ;------------------------------------------------------------------------------
   150                              <1> ; Debug Options
   151                              <1> ;------------------------------------------------------------------------------
   152                              <1> %define DEBUG_VERBOSE       0           ; Enable verbose debug output
   153                              <1> %define DEBUG_SERIAL        0           ; Output debug to COM1
   154                              <1> 
   155                              <1> %endif ; CONFIG_INC
    25                                  %include "bda.inc"
     1                              <1> ;==============================================================================
     2                              <1> ; FluxRipper HDD BIOS - BIOS Data Area Definitions
     3                              <1> ;==============================================================================
     4                              <1> ; Defines offsets within the BIOS Data Area (BDA) at segment 0040h.
     5                              <1> ; Includes fixed disk parameter tables and drive status locations.
     6                              <1> ;
     7                              <1> ; SPDX-License-Identifier: BSD-3-Clause
     8                              <1> ; Copyright (c) 2025 FluxRipper Project
     9                              <1> ;==============================================================================
    10                              <1> 
    11                              <1> %ifndef BDA_INC
    12                              <1> %define BDA_INC
    13                              <1> 
    14                              <1> ;------------------------------------------------------------------------------
    15                              <1> ; BDA Segment
    16                              <1> ;------------------------------------------------------------------------------
    17                              <1> %define BDA_SEG             0x0040      ; BIOS Data Area segment
    18                              <1> 
    19                              <1> ;------------------------------------------------------------------------------
    20                              <1> ; Floppy/Hard Disk Status and Count
    21                              <1> ;------------------------------------------------------------------------------
    22                              <1> %define BDA_DISKETTE_STATUS 0x0041      ; Diskette status byte
    23                              <1> %define BDA_DISKETTE_MOTOR  0x003F      ; Diskette motor status
    24                              <1> %define BDA_DISKETTE_TIMER  0x0040      ; Diskette motor timeout
    25                              <1> 
    26                              <1> %define BDA_HDD_STATUS      0x0074      ; Hard disk last operation status
    27                              <1> %define BDA_HDD_COUNT       0x0075      ; Number of hard drives
    28                              <1> 
    29                              <1> ;------------------------------------------------------------------------------
    30                              <1> ; Fixed Disk Parameter Tables
    31                              <1> ;------------------------------------------------------------------------------
    32                              <1> ; INT 41h vector points to drive 0 parameter table
    33                              <1> ; INT 46h vector points to drive 1 parameter table
    34                              <1> ;
    35                              <1> ; Each table is 16 bytes with the following format:
    36                              <1> ;   Offset  Size  Description
    37                              <1> ;   0x00    2     Maximum cylinders
    38                              <1> ;   0x02    1     Maximum heads
    39                              <1> ;   0x03    2     Reserved (was reduced write current cyl)
    40                              <1> ;   0x05    2     Write precompensation cylinder
    41                              <1> ;   0x07    1     Reserved (was max ECC burst length)
    42                              <1> ;   0x08    1     Control byte (step rate, etc.)
    43                              <1> ;   0x09    1     Standard timeout
    44                              <1> ;   0x0A    1     Format timeout
    45                              <1> ;   0x0B    1     Check timeout
    46                              <1> ;   0x0C    2     Landing zone cylinder
    47                              <1> ;   0x0E    1     Sectors per track
    48                              <1> ;   0x0F    1     Reserved
    49                              <1> 
    50                              <1> %define FDPT_MAX_CYL        0x00        ; Max cylinders (word)
    51                              <1> %define FDPT_MAX_HEAD       0x02        ; Max heads (byte)
    52                              <1> %define FDPT_RESERVED1      0x03        ; Reserved (word)
    53                              <1> %define FDPT_WR_PRECOMP     0x05        ; Write precomp cyl (word)
    54                              <1> %define FDPT_RESERVED2      0x07        ; Reserved (byte)
    55                              <1> %define FDPT_CONTROL        0x08        ; Control byte
    56                              <1> %define FDPT_STD_TIMEOUT    0x09        ; Standard timeout
    57                              <1> %define FDPT_FMT_TIMEOUT    0x0A        ; Format timeout
    58                              <1> %define FDPT_CHK_TIMEOUT    0x0B        ; Check timeout
    59                              <1> %define FDPT_LANDING        0x0C        ; Landing zone (word)
    60                              <1> %define FDPT_SECTORS        0x0E        ; Sectors per track
    61                              <1> %define FDPT_RESERVED3      0x0F        ; Reserved
    62                              <1> 
    63                              <1> %define FDPT_SIZE           16          ; Parameter table size
    64                              <1> 
    65                              <1> ;------------------------------------------------------------------------------
    66                              <1> ; FDPT Control Byte Bits
    67                              <1> ;------------------------------------------------------------------------------
    68                              <1> %define FDPT_CTL_DISABLE_RETRY  0x80    ; Disable ECC retry
    69                              <1> %define FDPT_CTL_MORE_8_HEADS   0x08    ; More than 8 heads
    70                              <1> 
    71                              <1> ;------------------------------------------------------------------------------
    72                              <1> ; Interrupt Vectors (in segment 0000h)
    73                              <1> ;------------------------------------------------------------------------------
    74                              <1> %define IVT_SEG             0x0000      ; Interrupt Vector Table segment
    75                              <1> 
    76                              <1> ; Hard disk vectors
    77                              <1> %define INT_13_VECTOR       0x004C      ; INT 13h vector (13h * 4)
    78                              <1> %define INT_40_VECTOR       0x0100      ; INT 40h vector (old INT 13h for floppy)
    79                              <1> %define INT_41_VECTOR       0x0104      ; INT 41h vector (HD0 FDPT pointer)
    80                              <1> %define INT_46_VECTOR       0x0118      ; INT 46h vector (HD1 FDPT pointer)
    81                              <1> %define INT_19_VECTOR       0x0064      ; INT 19h vector (bootstrap)
    82                              <1> 
    83                              <1> ;------------------------------------------------------------------------------
    84                              <1> ; Extended BDA (EBDA) for LBA Support
    85                              <1> ;------------------------------------------------------------------------------
    86                              <1> ; Some systems have an Extended BIOS Data Area starting at the top of
    87                              <1> ; conventional memory. LBA parameter tables may be stored there.
    88                              <1> ; The EBDA segment is stored at 40:0E.
    89                              <1> 
    90                              <1> %define BDA_EBDA_SEG        0x000E      ; EBDA segment pointer (word at 40:0E)
    91                              <1> 
    92                              <1> ;------------------------------------------------------------------------------
    93                              <1> ; CMOS RTC/NVRAM Ports (for reading drive type)
    94                              <1> ;------------------------------------------------------------------------------
    95                              <1> %define CMOS_ADDR           0x70        ; CMOS address port
    96                              <1> %define CMOS_DATA           0x71        ; CMOS data port
    97                              <1> 
    98                              <1> ; CMOS drive type locations
    99                              <1> %define CMOS_HD_TYPE        0x12        ; Hard disk types (high nibble=HD0, low=HD1)
   100                              <1> %define CMOS_HD0_EXT_TYPE   0x19        ; HD0 extended type if CMOS_HD_TYPE=0Fh
   101                              <1> %define CMOS_HD1_EXT_TYPE   0x1A        ; HD1 extended type if CMOS_HD_TYPE=F0h
   102                              <1> 
   103                              <1> ;------------------------------------------------------------------------------
   104                              <1> ; POST/Diagnostic Ports
   105                              <1> ;------------------------------------------------------------------------------
   106                              <1> %define POST_PORT           0x80        ; POST diagnostic port
   107                              <1> 
   108                              <1> ;------------------------------------------------------------------------------
   109                              <1> ; Keyboard Controller (for A20 gate)
   110                              <1> ;------------------------------------------------------------------------------
   111                              <1> %define KBC_DATA            0x60        ; Keyboard controller data port
   112                              <1> %define KBC_STATUS          0x64        ; Keyboard controller status/command
   113                              <1> 
   114                              <1> ;------------------------------------------------------------------------------
   115                              <1> ; INT 13h Status Codes (stored in BDA_HDD_STATUS)
   116                              <1> ;------------------------------------------------------------------------------
   117                              <1> %define HDD_ERR_NONE        0x00        ; No error
   118                              <1> %define HDD_ERR_BAD_CMD     0x01        ; Invalid command
   119                              <1> %define HDD_ERR_ADDR_MARK   0x02        ; Address mark not found
   120                              <1> %define HDD_ERR_WRITE_PROT  0x03        ; Write protected (not used for HD)
   121                              <1> %define HDD_ERR_SECT_NOT_FND 0x04       ; Sector not found
   122                              <1> %define HDD_ERR_RESET_FAIL  0x05        ; Reset failed
   123                              <1> %define HDD_ERR_MEDIA_CHG   0x06        ; Media changed (diskette)
   124                              <1> %define HDD_ERR_BAD_PARAM   0x07        ; Invalid parameter
   125                              <1> %define HDD_ERR_DMA_OVERRUN 0x08        ; DMA overrun
   126                              <1> %define HDD_ERR_DMA_BOUNDARY 0x09       ; DMA boundary error (64KB)
   127                              <1> %define HDD_ERR_BAD_SECTOR  0x0A        ; Bad sector flag
   128                              <1> %define HDD_ERR_BAD_TRACK   0x0B        ; Bad track flag
   129                              <1> %define HDD_ERR_MEDIA_TYPE  0x0C        ; Media type not found
   130                              <1> %define HDD_ERR_BAD_CYL     0x0D        ; Invalid number of sectors
   131                              <1> %define HDD_ERR_CTRL_DATA   0x0E        ; Control data address mark
   132                              <1> %define HDD_ERR_DMA_ARB     0x0F        ; DMA arbitration error
   133                              <1> %define HDD_ERR_BAD_CRC     0x10        ; CRC/ECC error
   134                              <1> %define HDD_ERR_ECC_CORR    0x11        ; ECC corrected data
   135                              <1> %define HDD_ERR_CONTROLLER  0x20        ; Controller failure
   136                              <1> %define HDD_ERR_SEEK        0x40        ; Seek failure
   137                              <1> %define HDD_ERR_TIMEOUT     0x80        ; Timeout
   138                              <1> %define HDD_ERR_NOT_READY   0xAA        ; Drive not ready
   139                              <1> %define HDD_ERR_UNDEFINED   0xBB        ; Undefined error
   140                              <1> %define HDD_ERR_WRITE_FAULT 0xCC        ; Write fault
   141                              <1> %define HDD_ERR_STATUS      0xE0        ; Status error
   142                              <1> %define HDD_ERR_SENSE       0xFF        ; Sense operation failed
   143                              <1> 
   144                              <1> ;------------------------------------------------------------------------------
   145                              <1> ; Macros for BDA Access
   146                              <1> ;------------------------------------------------------------------------------
   147                              <1> 
   148                              <1> ; Read byte from BDA
   149                              <1> ; Input: offset in BDA
   150                              <1> ; Output: AL = byte value, segment destroyed
   151                              <1> %macro BDA_READ_BYTE 1
   152                              <1>     push    es
   153                              <1>     mov     ax, BDA_SEG
   154                              <1>     mov     es, ax
   155                              <1>     mov     al, [es:%1]
   156                              <1>     pop     es
   157                              <1> %endmacro
   158                              <1> 
   159                              <1> ; Write byte to BDA
   160                              <1> ; Input: offset in BDA, value in AL
   161                              <1> %macro BDA_WRITE_BYTE 1
   162                              <1>     push    es
   163                              <1>     push    ax
   164                              <1>     mov     ax, BDA_SEG
   165                              <1>     mov     es, ax
   166                              <1>     pop     ax
   167                              <1>     mov     [es:%1], al
   168                              <1>     pop     es
   169                              <1> %endmacro
   170                              <1> 
   171                              <1> ; Read word from BDA
   172                              <1> ; Input: offset in BDA
   173                              <1> ; Output: AX = word value
   174                              <1> %macro BDA_READ_WORD 1
   175                              <1>     push    es
   176                              <1>     mov     ax, BDA_SEG
   177                              <1>     mov     es, ax
   178                              <1>     mov     ax, [es:%1]
   179                              <1>     pop     es
   180                              <1> %endmacro
   181                              <1> 
   182                              <1> %endif ; BDA_INC
    26                                  %include "wd_regs.inc"
     1                              <1> ;==============================================================================
     2                              <1> ; FluxRipper HDD BIOS - WD Controller Register Definitions
     3                              <1> ;==============================================================================
     4                              <1> ; Defines task file registers for WD1002/1003/1006/1007 compatible controllers.
     5                              <1> ;
     6                              <1> ; Register Map (AT-compatible, offset from base 0x1F0):
     7                              <1> ;   +0x0: DATA        - Data register (R/W)
     8                              <1> ;   +0x1: ERROR       - Error register (R) / Features (W)
     9                              <1> ;   +0x2: SECCNT      - Sector count (R/W)
    10                              <1> ;   +0x3: SECNUM      - Sector number / LBA [7:0] (R/W)
    11                              <1> ;   +0x4: CYL_LO      - Cylinder low / LBA [15:8] (R/W)
    12                              <1> ;   +0x5: CYL_HI      - Cylinder high / LBA [23:16] (R/W)
    13                              <1> ;   +0x6: SDH         - Size/Drive/Head / LBA [27:24] (R/W)
    14                              <1> ;   +0x7: STATUS      - Status register (R) / Command (W)
    15                              <1> ;
    16                              <1> ; Alternate registers (offset from 0x3F6):
    17                              <1> ;   +0x0: ALT_STATUS  - Alternate status (R) / Device Control (W)
    18                              <1> ;   +0x1: DRV_ADDR    - Drive address (R)
    19                              <1> ;
    20                              <1> ; SPDX-License-Identifier: BSD-3-Clause
    21                              <1> ; Copyright (c) 2025 FluxRipper Project
    22                              <1> ;==============================================================================
    23                              <1> 
    24                              <1> %ifndef WD_REGS_INC
    25                              <1> %define WD_REGS_INC
    26                              <1> 
    27                              <1> ;------------------------------------------------------------------------------
    28                              <1> ; Task File Register Offsets (from WD_BASE)
    29                              <1> ;------------------------------------------------------------------------------
    30                              <1> %define WD_DATA         0x00        ; Data register
    31                              <1> %define WD_ERROR        0x01        ; Error register (read)
    32                              <1> %define WD_FEATURES     0x01        ; Features register (write)
    33                              <1> %define WD_SECCNT       0x02        ; Sector count
    34                              <1> %define WD_SECNUM       0x03        ; Sector number (CHS) or LBA[7:0]
    35                              <1> %define WD_CYL_LO       0x04        ; Cylinder low (CHS) or LBA[15:8]
    36                              <1> %define WD_CYL_HI       0x05        ; Cylinder high (CHS) or LBA[23:16]
    37                              <1> %define WD_SDH          0x06        ; Size/Drive/Head
    38                              <1> %define WD_STATUS       0x07        ; Status register (read)
    39                              <1> %define WD_COMMAND      0x07        ; Command register (write)
    40                              <1> 
    41                              <1> ;------------------------------------------------------------------------------
    42                              <1> ; Alternate Register Offsets (from ALT_BASE = 0x3F6)
    43                              <1> ;------------------------------------------------------------------------------
    44                              <1> %define WD_ALT_STATUS   0x00        ; Alternate status (read, no IRQ clear)
    45                              <1> %define WD_DEV_CTRL     0x00        ; Device control (write)
    46                              <1> %define WD_DRV_ADDR     0x01        ; Drive address (read)
    47                              <1> 
    48                              <1> ;------------------------------------------------------------------------------
    49                              <1> ; Status Register Bits (WD_STATUS)
    50                              <1> ;------------------------------------------------------------------------------
    51                              <1> %define STS_BSY         0x80        ; Busy - controller executing
    52                              <1> %define STS_DRDY        0x40        ; Drive ready
    53                              <1> %define STS_DWF         0x20        ; Drive write fault
    54                              <1> %define STS_DSC         0x10        ; Drive seek complete
    55                              <1> %define STS_DRQ         0x08        ; Data request
    56                              <1> %define STS_CORR        0x04        ; Corrected data (ECC)
    57                              <1> %define STS_IDX         0x02        ; Index pulse
    58                              <1> %define STS_ERR         0x01        ; Error occurred
    59                              <1> 
    60                              <1> ;------------------------------------------------------------------------------
    61                              <1> ; Error Register Bits (WD_ERROR)
    62                              <1> ;------------------------------------------------------------------------------
    63                              <1> %define ERR_BBK         0x80        ; Bad block detected
    64                              <1> %define ERR_UNC         0x40        ; Uncorrectable data error
    65                              <1> %define ERR_MC          0x20        ; Media changed
    66                              <1> %define ERR_IDNF        0x10        ; ID not found
    67                              <1> %define ERR_MCR         0x08        ; Media change requested
    68                              <1> %define ERR_ABRT        0x04        ; Aborted command
    69                              <1> %define ERR_TK0NF       0x02        ; Track 0 not found
    70                              <1> %define ERR_AMNF        0x01        ; Address mark not found
    71                              <1> 
    72                              <1> ;------------------------------------------------------------------------------
    73                              <1> ; Device Control Register Bits (WD_DEV_CTRL)
    74                              <1> ;------------------------------------------------------------------------------
    75                              <1> %define CTRL_HOB        0x80        ; High order byte (48-bit LBA)
    76                              <1> %define CTRL_SRST       0x04        ; Software reset
    77                              <1> %define CTRL_NIEN       0x02        ; Disable interrupts
    78                              <1> 
    79                              <1> ;------------------------------------------------------------------------------
    80                              <1> ; SDH Register Format
    81                              <1> ;------------------------------------------------------------------------------
    82                              <1> ; Bit 7:5 = Size (sector size encoding, 010 = 512 bytes)
    83                              <1> ; Bit 4   = DRV (drive select: 0 = master, 1 = slave)
    84                              <1> ; Bit 3:0 = HEAD (head number 0-15)
    85                              <1> ;
    86                              <1> ; For LBA mode (drive must support it):
    87                              <1> ; Bit 7   = 1 (always)
    88                              <1> ; Bit 6   = LBA (1 = LBA mode)
    89                              <1> ; Bit 5   = 1 (always)
    90                              <1> ; Bit 4   = DRV
    91                              <1> ; Bit 3:0 = LBA[27:24]
    92                              <1> 
    93                              <1> %define SDH_SIZE_512    0xA0        ; 512-byte sectors, default
    94                              <1> %define SDH_DRV0        0x00        ; Drive 0 (master)
    95                              <1> %define SDH_DRV1        0x10        ; Drive 1 (slave)
    96                              <1> %define SDH_LBA         0x40        ; LBA mode bit
    97                              <1> 
    98                              <1> ;------------------------------------------------------------------------------
    99                              <1> ; Command Codes
   100                              <1> ;------------------------------------------------------------------------------
   101                              <1> ; Basic Commands (all personalities)
   102                              <1> %define CMD_RECALIBRATE 0x10        ; Recalibrate (seek to track 0)
   103                              <1> %define CMD_READ        0x20        ; Read sectors (with retry)
   104                              <1> %define CMD_READ_NR     0x21        ; Read sectors (no retry)
   105                              <1> %define CMD_WRITE       0x30        ; Write sectors (with retry)
   106                              <1> %define CMD_WRITE_NR    0x31        ; Write sectors (no retry)
   107                              <1> %define CMD_VERIFY      0x40        ; Verify sectors (with retry)
   108                              <1> %define CMD_VERIFY_NR   0x41        ; Verify sectors (no retry)
   109                              <1> %define CMD_FORMAT      0x50        ; Format track
   110                              <1> %define CMD_SEEK        0x70        ; Seek to cylinder
   111                              <1> %define CMD_DIAG        0x90        ; Execute drive diagnostics
   112                              <1> %define CMD_INIT_PARAM  0x91        ; Initialize drive parameters
   113                              <1> %define CMD_READ_LONG   0x22        ; Read long (sector + ECC)
   114                              <1> %define CMD_WRITE_LONG  0x32        ; Write long (sector + ECC)
   115                              <1> 
   116                              <1> ; WD1006 (RLL) Additional Commands
   117                              <1> %define CMD_READ_BUF    0xE4        ; Read sector buffer
   118                              <1> %define CMD_WRITE_BUF   0xE8        ; Write sector buffer
   119                              <1> 
   120                              <1> ; WD1007 (ESDI) Additional Commands
   121                              <1> %define CMD_IDENTIFY    0xEC        ; Identify drive (returns 256 words)
   122                              <1> %define CMD_SET_MULTI   0xC6        ; Set multiple mode
   123                              <1> %define CMD_READ_MULTI  0xC4        ; Read multiple sectors
   124                              <1> %define CMD_WRITE_MULTI 0xC5        ; Write multiple sectors
   125                              <1> 
   126                              <1> ;------------------------------------------------------------------------------
   127                              <1> ; Command Timeouts (in loop iterations - calibrate for target CPU)
   128                              <1> ;------------------------------------------------------------------------------
   129                              <1> %define TIMEOUT_BSY_CLR     0xFFFF  ; Wait for BSY clear
   130                              <1> %define TIMEOUT_DRQ_SET     0xFFFF  ; Wait for DRQ set
   131                              <1> %define TIMEOUT_DRDY        0xFFFF  ; Wait for DRDY
   132                              <1> %define TIMEOUT_SEEK        0xFFFF  ; Wait for seek complete
   133                              <1> %define TIMEOUT_RESET       0xFFFF  ; Wait for reset complete
   134                              <1> 
   135                              <1> ;------------------------------------------------------------------------------
   136                              <1> ; Macros for WD Register Access
   137                              <1> ;------------------------------------------------------------------------------
   138                              <1> 
   139                              <1> ; Wait for BSY clear with timeout
   140                              <1> ; Input: DX = base port, CX = timeout counter
   141                              <1> ; Output: CF=0 success, CF=1 timeout, AL = final status
   142                              <1> %macro WD_WAIT_NOT_BSY 0
   143                              <1>     %%loop:
   144                              <1>         in      al, dx
   145                              <1>         test    al, STS_BSY
   146                              <1>         jz      %%done
   147                              <1>         loop    %%loop
   148                              <1>         stc                         ; Set carry = timeout
   149                              <1>         jmp     %%exit
   150                              <1>     %%done:
   151                              <1>         clc                         ; Clear carry = success
   152                              <1>     %%exit:
   153                              <1> %endmacro
   154                              <1> 
   155                              <1> ; Wait for DRQ set with timeout
   156                              <1> ; Input: DX = base port, CX = timeout counter
   157                              <1> ; Output: CF=0 success, CF=1 timeout/error, AL = final status
   158                              <1> %macro WD_WAIT_DRQ 0
   159                              <1>     %%loop:
   160                              <1>         in      al, dx
   161                              <1>         test    al, STS_ERR
   162                              <1>         jnz     %%error
   163                              <1>         test    al, STS_DRQ
   164                              <1>         jnz     %%done
   165                              <1>         loop    %%loop
   166                              <1>         stc
   167                              <1>         jmp     %%exit
   168                              <1>     %%error:
   169                              <1>         stc
   170                              <1>         jmp     %%exit
   171                              <1>     %%done:
   172                              <1>         clc
   173                              <1>     %%exit:
   174                              <1> %endmacro
   175                              <1> 
   176                              <1> ; Wait for DRDY set with timeout
   177                              <1> ; Input: DX = base port, CX = timeout counter
   178                              <1> ; Output: CF=0 success, CF=1 timeout, AL = final status
   179                              <1> %macro WD_WAIT_DRDY 0
   180                              <1>     %%loop:
   181                              <1>         in      al, dx
   182                              <1>         test    al, STS_DRDY
   183                              <1>         jnz     %%done
   184                              <1>         loop    %%loop
   185                              <1>         stc
   186                              <1>         jmp     %%exit
   187                              <1>     %%done:
   188                              <1>         clc
   189                              <1>     %%exit:
   190                              <1> %endmacro
   191                              <1> 
   192                              <1> %endif ; WD_REGS_INC
    27                                  
    28                                  ;==============================================================================
    29                                  ; ROM Header (Required by BIOS)
    30                                  ;==============================================================================
    31                                  ; The first three bytes must be:
    32                                  ;   55 AA nn
    33                                  ; Where nn is the ROM size in 512-byte blocks.
    34                                  
    35                                  rom_header:
    36 00000000 55AA                        db      0x55, 0xAA              ; ROM signature
    37 00000002 20                          db      ROM_BLOCKS              ; Size in 512-byte blocks
    38                                  
    39                                      ; Entry point - BIOS will FAR CALL here with CS:0003
    40 00000003 EB64                        jmp     near rom_init
    41                                  
    42                                  ;------------------------------------------------------------------------------
    43                                  ; Reserved area / PnP Header location
    44                                  ;------------------------------------------------------------------------------
    45                                  %if ENABLE_PNP
    46                                      ; Align to 16-byte boundary for PnP header
    47 00000005 00<rep 15h>                 times (0x1A - ($ - $$)) db 0
    48                                  
    49                                  ;==============================================================================
    50                                  ; PnP Header (16KB Build Only)
    51                                  ;==============================================================================
    52                                  ; ISA Plug and Play expansion header per PnP BIOS Specification 1.0a
    53                                  pnp_header:
    54 0000001A 24506E50                    db      '$PnP'                  ; Signature
    55 0000001E 01                          db      0x01                    ; Structure revision (1.0)
    56 0000001F 02                          db      0x02                    ; Header length (32 bytes / 16 = 2)
    57 00000020 0000                        dw      0                       ; Offset to next header (0 = none)
    58 00000022 00                          db      0                       ; Reserved
    59 00000023 00                          db      0                       ; Checksum (calculated later)
    60 00000024 01584C46                    dd      PNP_DEVICE_ID           ; Device identifier
    61 00000028 [3B00]                      dw      pnp_mfg_string          ; Manufacturer string offset
    62 0000002A [4E00]                      dw      pnp_prod_string         ; Product name string offset
    63 0000002C 03                          db      3                       ; Device type: Mass Storage
    64 0000002D 00                          db      0                       ; Device sub-type: Generic
    65 0000002E 00                          db      0                       ; Device interface
    66 0000002F 0000                        dw      0                       ; Device indicators
    67 00000031 0000                        dw      0                       ; Boot connection vector (0 = use INT)
    68 00000033 0000                        dw      0                       ; Disconnect vector
    69 00000035 [6200]                      dw      pnp_bev                 ; Bootstrap Entry Vector
    70 00000037 0000                        dw      0                       ; Reserved
    71 00000039 0000                        dw      0                       ; Static resource info (0 = none)
    72                                  
    73                                  ; PnP Device ID: FLX0100 (FluxRipper HDD Controller)
    74                                  ; Format: EISA compressed vendor ID (3 chars) + 4-digit hex product
    75                                  PNP_DEVICE_ID   equ     0x464C5801  ; 'FLX' + 0x0100
    76                                  
    77                                  pnp_mfg_string:
    78 0000003B 466C75785269707065-         db      "FluxRipper Project", 0
    78 00000044 722050726F6A656374-
    78 0000004D 00                 
    79                                  
    80                                  pnp_prod_string:
    81 0000004E 466C75785269707065-         db      "FluxRipper HDD BIOS", 0
    81 00000057 72204844442042494F-
    81 00000060 5300               
    82                                  
    83                                  ; Bootstrap Entry Vector - called for INT 19h boot
    84                                  pnp_bev:
    85                                      ; This is called when BIOS wants to boot from this device
    86 00000062 9C                          pushf
    87 00000063 2EFF1E[9431]                call    far [cs:old_int19]      ; Chain to original INT 19h
    88                                      ; If we return here, boot failed - just return
    89 00000068 CB                          retf
    90                                  %else
    91                                      ; No PnP header - just pad
    92                                      times (0x20 - ($ - $$)) db 0
    93                                  %endif
    94                                  
    95                                  ;==============================================================================
    96                                  ; ROM Initialization Entry Point
    97                                  ;==============================================================================
    98                                  ; Called by system BIOS during POST via FAR CALL to CS:0003.
    99                                  ; Must preserve all registers except AX.
   100                                  ;
   101                                  ; Our job:
   102                                  ;   1. Check for FluxRipper FPGA (not a generic WD card)
   103                                  ;   2. Wait for FPGA discovery to complete
   104                                  ;   3. Read detected geometry
   105                                  ;   4. Set up Fixed Disk Parameter Tables
   106                                  ;   5. Hook INT 13h
   107                                  ;   6. Update drive count in BDA
   108                                  ;   7. Display banner
   109                                  ;==============================================================================
   110                                  
   111                                  rom_init:
   112                                      ; Save registers
   113 00000069 53                          push    bx
   114 0000006A 51                          push    cx
   115 0000006B 52                          push    dx
   116 0000006C 56                          push    si
   117 0000006D 57                          push    di
   118 0000006E 55                          push    bp
   119 0000006F 1E                          push    ds
   120 00000070 06                          push    es
   121                                  
   122                                      ; Set DS to ROM segment (CS should already be correct)
   123 00000071 0E                          push    cs
   124 00000072 1F                          pop     ds
   125                                  
   126                                      ; Check if we should initialize (detect FluxRipper FPGA)
   127 00000073 E83500                      call    detect_fluxripper
   128 00000076 722A                        jc      .init_done              ; CF=1: Not FluxRipper, skip init
   129                                  
   130                                      ; Display initialization banner
   131 00000078 BE[EF0E]                    mov     si, msg_banner
   132 0000007B E84200                      call    print_string
   133                                  
   134                                      ; Wait for FPGA drive discovery to complete
   135 0000007E E85301                      call    wait_discovery
   136 00000081 7219                        jc      .init_error             ; CF=1: Discovery timeout
   137                                  
   138                                      ; Read detected geometry from FPGA
   139 00000083 E87C01                      call    read_geometry
   140 00000086 7214                        jc      .init_error             ; CF=1: No drives detected
   141                                  
   142                                      ; Set up Fixed Disk Parameter Tables in our ROM
   143 00000088 E8AB02                      call    setup_fdpt
   144                                  
   145                                      ; Hook INT 13h
   146 0000008B E84103                      call    hook_int13h
   147                                  
   148                                      ; Update BDA with drive count
   149 0000008E E86303                      call    update_bda
   150                                  
   151                                      ; Display detected drives
   152 00000091 E87C03                      call    display_drives
   153                                  
   154                                      ; Success
   155 00000094 BE[480F]                    mov     si, msg_ready
   156 00000097 E82600                      call    print_string
   157 0000009A EB06                        jmp     .init_done
   158                                  
   159                                  .init_error:
   160                                      ; Display error message
   161 0000009C BE[510F]                    mov     si, msg_error
   162 0000009F E81E00                      call    print_string
   163                                  
   164                                  .init_done:
   165                                      ; Restore registers
   166 000000A2 07                          pop     es
   167 000000A3 1F                          pop     ds
   168 000000A4 5D                          pop     bp
   169 000000A5 5F                          pop     di
   170 000000A6 5E                          pop     si
   171 000000A7 5A                          pop     dx
   172 000000A8 59                          pop     cx
   173 000000A9 5B                          pop     bx
   174                                  
   175                                      ; Return to BIOS (AX is not preserved per convention)
   176 000000AA CB                          retf
   177                                  
   178                                  ;==============================================================================
   179                                  ; FluxRipper Detection
   180                                  ;==============================================================================
   181                                  ; Check if this is a FluxRipper FPGA by reading a signature register.
   182                                  ; Returns: CF=0 if FluxRipper detected, CF=1 if not
   183                                  ;==============================================================================
   184                                  detect_fluxripper:
   185 000000AB 50                          push    ax
   186 000000AC 52                          push    dx
   187                                  
   188                                      ; Read FPGA signature from discovery register base
   189 000000AD BA7002                      mov     dx, WD_BASE_PRIMARY + DISC_REG_BASE
   190 000000B0 EC                          in      al, dx
   191                                  
   192                                      ; Check for FluxRipper signature (magic byte)
   193 000000B1 3CFB                        cmp     al, 0xFB                ; 'FB' for FluxRipper Base
   194 000000B3 7407                        je      .found
   195 000000B5 3CFD                        cmp     al, 0xFD                ; 'FD' for FluxRipper Discovery
   196 000000B7 7403                        je      .found
   197                                  
   198                                      ; Not FluxRipper - could be real WD controller
   199 000000B9 F9                          stc
   200 000000BA EB01                        jmp     .done
   201                                  
   202                                  .found:
   203 000000BC F8                          clc
   204                                  
   205                                  .done:
   206 000000BD 5A                          pop     dx
   207 000000BE 58                          pop     ax
   208 000000BF C3                          ret
   209                                  
   210                                  ;==============================================================================
   211                                  ; Include Sub-Modules
   212                                  ;==============================================================================
   213                                  %include "util.asm"
     1                              <1> ;==============================================================================
     2                              <1> ; FluxRipper HDD BIOS - Utility Functions
     3                              <1> ;==============================================================================
     4                              <1> ; Common utility routines:
     5                              <1> ;   - Delay loops (calibrated for various CPU speeds)
     6                              <1> ;   - String output
     7                              <1> ;   - Hex/decimal printing
     8                              <1> ;   - Port I/O helpers
     9                              <1> ;
    10                              <1> ; SPDX-License-Identifier: BSD-3-Clause
    11                              <1> ; Copyright (c) 2025 FluxRipper Project
    12                              <1> ;==============================================================================
    13                              <1> 
    14                              <1> ;==============================================================================
    15                              <1> ; Print String (Null-Terminated)
    16                              <1> ;==============================================================================
    17                              <1> ; Input:  DS:SI = pointer to null-terminated string
    18                              <1> ; Output: None
    19                              <1> ; Destroys: AX, BX, SI
    20                              <1> ;==============================================================================
    21                              <1> print_string:
    22 000000C0 50                  <1>     push    ax
    23 000000C1 53                  <1>     push    bx
    24 000000C2 56                  <1>     push    si
    25                              <1> 
    26                              <1> .loop:
    27 000000C3 AC                  <1>     lodsb                           ; Load byte from DS:SI into AL, increment SI
    28 000000C4 08C0                <1>     or      al, al                  ; Check for null terminator
    29 000000C6 7409                <1>     jz      .done
    30                              <1> 
    31 000000C8 B40E                <1>     mov     ah, 0x0E                ; BIOS teletype output
    32 000000CA BB0700              <1>     mov     bx, 0x0007              ; Page 0, light gray attribute
    33 000000CD CD10                <1>     int     0x10                    ; Call video BIOS
    34 000000CF EBF2                <1>     jmp     .loop
    35                              <1> 
    36                              <1> .done:
    37 000000D1 5E                  <1>     pop     si
    38 000000D2 5B                  <1>     pop     bx
    39 000000D3 58                  <1>     pop     ax
    40 000000D4 C3                  <1>     ret
    41                              <1> 
    42                              <1> ;==============================================================================
    43                              <1> ; Print Character
    44                              <1> ;==============================================================================
    45                              <1> ; Input:  AL = character to print
    46                              <1> ; Output: None
    47                              <1> ; Destroys: AX, BX
    48                              <1> ;==============================================================================
    49                              <1> print_char:
    50 000000D5 50                  <1>     push    ax
    51 000000D6 53                  <1>     push    bx
    52                              <1> 
    53 000000D7 B40E                <1>     mov     ah, 0x0E                ; BIOS teletype output
    54 000000D9 BB0700              <1>     mov     bx, 0x0007              ; Page 0, light gray attribute
    55 000000DC CD10                <1>     int     0x10
    56                              <1> 
    57 000000DE 5B                  <1>     pop     bx
    58 000000DF 58                  <1>     pop     ax
    59 000000E0 C3                  <1>     ret
    60                              <1> 
    61                              <1> ;==============================================================================
    62                              <1> ; Print Newline (CR+LF)
    63                              <1> ;==============================================================================
    64                              <1> print_newline:
    65 000000E1 50                  <1>     push    ax
    66 000000E2 B00D                <1>     mov     al, 0x0D
    67 000000E4 E8EEFF              <1>     call    print_char
    68 000000E7 B00A                <1>     mov     al, 0x0A
    69 000000E9 E8E9FF              <1>     call    print_char
    70 000000EC 58                  <1>     pop     ax
    71 000000ED C3                  <1>     ret
    72                              <1> 
    73                              <1> ;==============================================================================
    74                              <1> ; Print Hex Byte
    75                              <1> ;==============================================================================
    76                              <1> ; Input:  AL = byte to print as 2 hex digits
    77                              <1> ; Output: None
    78                              <1> ; Destroys: AX
    79                              <1> ;==============================================================================
    80                              <1> print_hex_byte:
    81 000000EE 50                  <1>     push    ax
    82 000000EF 51                  <1>     push    cx
    83                              <1> 
    84 000000F0 88C1                <1>     mov     cl, al                  ; Save original value
    85 000000F2 C0E804              <1>     shr     al, 4                   ; Get high nibble
    86 000000F5 E80A00              <1>     call    .print_nibble
    87 000000F8 88C8                <1>     mov     al, cl                  ; Restore original
    88 000000FA 240F                <1>     and     al, 0x0F                ; Get low nibble
    89 000000FC E80300              <1>     call    .print_nibble
    90                              <1> 
    91 000000FF 59                  <1>     pop     cx
    92 00000100 58                  <1>     pop     ax
    93 00000101 C3                  <1>     ret
    94                              <1> 
    95                              <1> .print_nibble:
    96 00000102 3C0A                <1>     cmp     al, 10
    97 00000104 7204                <1>     jb      .digit
    98 00000106 0437                <1>     add     al, 'A' - 10
    99 00000108 EB02                <1>     jmp     .output
   100                              <1> .digit:
   101 0000010A 0430                <1>     add     al, '0'
   102                              <1> .output:
   103 0000010C E8C6FF              <1>     call    print_char
   104 0000010F C3                  <1>     ret
   105                              <1> 
   106                              <1> ;==============================================================================
   107                              <1> ; Print Hex Word
   108                              <1> ;==============================================================================
   109                              <1> ; Input:  AX = word to print as 4 hex digits
   110                              <1> ; Output: None
   111                              <1> ; Destroys: AX
   112                              <1> ;==============================================================================
   113                              <1> print_hex_word:
   114 00000110 50                  <1>     push    ax
   115 00000111 51                  <1>     push    cx
   116                              <1> 
   117 00000112 89C1                <1>     mov     cx, ax                  ; Save word
   118 00000114 88E0                <1>     mov     al, ah                  ; Print high byte first
   119 00000116 E8D5FF              <1>     call    print_hex_byte
   120 00000119 88C8                <1>     mov     al, cl                  ; Print low byte
   121 0000011B E8D0FF              <1>     call    print_hex_byte
   122                              <1> 
   123 0000011E 59                  <1>     pop     cx
   124 0000011F 58                  <1>     pop     ax
   125 00000120 C3                  <1>     ret
   126                              <1> 
   127                              <1> ;==============================================================================
   128                              <1> ; Print Decimal Word (No Leading Zeros)
   129                              <1> ;==============================================================================
   130                              <1> ; Input:  AX = 16-bit unsigned number
   131                              <1> ; Output: None
   132                              <1> ; Destroys: AX, CX, DX
   133                              <1> ;==============================================================================
   134                              <1> print_decimal:
   135 00000121 50                  <1>     push    ax
   136 00000122 53                  <1>     push    bx
   137 00000123 51                  <1>     push    cx
   138 00000124 52                  <1>     push    dx
   139                              <1> 
   140 00000125 B90000              <1>     mov     cx, 0                   ; Digit counter
   141 00000128 BB0A00              <1>     mov     bx, 10                  ; Divisor
   142                              <1> 
   143                              <1> .divide_loop:
   144 0000012B 31D2                <1>     xor     dx, dx                  ; Clear high word
   145 0000012D F7F3                <1>     div     bx                      ; AX = AX/10, DX = remainder
   146 0000012F 52                  <1>     push    dx                      ; Save digit on stack
   147 00000130 41                  <1>     inc     cx                      ; Count digits
   148 00000131 09C0                <1>     or      ax, ax                  ; Check if quotient is zero
   149 00000133 75F6                <1>     jnz     .divide_loop
   150                              <1> 
   151                              <1>     ; Print digits in reverse order (from stack)
   152                              <1> .print_loop:
   153 00000135 58                  <1>     pop     ax                      ; Get digit
   154 00000136 0430                <1>     add     al, '0'                 ; Convert to ASCII
   155 00000138 E89AFF              <1>     call    print_char
   156 0000013B E2F8                <1>     loop    .print_loop
   157                              <1> 
   158 0000013D 5A                  <1>     pop     dx
   159 0000013E 59                  <1>     pop     cx
   160 0000013F 5B                  <1>     pop     bx
   161 00000140 58                  <1>     pop     ax
   162 00000141 C3                  <1>     ret
   163                              <1> 
   164                              <1> ;==============================================================================
   165                              <1> ; Print Decimal Dword (32-bit)
   166                              <1> ;==============================================================================
   167                              <1> ; Input:  DX:AX = 32-bit unsigned number
   168                              <1> ; Output: None
   169                              <1> ; Destroys: AX, BX, CX, DX
   170                              <1> ;==============================================================================
   171                              <1> print_decimal_dword:
   172 00000142 50                  <1>     push    ax
   173 00000143 53                  <1>     push    bx
   174 00000144 51                  <1>     push    cx
   175 00000145 52                  <1>     push    dx
   176 00000146 56                  <1>     push    si
   177                              <1> 
   178 00000147 B90000              <1>     mov     cx, 0                   ; Digit counter
   179                              <1> 
   180                              <1> .divide_loop:
   181                              <1>     ; 32-bit division by 10
   182 0000014A 89C6                <1>     mov     si, ax                  ; Save low word
   183 0000014C 89D0                <1>     mov     ax, dx                  ; Divide high word first
   184 0000014E 31D2                <1>     xor     dx, dx
   185 00000150 BB0A00              <1>     mov     bx, 10
   186 00000153 F7F3                <1>     div     bx                      ; AX = high quotient, DX = remainder
   187 00000155 89C3                <1>     mov     bx, ax                  ; Save high quotient
   188 00000157 89F0                <1>     mov     ax, si                  ; Get low word + remainder*65536
   189 00000159 F736[7701]          <1>     div     word [.divisor]         ; AX = low quotient, DX = final remainder
   190 0000015D 52                  <1>     push    dx                      ; Save digit
   191 0000015E 89DA                <1>     mov     dx, bx                  ; Restore high quotient
   192 00000160 41                  <1>     inc     cx
   193                              <1> 
   194                              <1>     ; Check if result is zero
   195 00000161 09C0                <1>     or      ax, ax
   196 00000163 75E5                <1>     jnz     .divide_loop
   197 00000165 09D2                <1>     or      dx, dx
   198 00000167 75E1                <1>     jnz     .divide_loop
   199                              <1> 
   200                              <1>     ; Print digits
   201                              <1> .print_loop:
   202 00000169 58                  <1>     pop     ax
   203 0000016A 0430                <1>     add     al, '0'
   204 0000016C E866FF              <1>     call    print_char
   205 0000016F E2F8                <1>     loop    .print_loop
   206                              <1> 
   207 00000171 5E                  <1>     pop     si
   208 00000172 5A                  <1>     pop     dx
   209 00000173 59                  <1>     pop     cx
   210 00000174 5B                  <1>     pop     bx
   211 00000175 58                  <1>     pop     ax
   212 00000176 C3                  <1>     ret
   213                              <1> 
   214                              <1> .divisor:
   215 00000177 0A00                <1>     dw      10
   216                              <1> 
   217                              <1> ;==============================================================================
   218                              <1> ; Delay Microseconds (Approximate)
   219                              <1> ;==============================================================================
   220                              <1> ; Input:  CX = delay in approximate microseconds (very approximate on old PCs)
   221                              <1> ; Output: None
   222                              <1> ; Destroys: CX
   223                              <1> ;
   224                              <1> ; This uses the 8254 timer to provide reasonably accurate delays.
   225                              <1> ; Falls back to I/O port delay on systems where timer access fails.
   226                              <1> ;==============================================================================
   227                              <1> delay_us:
   228 00000179 50                  <1>     push    ax
   229 0000017A 51                  <1>     push    cx
   230                              <1> 
   231                              <1>     ; Use I/O port 0x80 for delay - each I/O takes ~1us on typical systems
   232                              <1> .delay_loop:
   233 0000017B E480                <1>     in      al, 0x80                ; ~1us delay
   234 0000017D E2FC                <1>     loop    .delay_loop
   235                              <1> 
   236 0000017F 59                  <1>     pop     cx
   237 00000180 58                  <1>     pop     ax
   238 00000181 C3                  <1>     ret
   239                              <1> 
   240                              <1> ;==============================================================================
   241                              <1> ; Delay Milliseconds
   242                              <1> ;==============================================================================
   243                              <1> ; Input:  CX = delay in milliseconds
   244                              <1> ; Output: None
   245                              <1> ; Destroys: CX
   246                              <1> ;==============================================================================
   247                              <1> delay_ms:
   248 00000182 50                  <1>     push    ax
   249 00000183 51                  <1>     push    cx
   250 00000184 52                  <1>     push    dx
   251                              <1> 
   252                              <1> .ms_loop:
   253 00000185 51                  <1>     push    cx
   254 00000186 B9E803              <1>     mov     cx, 1000                ; 1000 microseconds = 1 ms
   255 00000189 E8EDFF              <1>     call    delay_us
   256 0000018C 59                  <1>     pop     cx
   257 0000018D E2F6                <1>     loop    .ms_loop
   258                              <1> 
   259 0000018F 5A                  <1>     pop     dx
   260 00000190 59                  <1>     pop     cx
   261 00000191 58                  <1>     pop     ax
   262 00000192 C3                  <1>     ret
   263                              <1> 
   264                              <1> ;==============================================================================
   265                              <1> ; Wait for I/O Port Bit Set (with Timeout)
   266                              <1> ;==============================================================================
   267                              <1> ; Input:  DX = I/O port
   268                              <1> ;         AL = bit mask to check
   269                              <1> ;         CX = timeout in iterations (0 = infinite)
   270                              <1> ; Output: CF = 0 if bit set, CF = 1 if timeout
   271                              <1> ;         AL = final port value
   272                              <1> ; Destroys: AX, CX
   273                              <1> ;==============================================================================
   274                              <1> wait_bit_set:
   275 00000193 53                  <1>     push    bx
   276 00000194 88C7                <1>     mov     bh, al                  ; Save mask
   277                              <1> 
   278                              <1> .loop:
   279 00000196 EC                  <1>     in      al, dx
   280 00000197 84F8                <1>     test    al, bh
   281 00000199 7509                <1>     jnz     .found
   282 0000019B 09C9                <1>     or      cx, cx                  ; Check for infinite wait
   283 0000019D 74F7                <1>     jz      .loop                   ; CX=0 means wait forever
   284 0000019F E2F5                <1>     loop    .loop
   285 000001A1 F9                  <1>     stc                             ; Timeout
   286 000001A2 EB01                <1>     jmp     .done
   287                              <1> 
   288                              <1> .found:
   289 000001A4 F8                  <1>     clc                             ; Success
   290                              <1> 
   291                              <1> .done:
   292 000001A5 5B                  <1>     pop     bx
   293 000001A6 C3                  <1>     ret
   294                              <1> 
   295                              <1> ;==============================================================================
   296                              <1> ; Wait for I/O Port Bit Clear (with Timeout)
   297                              <1> ;==============================================================================
   298                              <1> ; Input:  DX = I/O port
   299                              <1> ;         AL = bit mask to check
   300                              <1> ;         CX = timeout in iterations (0 = infinite)
   301                              <1> ; Output: CF = 0 if bit clear, CF = 1 if timeout
   302                              <1> ;         AL = final port value
   303                              <1> ; Destroys: AX, CX
   304                              <1> ;==============================================================================
   305                              <1> wait_bit_clear:
   306 000001A7 53                  <1>     push    bx
   307 000001A8 88C7                <1>     mov     bh, al                  ; Save mask
   308                              <1> 
   309                              <1> .loop:
   310 000001AA EC                  <1>     in      al, dx
   311 000001AB 84F8                <1>     test    al, bh
   312 000001AD 7409                <1>     jz      .found
   313 000001AF 09C9                <1>     or      cx, cx
   314 000001B1 74F7                <1>     jz      .loop
   315 000001B3 E2F5                <1>     loop    .loop
   316 000001B5 F9                  <1>     stc
   317 000001B6 EB01                <1>     jmp     .done
   318                              <1> 
   319                              <1> .found:
   320 000001B8 F8                  <1>     clc
   321                              <1> 
   322                              <1> .done:
   323 000001B9 5B                  <1>     pop     bx
   324 000001BA C3                  <1>     ret
   325                              <1> 
   326                              <1> ;==============================================================================
   327                              <1> ; Memory Set (Fill Memory with Byte)
   328                              <1> ;==============================================================================
   329                              <1> ; Input:  ES:DI = destination pointer
   330                              <1> ;         AL    = fill byte
   331                              <1> ;         CX    = byte count
   332                              <1> ; Output: None
   333                              <1> ; Destroys: CX, DI
   334                              <1> ;==============================================================================
   335                              <1> memset:
   336 000001BB 50                  <1>     push    ax
   337 000001BC F3AA                <1>     rep stosb
   338 000001BE 58                  <1>     pop     ax
   339 000001BF C3                  <1>     ret
   340                              <1> 
   341                              <1> ;==============================================================================
   342                              <1> ; Memory Copy
   343                              <1> ;==============================================================================
   344                              <1> ; Input:  DS:SI = source pointer
   345                              <1> ;         ES:DI = destination pointer
   346                              <1> ;         CX    = byte count
   347                              <1> ; Output: None
   348                              <1> ; Destroys: CX, SI, DI
   349                              <1> ;==============================================================================
   350                              <1> memcpy:
   351 000001C0 50                  <1>     push    ax
   352 000001C1 F3A4                <1>     rep movsb
   353 000001C3 58                  <1>     pop     ax
   354 000001C4 C3                  <1>     ret
   355                              <1> 
   356                              <1> ;==============================================================================
   357                              <1> ; Compare Memory
   358                              <1> ;==============================================================================
   359                              <1> ; Input:  DS:SI = first buffer
   360                              <1> ;         ES:DI = second buffer
   361                              <1> ;         CX    = byte count
   362                              <1> ; Output: ZF = 1 if equal, ZF = 0 if different
   363                              <1> ; Destroys: CX, SI, DI
   364                              <1> ;==============================================================================
   365                              <1> memcmp:
   366 000001C5 50                  <1>     push    ax
   367 000001C6 F3A6                <1>     repe cmpsb
   368 000001C8 58                  <1>     pop     ax
   369 000001C9 C3                  <1>     ret
   370                              <1> 
   371                              <1> ;==============================================================================
   372                              <1> ; Check for Keypress (Non-blocking)
   373                              <1> ;==============================================================================
   374                              <1> ; Output: ZF = 1 if no key, ZF = 0 if key available
   375                              <1> ;         If key available: AH = scan code, AL = ASCII
   376                              <1> ; Destroys: AX
   377                              <1> ;==============================================================================
   378                              <1> check_key:
   379 000001CA B401                <1>     mov     ah, 0x01                ; Check keyboard buffer
   380 000001CC CD16                <1>     int     0x16
   381 000001CE C3                  <1>     ret                             ; ZF reflects result
   382                              <1> 
   383                              <1> ;==============================================================================
   384                              <1> ; Get Key (Blocking)
   385                              <1> ;==============================================================================
   386                              <1> ; Output: AH = scan code, AL = ASCII
   387                              <1> ; Destroys: AX
   388                              <1> ;==============================================================================
   389                              <1> get_key:
   390 000001CF B400                <1>     mov     ah, 0x00                ; Wait for keypress
   391 000001D1 CD16                <1>     int     0x16
   392 000001D3 C3                  <1>     ret
   214                                  %include "discovery.asm"
     1                              <1> ;==============================================================================
     2                              <1> ; FluxRipper HDD BIOS - FPGA Discovery Register Access
     3                              <1> ;==============================================================================
     4                              <1> ; Routines for reading drive discovery information from FPGA registers.
     5                              <1> ;
     6                              <1> ; The FPGA automatically detects connected drives during power-up:
     7                              <1> ;   1. PHY probe - Check for drive presence on ST-506/ESDI interface
     8                              <1> ;   2. Rate detect - Measure data rate (5/7.5/10/15 Mbps)
     9                              <1> ;   3. Decode test - Verify MFM/RLL decoding
    10                              <1> ;   4. Geometry scan - Read track 0 to determine C/H/S
    11                              <1> ;
    12                              <1> ; This BIOS simply reads the results rather than probing the drive.
    13                              <1> ;
    14                              <1> ; SPDX-License-Identifier: BSD-3-Clause
    15                              <1> ; Copyright (c) 2025 FluxRipper Project
    16                              <1> ;==============================================================================
    17                              <1> 
    18                              <1> %include "discovery.inc"
     1                              <2> ;==============================================================================
     2                              <2> ; FluxRipper HDD BIOS - FPGA Discovery Register Definitions
     3                              <2> ;==============================================================================
     4                              <2> ; Defines the register map for reading FPGA auto-detection results.
     5                              <2> ;
     6                              <2> ; The FPGA automatically detects connected drives during power-up and
     7                              <2> ; populates these registers with discovered geometry and capabilities.
     8                              <2> ; The BIOS reads these registers instead of probing the drive directly.
     9                              <2> ;
    10                              <2> ; Register Base: WD_BASE + 0x80 (e.g., 0x1F0 + 0x80 = 0x270)
    11                              <2> ;
    12                              <2> ; SPDX-License-Identifier: BSD-3-Clause
    13                              <2> ; Copyright (c) 2025 FluxRipper Project
    14                              <2> ;==============================================================================
    15                              <2> 
    16                              <2> %ifndef DISCOVERY_INC
    17                              <2> %define DISCOVERY_INC
    18                              <2> 
    19                              <2> ;------------------------------------------------------------------------------
    20                              <2> ; Discovery Register Offsets (from DISC_REG_BASE = WD_BASE + 0x80)
    21                              <2> ;------------------------------------------------------------------------------
    22                              <2> %define DISC_SIGNATURE      0x00    ; R: Signature byte (0xFB = FluxRipper)
    23                              <2> %define DISC_VERSION        0x01    ; R: FPGA version (major.minor)
    24                              <2> %define DISC_STATUS         0x02    ; R: Discovery status
    25                              <2> %define DISC_FLAGS          0x03    ; R: Detection flags
    26                              <2> 
    27                              <2> ; Drive 0 Geometry (primary)
    28                              <2> %define DISC_D0_CYL_LO      0x04    ; R: Cylinders [7:0]
    29                              <2> %define DISC_D0_CYL_HI      0x05    ; R: Cylinders [15:8]
    30                              <2> %define DISC_D0_HEADS       0x06    ; R: Heads (1-255)
    31                              <2> %define DISC_D0_SECTORS     0x07    ; R: Sectors per track (1-63)
    32                              <2> %define DISC_D0_CAP_0       0x08    ; R: Total sectors [7:0]
    33                              <2> %define DISC_D0_CAP_1       0x09    ; R: Total sectors [15:8]
    34                              <2> %define DISC_D0_CAP_2       0x0A    ; R: Total sectors [23:16]
    35                              <2> %define DISC_D0_CAP_3       0x0B    ; R: Total sectors [31:24]
    36                              <2> %define DISC_D0_FLAGS       0x0C    ; R: Drive 0 feature flags
    37                              <2> %define DISC_D0_RATE        0x0D    ; R: Data rate code
    38                              <2> %define DISC_D0_RESERVED    0x0E    ; Reserved
    39                              <2> 
    40                              <2> ; Drive 1 Geometry (secondary)
    41                              <2> %define DISC_D1_CYL_LO      0x10    ; R: Cylinders [7:0]
    42                              <2> %define DISC_D1_CYL_HI      0x11    ; R: Cylinders [15:8]
    43                              <2> %define DISC_D1_HEADS       0x12    ; R: Heads
    44                              <2> %define DISC_D1_SECTORS     0x13    ; R: Sectors per track
    45                              <2> %define DISC_D1_CAP_0       0x14    ; R: Total sectors [7:0]
    46                              <2> %define DISC_D1_CAP_1       0x15    ; R: Total sectors [15:8]
    47                              <2> %define DISC_D1_CAP_2       0x16    ; R: Total sectors [23:16]
    48                              <2> %define DISC_D1_CAP_3       0x17    ; R: Total sectors [31:24]
    49                              <2> %define DISC_D1_FLAGS       0x18    ; R: Drive 1 feature flags
    50                              <2> %define DISC_D1_RATE        0x19    ; R: Data rate code
    51                              <2> %define DISC_D1_RESERVED    0x1A    ; Reserved
    52                              <2> 
    53                              <2> ; Drive Model String (32 bytes, null-terminated)
    54                              <2> %define DISC_MODEL_BASE     0x20    ; R: Drive model string (32 bytes)
    55                              <2> %define DISC_MODEL_LEN      32
    56                              <2> 
    57                              <2> ; Personality Detection
    58                              <2> %define DISC_PERSONALITY    0x40    ; R: Detected personality (0=WD1002, 1=WD1003, 2=WD1006, 3=WD1007)
    59                              <2> %define DISC_SLOT_TYPE      0x41    ; R: Slot type (0=8-bit XT, 1=16-bit AT)
    60                              <2> %define DISC_PNP_ACTIVE     0x42    ; R: PnP mode active (0=legacy, 1=PnP)
    61                              <2> 
    62                              <2> ;------------------------------------------------------------------------------
    63                              <2> ; DISC_STATUS Bits
    64                              <2> ;------------------------------------------------------------------------------
    65                              <2> %define DISC_STS_BUSY       0x80    ; Discovery in progress
    66                              <2> %define DISC_STS_DONE       0x40    ; Discovery complete
    67                              <2> %define DISC_STS_ERROR      0x20    ; Discovery error occurred
    68                              <2> %define DISC_STS_D0_PRESENT 0x01    ; Drive 0 detected
    69                              <2> %define DISC_STS_D1_PRESENT 0x02    ; Drive 1 detected
    70                              <2> 
    71                              <2> ;------------------------------------------------------------------------------
    72                              <2> ; DISC_FLAGS Bits (global)
    73                              <2> ;------------------------------------------------------------------------------
    74                              <2> %define DISC_FLG_ESDI       0x01    ; ESDI interface detected
    75                              <2> %define DISC_FLG_RLL        0x02    ; RLL encoding detected
    76                              <2> %define DISC_FLG_MFM        0x04    ; MFM encoding detected
    77                              <2> %define DISC_FLG_XT_MODE    0x10    ; Operating in XT mode
    78                              <2> %define DISC_FLG_AT_MODE    0x20    ; Operating in AT mode
    79                              <2> %define DISC_FLG_PNP        0x40    ; PnP BIOS detected
    80                              <2> 
    81                              <2> ;------------------------------------------------------------------------------
    82                              <2> ; Per-Drive Flags (DISC_Dx_FLAGS)
    83                              <2> ;------------------------------------------------------------------------------
    84                              <2> %define DDRV_FLG_PRESENT    0x01    ; Drive is present
    85                              <2> %define DDRV_FLG_ESDI       0x02    ; ESDI interface
    86                              <2> %define DDRV_FLG_RLL        0x04    ; RLL encoding
    87                              <2> %define DDRV_FLG_MFM        0x08    ; MFM encoding
    88                              <2> %define DDRV_FLG_LBA        0x10    ; LBA capable
    89                              <2> %define DDRV_FLG_ECC        0x20    ; ECC supported
    90                              <2> %define DDRV_FLG_MULTI      0x40    ; Multi-sector transfers
    91                              <2> %define DDRV_FLG_READY      0x80    ; Drive ready
    92                              <2> 
    93                              <2> ;------------------------------------------------------------------------------
    94                              <2> ; Data Rate Codes (DISC_Dx_RATE)
    95                              <2> ;------------------------------------------------------------------------------
    96                              <2> %define RATE_5MBPS          0x00    ; 5 Mbps (MFM ST-506)
    97                              <2> %define RATE_7_5MBPS        0x01    ; 7.5 Mbps (RLL ST-506)
    98                              <2> %define RATE_10MBPS         0x02    ; 10 Mbps (ESDI)
    99                              <2> %define RATE_15MBPS         0x03    ; 15 Mbps (ESDI high-speed)
   100                              <2> %define RATE_20MBPS         0x04    ; 20 Mbps (ESDI max)
   101                              <2> 
   102                              <2> ;------------------------------------------------------------------------------
   103                              <2> ; Personality Codes
   104                              <2> ;------------------------------------------------------------------------------
   105                              <2> %define PERS_WD1002         0x00    ; WD1002-WX1: 8-bit XT, MFM, ST-506
   106                              <2> %define PERS_WD1003         0x01    ; WD1003-WAH: 16-bit AT, MFM, ST-506
   107                              <2> %define PERS_WD1006         0x02    ; WD1006-WAH: 16-bit AT, RLL, ST-506
   108                              <2> %define PERS_WD1007         0x03    ; WD1007-WAH: 16-bit AT, ESDI
   109                              <2> 
   110                              <2> ;------------------------------------------------------------------------------
   111                              <2> ; Discovery Timeout (in milliseconds)
   112                              <2> ;------------------------------------------------------------------------------
   113                              <2> %define DISC_TIMEOUT_MS     5000    ; 5 second timeout for discovery
   114                              <2> 
   115                              <2> ;------------------------------------------------------------------------------
   116                              <2> ; Macros for Reading Discovery Registers
   117                              <2> ;------------------------------------------------------------------------------
   118                              <2> 
   119                              <2> ; Read discovery byte register
   120                              <2> ; Input: AL = register offset (from DISC_REG_BASE)
   121                              <2> ; Output: AL = register value
   122                              <2> ; Destroys: DX
   123                              <2> %macro DISC_READ_BYTE 1
   124                              <2>     mov     dx, [current_base]
   125                              <2>     add     dx, DISC_REG_BASE + %1
   126                              <2>     in      al, dx
   127                              <2> %endmacro
   128                              <2> 
   129                              <2> ; Read discovery word register (little-endian)
   130                              <2> ; Input: first param = low byte offset
   131                              <2> ; Output: AX = 16-bit value
   132                              <2> ; Destroys: DX
   133                              <2> %macro DISC_READ_WORD 1
   134                              <2>     mov     dx, [current_base]
   135                              <2>     add     dx, DISC_REG_BASE + %1
   136                              <2>     in      al, dx                  ; Read low byte
   137                              <2>     mov     ah, al
   138                              <2>     inc     dx
   139                              <2>     in      al, dx                  ; Read high byte
   140                              <2>     xchg    al, ah                  ; Swap to correct order
   141                              <2> %endmacro
   142                              <2> 
   143                              <2> %endif ; DISCOVERY_INC
    19                              <1> 
    20                              <1> ;==============================================================================
    21                              <1> ; Wait for Discovery Complete
    22                              <1> ;==============================================================================
    23                              <1> ; Waits for FPGA discovery to finish (DISC_STS_DONE set or timeout).
    24                              <1> ;
    25                              <1> ; Output: CF = 0 if discovery complete, CF = 1 if timeout/error
    26                              <1> ;         AL = discovery status byte
    27                              <1> ; Destroys: AX, CX, DX
    28                              <1> ;==============================================================================
    29                              <1> wait_discovery:
    30 000001D4 53                  <1>     push    bx
    31 000001D5 51                  <1>     push    cx
    32                              <1> 
    33                              <1>     ; Timeout counter (approximately 5 seconds at ~1ms per iteration)
    34 000001D6 B98813              <1>     mov     cx, DISC_TIMEOUT_MS
    35                              <1> 
    36                              <1> .wait_loop:
    37                              <1>     ; Read discovery status
    38 000001D9 8B16[C931]          <1>     mov     dx, [current_base]
    39 000001DD 81C28200            <1>     add     dx, DISC_REG_BASE + DISC_STATUS
    40 000001E1 EC                  <1>     in      al, dx
    41                              <1> 
    42                              <1>     ; Check for done flag
    43 000001E2 A840                <1>     test    al, DISC_STS_DONE
    44 000001E4 7511                <1>     jnz     .check_error
    45                              <1> 
    46                              <1>     ; Check for error flag
    47 000001E6 A820                <1>     test    al, DISC_STS_ERROR
    48 000001E8 7514                <1>     jnz     .error
    49                              <1> 
    50                              <1>     ; Not done yet - delay and retry
    51 000001EA 51                  <1>     push    cx
    52 000001EB B90100              <1>     mov     cx, 1                   ; 1ms delay
    53 000001EE E891FF              <1>     call    delay_ms
    54 000001F1 59                  <1>     pop     cx
    55                              <1> 
    56 000001F2 E2E5                <1>     loop    .wait_loop
    57                              <1> 
    58                              <1>     ; Timeout
    59 000001F4 F9                  <1>     stc
    60 000001F5 EB08                <1>     jmp     .done
    61                              <1> 
    62                              <1> .check_error:
    63                              <1>     ; Done - but check if error occurred
    64 000001F7 A820                <1>     test    al, DISC_STS_ERROR
    65 000001F9 7503                <1>     jnz     .error
    66 000001FB F8                  <1>     clc                             ; Success
    67 000001FC EB01                <1>     jmp     .done
    68                              <1> 
    69                              <1> .error:
    70 000001FE F9                  <1>     stc                             ; Error
    71                              <1> 
    72                              <1> .done:
    73 000001FF 59                  <1>     pop     cx
    74 00000200 5B                  <1>     pop     bx
    75 00000201 C3                  <1>     ret
    76                              <1> 
    77                              <1> ;==============================================================================
    78                              <1> ; Read Drive Geometry from FPGA
    79                              <1> ;==============================================================================
    80                              <1> ; Reads discovered geometry for both drives into drive parameter structures.
    81                              <1> ;
    82                              <1> ; Output: CF = 0 if at least one drive detected, CF = 1 if no drives
    83                              <1> ;         [num_drives] updated with drive count
    84                              <1> ;         [drive0_params] and [drive1_params] populated
    85                              <1> ; Destroys: AX, BX, CX, DX, SI
    86                              <1> ;==============================================================================
    87                              <1> read_geometry:
    88 00000202 53                  <1>     push    bx
    89 00000203 51                  <1>     push    cx
    90 00000204 52                  <1>     push    dx
    91 00000205 56                  <1>     push    si
    92                              <1> 
    93                              <1>     ; Clear drive count
    94 00000206 C606[C831]00        <1>     mov     byte [num_drives], 0
    95                              <1> 
    96                              <1>     ; Read discovery status to check which drives are present
    97 0000020B 8B16[C931]          <1>     mov     dx, [current_base]
    98 0000020F 81C28200            <1>     add     dx, DISC_REG_BASE + DISC_STATUS
    99 00000213 EC                  <1>     in      al, dx
   100 00000214 88C3                <1>     mov     bl, al                  ; Save status in BL
   101                              <1> 
   102                              <1>     ; Read global flags
   103 00000216 42                  <1>     inc     dx
   104 00000217 EC                  <1>     in      al, dx
   105 00000218 88C7                <1>     mov     bh, al                  ; Save flags in BH
   106                              <1> 
   107                              <1>     ; Read detected personality
   108 0000021A 8B16[C931]          <1>     mov     dx, [current_base]
   109 0000021E 81C2C000            <1>     add     dx, DISC_REG_BASE + DISC_PERSONALITY
   110 00000222 EC                  <1>     in      al, dx
   111 00000223 A2[CB31]            <1>     mov     [personality], al
   112                              <1> 
   113                              <1>     ;--------------------------------------------------------------------------
   114                              <1>     ; Read Drive 0 Geometry
   115                              <1>     ;--------------------------------------------------------------------------
   116 00000226 F6C301              <1>     test    bl, DISC_STS_D0_PRESENT
   117 00000229 742D                <1>     jz      .try_drive1
   118                              <1> 
   119                              <1>     ; Drive 0 is present
   120 0000022B BE[9831]            <1>     mov     si, drive0_params
   121                              <1> 
   122                              <1>     ; Read cylinders
   123 0000022E 8B16[C931]          <1>     mov     dx, [current_base]
   124 00000232 81C28400            <1>     add     dx, DISC_REG_BASE + DISC_D0_CYL_LO
   125 00000236 EC                  <1>     in      al, dx
   126 00000237 8804                <1>     mov     [si + 0], al            ; Low byte
   127 00000239 42                  <1>     inc     dx
   128 0000023A EC                  <1>     in      al, dx
   129 0000023B 884401              <1>     mov     [si + 1], al            ; High byte
   130                              <1> 
   131                              <1>     ; Read heads
   132 0000023E 42                  <1>     inc     dx
   133 0000023F EC                  <1>     in      al, dx
   134 00000240 884402              <1>     mov     [si + 2], al            ; Heads
   135                              <1> 
   136                              <1>     ; Read sectors per track
   137 00000243 42                  <1>     inc     dx
   138 00000244 EC                  <1>     in      al, dx
   139 00000245 884403              <1>     mov     [si + 3], al            ; Sectors
   140                              <1> 
   141                              <1>     ; Read flags
   142 00000248 8B16[C931]          <1>     mov     dx, [current_base]
   143 0000024C 81C28C00            <1>     add     dx, DISC_REG_BASE + DISC_D0_FLAGS
   144 00000250 EC                  <1>     in      al, dx
   145 00000251 884404              <1>     mov     [si + 4], al            ; Flags
   146                              <1> 
   147                              <1>     ; Increment drive count
   148 00000254 FE06[C831]          <1>     inc     byte [num_drives]
   149                              <1> 
   150                              <1>     ;--------------------------------------------------------------------------
   151                              <1>     ; Read Drive 1 Geometry
   152                              <1>     ;--------------------------------------------------------------------------
   153                              <1> .try_drive1:
   154 00000258 F6C302              <1>     test    bl, DISC_STS_D1_PRESENT
   155 0000025B 742D                <1>     jz      .check_result
   156                              <1> 
   157                              <1>     ; Drive 1 is present
   158 0000025D BE[A031]            <1>     mov     si, drive1_params
   159                              <1> 
   160                              <1>     ; Read cylinders
   161 00000260 8B16[C931]          <1>     mov     dx, [current_base]
   162 00000264 81C29000            <1>     add     dx, DISC_REG_BASE + DISC_D1_CYL_LO
   163 00000268 EC                  <1>     in      al, dx
   164 00000269 8804                <1>     mov     [si + 0], al
   165 0000026B 42                  <1>     inc     dx
   166 0000026C EC                  <1>     in      al, dx
   167 0000026D 884401              <1>     mov     [si + 1], al
   168                              <1> 
   169                              <1>     ; Read heads
   170 00000270 42                  <1>     inc     dx
   171 00000271 EC                  <1>     in      al, dx
   172 00000272 884402              <1>     mov     [si + 2], al
   173                              <1> 
   174                              <1>     ; Read sectors per track
   175 00000275 42                  <1>     inc     dx
   176 00000276 EC                  <1>     in      al, dx
   177 00000277 884403              <1>     mov     [si + 3], al
   178                              <1> 
   179                              <1>     ; Read flags
   180 0000027A 8B16[C931]          <1>     mov     dx, [current_base]
   181 0000027E 81C29800            <1>     add     dx, DISC_REG_BASE + DISC_D1_FLAGS
   182 00000282 EC                  <1>     in      al, dx
   183 00000283 884404              <1>     mov     [si + 4], al
   184                              <1> 
   185                              <1>     ; Increment drive count
   186 00000286 FE06[C831]          <1>     inc     byte [num_drives]
   187                              <1> 
   188                              <1> .check_result:
   189                              <1>     ; Return success if at least one drive found
   190 0000028A 803E[C831]00        <1>     cmp     byte [num_drives], 0
   191 0000028F 7403                <1>     je      .no_drives
   192                              <1> 
   193 00000291 F8                  <1>     clc
   194 00000292 EB01                <1>     jmp     .done
   195                              <1> 
   196                              <1> .no_drives:
   197 00000294 F9                  <1>     stc
   198                              <1> 
   199                              <1> .done:
   200 00000295 5E                  <1>     pop     si
   201 00000296 5A                  <1>     pop     dx
   202 00000297 59                  <1>     pop     cx
   203 00000298 5B                  <1>     pop     bx
   204 00000299 C3                  <1>     ret
   205                              <1> 
   206                              <1> ;==============================================================================
   207                              <1> ; Read Drive Model String
   208                              <1> ;==============================================================================
   209                              <1> ; Reads the drive model string from FPGA into a buffer.
   210                              <1> ;
   211                              <1> ; Input:  ES:DI = destination buffer (32 bytes min)
   212                              <1> ; Output: CF = 0 success, CF = 1 if no string available
   213                              <1> ;         Buffer filled with null-terminated string
   214                              <1> ; Destroys: AX, CX, DX, DI
   215                              <1> ;==============================================================================
   216                              <1> read_model_string:
   217 0000029A 51                  <1>     push    cx
   218 0000029B 52                  <1>     push    dx
   219                              <1> 
   220 0000029C B92000              <1>     mov     cx, DISC_MODEL_LEN
   221                              <1> 
   222                              <1>     ; Read model string byte by byte
   223 0000029F 8B16[C931]          <1>     mov     dx, [current_base]
   224 000002A3 81C2A000            <1>     add     dx, DISC_REG_BASE + DISC_MODEL_BASE
   225                              <1> 
   226                              <1> .read_loop:
   227 000002A7 EC                  <1>     in      al, dx
   228 000002A8 AA                  <1>     stosb                           ; Store to ES:DI
   229 000002A9 42                  <1>     inc     dx
   230 000002AA E2FB                <1>     loop    .read_loop
   231                              <1> 
   232                              <1>     ; Ensure null termination
   233 000002AC 30C0                <1>     xor     al, al
   234 000002AE 4F                  <1>     dec     di
   235 000002AF 268805              <1>     mov     [es:di], al
   236                              <1> 
   237 000002B2 F8                  <1>     clc
   238                              <1> 
   239 000002B3 5A                  <1>     pop     dx
   240 000002B4 59                  <1>     pop     cx
   241 000002B5 C3                  <1>     ret
   242                              <1> 
   243                              <1> ;==============================================================================
   244                              <1> ; Get Detected Personality
   245                              <1> ;==============================================================================
   246                              <1> ; Returns the detected WD controller personality.
   247                              <1> ;
   248                              <1> ; Output: AL = personality code (PERS_WD1002/1003/1006/1007)
   249                              <1> ; Destroys: None
   250                              <1> ;==============================================================================
   251                              <1> get_personality:
   252 000002B6 A0[CB31]            <1>     mov     al, [personality]
   253 000002B9 C3                  <1>     ret
   254                              <1> 
   255                              <1> ;==============================================================================
   256                              <1> ; Get Slot Type
   257                              <1> ;==============================================================================
   258                              <1> ; Returns the detected ISA slot type (8-bit XT or 16-bit AT).
   259                              <1> ;
   260                              <1> ; Output: AL = 0 for 8-bit XT slot, AL = 1 for 16-bit AT slot
   261                              <1> ; Destroys: DX
   262                              <1> ;==============================================================================
   263                              <1> get_slot_type:
   264 000002BA 52                  <1>     push    dx
   265 000002BB 8B16[C931]          <1>     mov     dx, [current_base]
   266 000002BF 81C2C100            <1>     add     dx, DISC_REG_BASE + DISC_SLOT_TYPE
   267 000002C3 EC                  <1>     in      al, dx
   268 000002C4 5A                  <1>     pop     dx
   269 000002C5 C3                  <1>     ret
   270                              <1> 
   271                              <1> ;==============================================================================
   272                              <1> ; Check ESDI Mode
   273                              <1> ;==============================================================================
   274                              <1> ; Returns whether ESDI interface was detected.
   275                              <1> ;
   276                              <1> ; Output: CF = 1 if ESDI detected, CF = 0 if ST-506
   277                              <1> ; Destroys: AL, DX
   278                              <1> ;==============================================================================
   279                              <1> check_esdi_mode:
   280 000002C6 52                  <1>     push    dx
   281 000002C7 8B16[C931]          <1>     mov     dx, [current_base]
   282 000002CB 81C28300            <1>     add     dx, DISC_REG_BASE + DISC_FLAGS
   283 000002CF EC                  <1>     in      al, dx
   284 000002D0 A801                <1>     test    al, DISC_FLG_ESDI
   285 000002D2 7403                <1>     jz      .not_esdi
   286 000002D4 F9                  <1>     stc
   287 000002D5 EB01                <1>     jmp     .done
   288                              <1> .not_esdi:
   289 000002D7 F8                  <1>     clc
   290                              <1> .done:
   291 000002D8 5A                  <1>     pop     dx
   292 000002D9 C3                  <1>     ret
   293                              <1> 
   294                              <1> ;==============================================================================
   295                              <1> ; Check RLL Mode
   296                              <1> ;==============================================================================
   297                              <1> ; Returns whether RLL encoding was detected.
   298                              <1> ;
   299                              <1> ; Output: CF = 1 if RLL detected, CF = 0 if MFM
   300                              <1> ; Destroys: AL, DX
   301                              <1> ;==============================================================================
   302                              <1> check_rll_mode:
   303 000002DA 52                  <1>     push    dx
   304 000002DB 8B16[C931]          <1>     mov     dx, [current_base]
   305 000002DF 81C28300            <1>     add     dx, DISC_REG_BASE + DISC_FLAGS
   306 000002E3 EC                  <1>     in      al, dx
   307 000002E4 A802                <1>     test    al, DISC_FLG_RLL
   308 000002E6 7403                <1>     jz      .not_rll
   309 000002E8 F9                  <1>     stc
   310 000002E9 EB01                <1>     jmp     .done
   311                              <1> .not_rll:
   312 000002EB F8                  <1>     clc
   313                              <1> .done:
   314 000002EC 5A                  <1>     pop     dx
   315 000002ED C3                  <1>     ret
   316                              <1> 
   317                              <1> ;==============================================================================
   318                              <1> ; Get Data Rate
   319                              <1> ;==============================================================================
   320                              <1> ; Returns the detected data rate for a drive.
   321                              <1> ;
   322                              <1> ; Input:  DL = drive number (0 or 1)
   323                              <1> ; Output: AL = rate code (RATE_5MBPS, RATE_7_5MBPS, etc.)
   324                              <1> ; Destroys: DX
   325                              <1> ;==============================================================================
   326                              <1> get_data_rate:
   327 000002EE 52                  <1>     push    dx
   328 000002EF 88D6                <1>     mov     dh, dl                  ; Save drive number
   329                              <1> 
   330 000002F1 8B16[C931]          <1>     mov     dx, [current_base]
   331 000002F5 81C28000            <1>     add     dx, DISC_REG_BASE
   332                              <1> 
   333                              <1>     ; Select correct register based on drive
   334 000002F9 84F6                <1>     test    dh, dh
   335 000002FB 7405                <1>     jz      .drive0
   336 000002FD 83C219              <1>     add     dx, DISC_D1_RATE
   337 00000300 EB03                <1>     jmp     .read
   338                              <1> .drive0:
   339 00000302 83C20D              <1>     add     dx, DISC_D0_RATE
   340                              <1> .read:
   341 00000305 EC                  <1>     in      al, dx
   342 00000306 5A                  <1>     pop     dx
   343 00000307 C3                  <1>     ret
   344                              <1> 
   345                              <1> ;==============================================================================
   346                              <1> ; Read Total Sectors (32-bit)
   347                              <1> ;==============================================================================
   348                              <1> ; Returns the total sector count for a drive.
   349                              <1> ;
   350                              <1> ; Input:  DL = drive number (0 or 1)
   351                              <1> ; Output: DX:AX = 32-bit sector count
   352                              <1> ; Destroys: BX
   353                              <1> ;==============================================================================
   354                              <1> read_total_sectors:
   355 00000308 53                  <1>     push    bx
   356 00000309 51                  <1>     push    cx
   357                              <1> 
   358 0000030A 88D3                <1>     mov     bl, dl                  ; Save drive number
   359                              <1> 
   360 0000030C 8B16[C931]          <1>     mov     dx, [current_base]
   361 00000310 81C28000            <1>     add     dx, DISC_REG_BASE
   362                              <1> 
   363                              <1>     ; Select correct register base
   364 00000314 84DB                <1>     test    bl, bl
   365 00000316 7405                <1>     jz      .drive0
   366 00000318 83C214              <1>     add     dx, DISC_D1_CAP_0
   367 0000031B EB03                <1>     jmp     .read
   368                              <1> .drive0:
   369 0000031D 83C208              <1>     add     dx, DISC_D0_CAP_0
   370                              <1> 
   371                              <1> .read:
   372                              <1>     ; Read 4 bytes (little-endian)
   373 00000320 EC                  <1>     in      al, dx                  ; Byte 0
   374 00000321 88C1                <1>     mov     cl, al
   375 00000323 42                  <1>     inc     dx
   376 00000324 EC                  <1>     in      al, dx                  ; Byte 1
   377 00000325 88C5                <1>     mov     ch, al
   378 00000327 42                  <1>     inc     dx
   379 00000328 EC                  <1>     in      al, dx                  ; Byte 2
   380 00000329 88C3                <1>     mov     bl, al
   381 0000032B 42                  <1>     inc     dx
   382 0000032C EC                  <1>     in      al, dx                  ; Byte 3
   383 0000032D 88C7                <1>     mov     bh, al
   384                              <1> 
   385                              <1>     ; Assemble result in DX:AX
   386 0000032F 89C8                <1>     mov     ax, cx                  ; AX = low word
   387 00000331 89DA                <1>     mov     dx, bx                  ; DX = high word
   388                              <1> 
   389 00000333 59                  <1>     pop     cx
   390 00000334 5B                  <1>     pop     bx
   391 00000335 C3                  <1>     ret
   215                                  %include "init.asm"
     1                              <1> ;==============================================================================
     2                              <1> ; FluxRipper HDD BIOS - Initialization Routines
     3                              <1> ;==============================================================================
     4                              <1> ; Handles BIOS initialization after ROM entry:
     5                              <1> ;   - Set up Fixed Disk Parameter Tables
     6                              <1> ;   - Hook INT 13h
     7                              <1> ;   - Update BDA with drive count
     8                              <1> ;   - Display detected drives
     9                              <1> ;
    10                              <1> ; SPDX-License-Identifier: BSD-3-Clause
    11                              <1> ; Copyright (c) 2025 FluxRipper Project
    12                              <1> ;==============================================================================
    13                              <1> 
    14                              <1> ;==============================================================================
    15                              <1> ; Set Up Fixed Disk Parameter Tables
    16                              <1> ;==============================================================================
    17                              <1> ; Populates FDPT structures from discovered geometry and updates INT vectors.
    18                              <1> ;
    19                              <1> ; The FDPT is a 16-byte structure that the BIOS uses to track drive geometry.
    20                              <1> ; INT 41h vector points to drive 0's FDPT, INT 46h to drive 1's FDPT.
    21                              <1> ;
    22                              <1> ; Destroys: AX, BX, CX, DX, SI, DI, ES
    23                              <1> ;==============================================================================
    24                              <1> setup_fdpt:
    25 00000336 50                  <1>     push    ax
    26 00000337 53                  <1>     push    bx
    27 00000338 51                  <1>     push    cx
    28 00000339 52                  <1>     push    dx
    29 0000033A 56                  <1>     push    si
    30 0000033B 57                  <1>     push    di
    31 0000033C 06                  <1>     push    es
    32                              <1> 
    33                              <1>     ; Check if any drives present
    34 0000033D 803E[C831]00        <1>     cmp     byte [num_drives], 0
    35 00000342 0F848100            <1>     je      .done
    36                              <1> 
    37                              <1>     ;--------------------------------------------------------------------------
    38                              <1>     ; Set up Drive 0 FDPT
    39                              <1>     ;--------------------------------------------------------------------------
    40 00000346 BE[9831]            <1>     mov     si, drive0_params       ; Source: discovered geometry
    41 00000349 BF[A831]            <1>     mov     di, fdpt_drive0         ; Destination: FDPT structure
    42                              <1> 
    43                              <1>     ; Copy cylinders
    44 0000034C 8B04                <1>     mov     ax, [si + 0]            ; Cylinders from discovery
    45 0000034E 8905                <1>     mov     [di + FDPT_MAX_CYL], ax
    46                              <1> 
    47                              <1>     ; Copy heads
    48 00000350 30E4                <1>     xor     ah, ah
    49 00000352 8A4402              <1>     mov     al, [si + 2]
    50 00000355 884502              <1>     mov     [di + FDPT_MAX_HEAD], al
    51                              <1> 
    52                              <1>     ; Set control byte
    53 00000358 B000                <1>     mov     al, 0                   ; Start with no flags
    54 0000035A 807C0208            <1>     cmp     byte [si + 2], 8        ; More than 8 heads?
    55 0000035E 7602                <1>     jbe     .d0_heads_ok
    56 00000360 0C08                <1>     or      al, FDPT_CTL_MORE_8_HEADS
    57                              <1> .d0_heads_ok:
    58 00000362 884508              <1>     mov     [di + FDPT_CONTROL], al
    59                              <1> 
    60                              <1>     ; Copy sectors per track
    61 00000365 8A4403              <1>     mov     al, [si + 3]
    62 00000368 88450E              <1>     mov     [di + FDPT_SECTORS], al
    63                              <1> 
    64                              <1>     ; Set landing zone = max cylinder
    65 0000036B 8B04                <1>     mov     ax, [si + 0]
    66 0000036D 89450C              <1>     mov     [di + FDPT_LANDING], ax
    67                              <1> 
    68                              <1>     ; Write precomp = 0xFFFF (none needed for modern drives)
    69 00000370 C74505FFFF          <1>     mov     word [di + FDPT_WR_PRECOMP], 0xFFFF
    70                              <1> 
    71                              <1>     ;--------------------------------------------------------------------------
    72                              <1>     ; Update INT 41h vector to point to our FDPT
    73                              <1>     ;--------------------------------------------------------------------------
    74 00000375 31C0                <1>     xor     ax, ax
    75 00000377 8EC0                <1>     mov     es, ax                  ; ES = 0000 (IVT segment)
    76                              <1> 
    77                              <1>     ; Store offset and segment of our FDPT
    78 00000379 B8[A831]            <1>     mov     ax, fdpt_drive0
    79 0000037C 26A30401            <1>     mov     [es:INT_41_VECTOR], ax  ; Offset
    80 00000380 8CC8                <1>     mov     ax, cs
    81 00000382 26A30601            <1>     mov     [es:INT_41_VECTOR + 2], ax  ; Segment
    82                              <1> 
    83                              <1>     ;--------------------------------------------------------------------------
    84                              <1>     ; Set up Drive 1 FDPT (if present)
    85                              <1>     ;--------------------------------------------------------------------------
    86 00000386 803E[C831]02        <1>     cmp     byte [num_drives], 2
    87 0000038B 723A                <1>     jb      .done
    88                              <1> 
    89 0000038D BE[A031]            <1>     mov     si, drive1_params
    90 00000390 BF[B831]            <1>     mov     di, fdpt_drive1
    91                              <1> 
    92                              <1>     ; Copy cylinders
    93 00000393 8B04                <1>     mov     ax, [si + 0]
    94 00000395 8905                <1>     mov     [di + FDPT_MAX_CYL], ax
    95                              <1> 
    96                              <1>     ; Copy heads
    97 00000397 8A4402              <1>     mov     al, [si + 2]
    98 0000039A 884502              <1>     mov     [di + FDPT_MAX_HEAD], al
    99                              <1> 
   100                              <1>     ; Set control byte
   101 0000039D B000                <1>     mov     al, 0
   102 0000039F 807C0208            <1>     cmp     byte [si + 2], 8
   103 000003A3 7602                <1>     jbe     .d1_heads_ok
   104 000003A5 0C08                <1>     or      al, FDPT_CTL_MORE_8_HEADS
   105                              <1> .d1_heads_ok:
   106 000003A7 884508              <1>     mov     [di + FDPT_CONTROL], al
   107                              <1> 
   108                              <1>     ; Copy sectors per track
   109 000003AA 8A4403              <1>     mov     al, [si + 3]
   110 000003AD 88450E              <1>     mov     [di + FDPT_SECTORS], al
   111                              <1> 
   112                              <1>     ; Set landing zone
   113 000003B0 8B04                <1>     mov     ax, [si + 0]
   114 000003B2 89450C              <1>     mov     [di + FDPT_LANDING], ax
   115                              <1> 
   116                              <1>     ; Write precomp = none
   117 000003B5 C74505FFFF          <1>     mov     word [di + FDPT_WR_PRECOMP], 0xFFFF
   118                              <1> 
   119                              <1>     ;--------------------------------------------------------------------------
   120                              <1>     ; Update INT 46h vector for drive 1
   121                              <1>     ;--------------------------------------------------------------------------
   122 000003BA B8[B831]            <1>     mov     ax, fdpt_drive1
   123 000003BD 26A31801            <1>     mov     [es:INT_46_VECTOR], ax
   124 000003C1 8CC8                <1>     mov     ax, cs
   125 000003C3 26A31A01            <1>     mov     [es:INT_46_VECTOR + 2], ax
   126                              <1> 
   127                              <1> .done:
   128 000003C7 07                  <1>     pop     es
   129 000003C8 5F                  <1>     pop     di
   130 000003C9 5E                  <1>     pop     si
   131 000003CA 5A                  <1>     pop     dx
   132 000003CB 59                  <1>     pop     cx
   133 000003CC 5B                  <1>     pop     bx
   134 000003CD 58                  <1>     pop     ax
   135 000003CE C3                  <1>     ret
   136                              <1> 
   137                              <1> ;==============================================================================
   138                              <1> ; Hook INT 13h
   139                              <1> ;==============================================================================
   140                              <1> ; Saves the original INT 13h vector and installs our handler.
   141                              <1> ; We handle hard disk calls (DL >= 80h) and chain to original for floppy.
   142                              <1> ;
   143                              <1> ; Destroys: AX, ES
   144                              <1> ;==============================================================================
   145                              <1> hook_int13h:
   146 000003CF 50                  <1>     push    ax
   147 000003D0 06                  <1>     push    es
   148                              <1> 
   149                              <1>     ; Point ES to IVT
   150 000003D1 31C0                <1>     xor     ax, ax
   151 000003D3 8EC0                <1>     mov     es, ax
   152                              <1> 
   153                              <1>     ; Save original INT 13h vector
   154 000003D5 26A14C00            <1>     mov     ax, [es:INT_13_VECTOR]
   155 000003D9 A3[9031]            <1>     mov     [old_int13h], ax
   156 000003DC 26A14E00            <1>     mov     ax, [es:INT_13_VECTOR + 2]
   157 000003E0 A3[9231]            <1>     mov     [old_int13h + 2], ax
   158                              <1> 
   159                              <1>     ; Install our handler
   160 000003E3 FA                  <1>     cli                             ; Disable interrupts during vector update
   161 000003E4 26C7064C00[9804]    <1>     mov     word [es:INT_13_VECTOR], int13h_handler
   162 000003EB 268C0E4E00          <1>     mov     [es:INT_13_VECTOR + 2], cs
   163 000003F0 FB                  <1>     sti                             ; Re-enable interrupts
   164                              <1> 
   165 000003F1 07                  <1>     pop     es
   166 000003F2 58                  <1>     pop     ax
   167 000003F3 C3                  <1>     ret
   168                              <1> 
   169                              <1> ;==============================================================================
   170                              <1> ; Update BDA Drive Count
   171                              <1> ;==============================================================================
   172                              <1> ; Updates the hard disk count in the BIOS Data Area.
   173                              <1> ;
   174                              <1> ; Destroys: AX, ES
   175                              <1> ;==============================================================================
   176                              <1> update_bda:
   177 000003F4 50                  <1>     push    ax
   178 000003F5 06                  <1>     push    es
   179                              <1> 
   180                              <1>     ; Point ES to BDA
   181 000003F6 B84000              <1>     mov     ax, BDA_SEG
   182 000003F9 8EC0                <1>     mov     es, ax
   183                              <1> 
   184                              <1>     ; Get current drive count (in case system BIOS found some)
   185 000003FB 26A07500            <1>     mov     al, [es:BDA_HDD_COUNT]
   186                              <1> 
   187                              <1>     ; Add our drives
   188 000003FF 0206[C831]          <1>     add     al, [num_drives]
   189                              <1> 
   190                              <1>     ; Clamp to maximum of 2 for compatibility
   191 00000403 3C02                <1>     cmp     al, 2
   192 00000405 7602                <1>     jbe     .store
   193 00000407 B002                <1>     mov     al, 2
   194                              <1> 
   195                              <1> .store:
   196 00000409 26A27500            <1>     mov     [es:BDA_HDD_COUNT], al
   197                              <1> 
   198 0000040D 07                  <1>     pop     es
   199 0000040E 58                  <1>     pop     ax
   200 0000040F C3                  <1>     ret
   201                              <1> 
   202                              <1> ;==============================================================================
   203                              <1> ; Display Detected Drives
   204                              <1> ;==============================================================================
   205                              <1> ; Prints information about detected drives.
   206                              <1> ;
   207                              <1> ; Destroys: AX, BX, CX, DX, SI
   208                              <1> ;==============================================================================
   209                              <1> display_drives:
   210 00000410 50                  <1>     push    ax
   211 00000411 53                  <1>     push    bx
   212 00000412 51                  <1>     push    cx
   213 00000413 52                  <1>     push    dx
   214 00000414 56                  <1>     push    si
   215                              <1> 
   216                              <1>     ; Print number of drives
   217 00000415 BE[600F]            <1>     mov     si, msg_drives_found
   218 00000418 E8A5FC              <1>     call    print_string
   219 0000041B 30E4                <1>     xor     ah, ah
   220 0000041D A0[C831]            <1>     mov     al, [num_drives]
   221 00000420 E8FEFC              <1>     call    print_decimal
   222 00000423 BE[690F]            <1>     mov     si, msg_drives_suffix
   223 00000426 E897FC              <1>     call    print_string
   224 00000429 E8B5FC              <1>     call    print_newline
   225                              <1> 
   226                              <1>     ; Display drive 0 if present
   227 0000042C 803E[C831]00        <1>     cmp     byte [num_drives], 0
   228 00000431 741F                <1>     je      .done
   229                              <1> 
   230 00000433 BE[730F]            <1>     mov     si, msg_drive0
   231 00000436 E887FC              <1>     call    print_string
   232 00000439 BE[9831]            <1>     mov     si, drive0_params
   233 0000043C E81900              <1>     call    print_drive_info
   234                              <1> 
   235                              <1>     ; Display drive 1 if present
   236 0000043F 803E[C831]02        <1>     cmp     byte [num_drives], 2
   237 00000444 720C                <1>     jb      .done
   238                              <1> 
   239 00000446 BE[7B0F]            <1>     mov     si, msg_drive1
   240 00000449 E874FC              <1>     call    print_string
   241 0000044C BE[A031]            <1>     mov     si, drive1_params
   242 0000044F E80600              <1>     call    print_drive_info
   243                              <1> 
   244                              <1> .done:
   245 00000452 5E                  <1>     pop     si
   246 00000453 5A                  <1>     pop     dx
   247 00000454 59                  <1>     pop     cx
   248 00000455 5B                  <1>     pop     bx
   249 00000456 58                  <1>     pop     ax
   250 00000457 C3                  <1>     ret
   251                              <1> 
   252                              <1> ;==============================================================================
   253                              <1> ; Print Drive Info
   254                              <1> ;==============================================================================
   255                              <1> ; Prints geometry for a single drive.
   256                              <1> ;
   257                              <1> ; Input:  SI = pointer to drive parameter structure
   258                              <1> ; Destroys: AX, BX, CX, DX
   259                              <1> ;==============================================================================
   260                              <1> print_drive_info:
   261 00000458 56                  <1>     push    si
   262                              <1> 
   263                              <1>     ; Print cylinders
   264 00000459 8B04                <1>     mov     ax, [si + 0]            ; Cylinders
   265 0000045B E8C3FC              <1>     call    print_decimal
   266 0000045E B02F                <1>     mov     al, '/'
   267 00000460 E872FC              <1>     call    print_char
   268                              <1> 
   269                              <1>     ; Print heads
   270 00000463 30E4                <1>     xor     ah, ah
   271 00000465 8A4402              <1>     mov     al, [si + 2]            ; Heads
   272 00000468 E8B6FC              <1>     call    print_decimal
   273 0000046B B02F                <1>     mov     al, '/'
   274 0000046D E865FC              <1>     call    print_char
   275                              <1> 
   276                              <1>     ; Print sectors
   277 00000470 30E4                <1>     xor     ah, ah
   278 00000472 8A4403              <1>     mov     al, [si + 3]            ; Sectors
   279 00000475 E8A9FC              <1>     call    print_decimal
   280                              <1> 
   281                              <1>     ; Print interface type based on flags
   282 00000478 8A4404              <1>     mov     al, [si + 4]            ; Flags
   283 0000047B A802                <1>     test    al, DDRV_FLG_ESDI
   284 0000047D 7405                <1>     jz      .check_rll
   285 0000047F BE[8D0F]            <1>     mov     si, msg_esdi
   286 00000482 EB0C                <1>     jmp     .print_type
   287                              <1> 
   288                              <1> .check_rll:
   289 00000484 A804                <1>     test    al, DDRV_FLG_RLL
   290 00000486 7405                <1>     jz      .mfm
   291 00000488 BE[880F]            <1>     mov     si, msg_rll
   292 0000048B EB03                <1>     jmp     .print_type
   293                              <1> 
   294                              <1> .mfm:
   295 0000048D BE[830F]            <1>     mov     si, msg_mfm
   296                              <1> 
   297                              <1> .print_type:
   298 00000490 E82DFC              <1>     call    print_string
   299 00000493 E84BFC              <1>     call    print_newline
   300                              <1> 
   301 00000496 5E                  <1>     pop     si
   302 00000497 C3                  <1>     ret
   216                                  %include "int13h.asm"
     1                              <1> ;==============================================================================
     2                              <1> ; FluxRipper HDD BIOS - INT 13h Handler
     3                              <1> ;==============================================================================
     4                              <1> ; Main INT 13h interrupt handler and function dispatcher.
     5                              <1> ;
     6                              <1> ; This handler:
     7                              <1> ;   1. Checks if request is for hard disk (DL >= 80h)
     8                              <1> ;   2. Maps drive number to our physical drive
     9                              <1> ;   3. Dispatches to appropriate function handler
    10                              <1> ;   4. Chains to original INT 13h for floppy requests
    11                              <1> ;
    12                              <1> ; SPDX-License-Identifier: BSD-3-Clause
    13                              <1> ; Copyright (c) 2025 FluxRipper Project
    14                              <1> ;==============================================================================
    15                              <1> 
    16                              <1> %include "int13h.inc"
     1                              <2> ;==============================================================================
     2                              <2> ; FluxRipper HDD BIOS - INT 13h Function Code Definitions
     3                              <2> ;==============================================================================
     4                              <2> ; Defines function codes and register conventions for INT 13h disk services.
     5                              <2> ;
     6                              <2> ; SPDX-License-Identifier: BSD-3-Clause
     7                              <2> ; Copyright (c) 2025 FluxRipper Project
     8                              <2> ;==============================================================================
     9                              <2> 
    10                              <2> %ifndef INT13H_INC
    11                              <2> %define INT13H_INC
    12                              <2> 
    13                              <2> ;------------------------------------------------------------------------------
    14                              <2> ; INT 13h Basic Functions (00h-08h)
    15                              <2> ;------------------------------------------------------------------------------
    16                              <2> ; These are supported by all builds (8KB and 16KB)
    17                              <2> 
    18                              <2> %define FN_RESET            0x00    ; Reset disk system
    19                              <2> %define FN_GET_STATUS       0x01    ; Get status of last operation
    20                              <2> %define FN_READ_SECTORS     0x02    ; Read sectors into memory
    21                              <2> %define FN_WRITE_SECTORS    0x03    ; Write sectors from memory
    22                              <2> %define FN_VERIFY_SECTORS   0x04    ; Verify sectors (compare CRC)
    23                              <2> %define FN_FORMAT_TRACK     0x05    ; Format track
    24                              <2> %define FN_FORMAT_BAD       0x06    ; Format track with bad sectors (XT only)
    25                              <2> %define FN_FORMAT_DRIVE     0x07    ; Format entire drive (XT only)
    26                              <2> %define FN_GET_PARAMETERS   0x08    ; Get drive parameters
    27                              <2> 
    28                              <2> ;------------------------------------------------------------------------------
    29                              <2> ; INT 13h Extended Functions (09h-15h)
    30                              <2> ;------------------------------------------------------------------------------
    31                              <2> ; These are supported by 16KB build only
    32                              <2> 
    33                              <2> %define FN_INIT_DRIVE       0x09    ; Initialize drive parameters
    34                              <2> %define FN_READ_LONG        0x0A    ; Read sectors with ECC
    35                              <2> %define FN_WRITE_LONG       0x0B    ; Write sectors with ECC
    36                              <2> %define FN_SEEK             0x0C    ; Seek to cylinder
    37                              <2> %define FN_RESET_ALTERNATE  0x0D    ; Alternate disk reset
    38                              <2> %define FN_READ_BUFFER      0x0E    ; Read sector buffer (diagnostics)
    39                              <2> %define FN_WRITE_BUFFER     0x0F    ; Write sector buffer (diagnostics)
    40                              <2> %define FN_TEST_READY       0x10    ; Test drive ready
    41                              <2> %define FN_RECALIBRATE      0x11    ; Recalibrate drive
    42                              <2> %define FN_RAM_DIAGNOSTIC   0x12    ; Controller RAM diagnostic
    43                              <2> %define FN_DRIVE_DIAGNOSTIC 0x13    ; Drive diagnostic
    44                              <2> %define FN_CTRL_DIAGNOSTIC  0x14    ; Controller diagnostic
    45                              <2> %define FN_GET_DISK_TYPE    0x15    ; Get disk type
    46                              <2> 
    47                              <2> ;------------------------------------------------------------------------------
    48                              <2> ; INT 13h LBA Extensions (41h-48h)
    49                              <2> ;------------------------------------------------------------------------------
    50                              <2> ; IBM/Microsoft Extended INT 13h - 16KB build only
    51                              <2> 
    52                              <2> %define FN_CHECK_EXTENSIONS 0x41    ; Installation check
    53                              <2> %define FN_EXT_READ         0x42    ; Extended read
    54                              <2> %define FN_EXT_WRITE        0x43    ; Extended write
    55                              <2> %define FN_EXT_VERIFY       0x44    ; Extended verify
    56                              <2> %define FN_LOCK_UNLOCK      0x45    ; Lock/unlock media
    57                              <2> %define FN_EJECT            0x46    ; Eject media
    58                              <2> %define FN_EXT_SEEK         0x47    ; Extended seek
    59                              <2> %define FN_GET_EXT_PARAMS   0x48    ; Get extended drive parameters
    60                              <2> 
    61                              <2> ;------------------------------------------------------------------------------
    62                              <2> ; Register Conventions for INT 13h Calls
    63                              <2> ;------------------------------------------------------------------------------
    64                              <2> ; Input (for sector operations):
    65                              <2> ;   AH    = Function number
    66                              <2> ;   AL    = Sector count
    67                              <2> ;   CH    = Cylinder low 8 bits
    68                              <2> ;   CL    = Sector (bits 0-5) + Cylinder high (bits 6-7)
    69                              <2> ;   DH    = Head number
    70                              <2> ;   DL    = Drive number (80h = first HD, 81h = second HD)
    71                              <2> ;   ES:BX = Buffer address (for read/write)
    72                              <2> ;
    73                              <2> ; Output:
    74                              <2> ;   AH    = Status code (0 = success)
    75                              <2> ;   AL    = Sectors transferred (for read/write/verify)
    76                              <2> ;   CF    = 0 if success, 1 if error
    77                              <2> ;
    78                              <2> ; Note: CHS is encoded as follows:
    79                              <2> ;   Cylinder = (CL >> 6) | CH  (10 bits, 0-1023)
    80                              <2> ;   Head     = DH              (8 bits, 0-255)
    81                              <2> ;   Sector   = CL & 0x3F       (6 bits, 1-63)
    82                              <2> 
    83                              <2> ;------------------------------------------------------------------------------
    84                              <2> ; Status Codes (returned in AH)
    85                              <2> ;------------------------------------------------------------------------------
    86                              <2> ; These are stored in BDA at 0040:0074
    87                              <2> 
    88                              <2> %define ST_SUCCESS          0x00    ; No error
    89                              <2> %define ST_BAD_COMMAND      0x01    ; Invalid function
    90                              <2> %define ST_ADDR_MARK        0x02    ; Address mark not found
    91                              <2> %define ST_WRITE_PROTECT    0x03    ; Write protected
    92                              <2> %define ST_SECTOR_NOT_FOUND 0x04    ; Sector not found
    93                              <2> %define ST_RESET_FAILED     0x05    ; Reset failed
    94                              <2> %define ST_MEDIA_CHANGED    0x06    ; Media changed
    95                              <2> %define ST_INIT_FAILED      0x07    ; Parameter activity failed
    96                              <2> %define ST_DMA_OVERRUN      0x08    ; DMA overrun
    97                              <2> %define ST_DMA_BOUNDARY     0x09    ; DMA crossed 64K boundary
    98                              <2> %define ST_BAD_SECTOR       0x0A    ; Bad sector flag
    99                              <2> %define ST_BAD_TRACK        0x0B    ; Bad track flag
   100                              <2> %define ST_MEDIA_TYPE       0x0C    ; Media type not found
   101                              <2> %define ST_INVALID_SECTORS  0x0D    ; Invalid number of sectors
   102                              <2> %define ST_CONTROL_DATA     0x0E    ; Control data address mark
   103                              <2> %define ST_DMA_ERROR        0x0F    ; DMA arbitration error
   104                              <2> %define ST_CRC_ERROR        0x10    ; CRC/ECC error (uncorrectable)
   105                              <2> %define ST_ECC_CORRECTED    0x11    ; ECC corrected data
   106                              <2> %define ST_CONTROLLER       0x20    ; Controller failure
   107                              <2> %define ST_SEEK_ERROR       0x40    ; Seek failure
   108                              <2> %define ST_TIMEOUT          0x80    ; Timeout
   109                              <2> %define ST_NOT_READY        0xAA    ; Drive not ready
   110                              <2> %define ST_UNDEFINED        0xBB    ; Undefined error
   111                              <2> %define ST_WRITE_FAULT      0xCC    ; Write fault
   112                              <2> %define ST_STATUS_ERROR     0xE0    ; Status error
   113                              <2> %define ST_SENSE_FAILED     0xFF    ; Sense operation failed
   114                              <2> 
   115                              <2> ;------------------------------------------------------------------------------
   116                              <2> ; Extended INT 13h Installation Check (Function 41h)
   117                              <2> ;------------------------------------------------------------------------------
   118                              <2> ; Input:
   119                              <2> ;   AH = 41h
   120                              <2> ;   BX = 55AAh (signature)
   121                              <2> ;   DL = drive number
   122                              <2> ;
   123                              <2> ; Output:
   124                              <2> ;   CF = 0 if extensions supported
   125                              <2> ;   AH = version (21h = 1.x, 30h = 2.x/EDD-1.1, etc.)
   126                              <2> ;   BX = AA55h (inverted signature)
   127                              <2> ;   CX = extension support bitmap
   128                              <2> 
   129                              <2> %define EXT_VER_1X          0x01    ; Version 1.x
   130                              <2> %define EXT_VER_2X          0x20    ; Version 2.0
   131                              <2> %define EXT_VER_21          0x21    ; Version 2.1
   132                              <2> %define EXT_VER_30          0x30    ; Version 3.0 (EDD)
   133                              <2> 
   134                              <2> ; CX extension bits
   135                              <2> %define EXT_DAP             0x0001  ; Device Access Packet (read/write)
   136                              <2> %define EXT_LOCK            0x0002  ; Lock/Unlock and Eject
   137                              <2> %define EXT_EDD             0x0004  ; Enhanced Disk Drive support
   138                              <2> 
   139                              <2> ;------------------------------------------------------------------------------
   140                              <2> ; Device Address Packet (DAP) Structure
   141                              <2> ;------------------------------------------------------------------------------
   142                              <2> ; Used by extended read/write functions (42h/43h)
   143                              <2> ;
   144                              <2> ; Offset  Size  Description
   145                              <2> ;   00h    1    Packet size (10h or 18h)
   146                              <2> ;   01h    1    Reserved (0)
   147                              <2> ;   02h    2    Sector count
   148                              <2> ;   04h    4    Buffer address (segment:offset)
   149                              <2> ;   08h    8    Starting LBA (64-bit)
   150                              <2> ;   10h    8    Flat address (if packet size = 18h)
   151                              <2> 
   152                              <2> %define DAP_SIZE_BASIC      0x10    ; 16-byte DAP
   153                              <2> %define DAP_SIZE_EXTENDED   0x18    ; 24-byte DAP with flat address
   154                              <2> 
   155                              <2> struc DAP
   156 00000000 ??                  <2>     .size       resb 1
   157 00000001 ??                  <2>     .reserved   resb 1
   158 00000002 ????                <2>     .count      resw 1
   159 00000004 ????????            <2>     .buffer     resd 1
   160 00000008 ????????????????    <2>     .lba        resq 1
   161 00000010 ????????????????    <2>     .flat_addr  resq 1              ; Only if size = 18h
   162                              <2> endstruc
   163                              <2> 
   164                              <2> ;------------------------------------------------------------------------------
   165                              <2> ; Extended Drive Parameters (Function 48h)
   166                              <2> ;------------------------------------------------------------------------------
   167                              <2> ; Offset  Size  Description
   168                              <2> ;   00h    2    Buffer size (1Ah minimum, 1Eh with EDD, 42h with path)
   169                              <2> ;   02h    2    Flags
   170                              <2> ;   04h    4    Physical cylinders
   171                              <2> ;   08h    4    Physical heads
   172                              <2> ;   0Ch    4    Physical sectors per track
   173                              <2> ;   10h    8    Total sectors (64-bit)
   174                              <2> ;   18h    2    Bytes per sector
   175                              <2> 
   176                              <2> struc EXT_PARAMS
   177 00000000 ????                <2>     .size           resw 1
   178 00000002 ????                <2>     .flags          resw 1
   179 00000004 ????????            <2>     .cylinders      resd 1
   180 00000008 ????????            <2>     .heads          resd 1
   181 0000000C ????????            <2>     .sectors        resd 1
   182 00000010 ????????????????    <2>     .total_sectors  resq 1
   183 00000018 ????                <2>     .bytes_sector   resw 1
   184                              <2> endstruc
   185                              <2> 
   186                              <2> ;------------------------------------------------------------------------------
   187                              <2> ; Macros for INT 13h Handler
   188                              <2> ;------------------------------------------------------------------------------
   189                              <2> 
   190                              <2> ; Save all registers for INT handler
   191                              <2> %macro INT13_SAVE_REGS 0
   192                              <2>     push    ds
   193                              <2>     push    es
   194                              <2>     push    bx
   195                              <2>     push    cx
   196                              <2>     push    dx
   197                              <2>     push    si
   198                              <2>     push    di
   199                              <2>     push    bp
   200                              <2> %endmacro
   201                              <2> 
   202                              <2> ; Restore all registers for INT handler
   203                              <2> %macro INT13_RESTORE_REGS 0
   204                              <2>     pop     bp
   205                              <2>     pop     di
   206                              <2>     pop     si
   207                              <2>     pop     dx
   208                              <2>     pop     cx
   209                              <2>     pop     bx
   210                              <2>     pop     es
   211                              <2>     pop     ds
   212                              <2> %endmacro
   213                              <2> 
   214                              <2> ; Return from INT 13h with status
   215                              <2> ; Input: AL = status code
   216                              <2> %macro INT13_RETURN 0
   217                              <2>     mov     [bp + 8], ax            ; Store AH (status) in saved AX on stack
   218                              <2>     ; Update BDA status
   219                              <2>     push    es
   220                              <2>     push    bx
   221                              <2>     mov     bx, BDA_SEG
   222                              <2>     mov     es, bx
   223                              <2>     mov     [es:BDA_HDD_STATUS], ah
   224                              <2>     pop     bx
   225                              <2>     pop     es
   226                              <2>     INT13_RESTORE_REGS
   227                              <2>     ; Set/clear carry based on status
   228                              <2>     or      ah, ah
   229                              <2>     jz      %%no_error
   230                              <2>     stc                             ; Set carry = error
   231                              <2>     retf    2                       ; Return, discard flags
   232                              <2> %%no_error:
   233                              <2>     clc                             ; Clear carry = success
   234                              <2>     retf    2
   235                              <2> %endmacro
   236                              <2> 
   237                              <2> %endif ; INT13H_INC
    17                              <1> 
    18                              <1> ;==============================================================================
    19                              <1> ; INT 13h Entry Point
    20                              <1> ;==============================================================================
    21                              <1> ; Called via INT 13h from user code.
    22                              <1> ;
    23                              <1> ; We handle hard disk requests (DL >= 80h) and chain to original for floppy.
    24                              <1> ;==============================================================================
    25                              <1> int13h_handler:
    26                              <1>     ; Check if this is a hard disk request
    27 00000498 80FA80              <1>     cmp     dl, 0x80
    28 0000049B 0F824C04            <1>     jb      .chain_to_original      ; DL < 80h = floppy, chain
    29                              <1> 
    30                              <1>     ; Check if drive is one we manage
    31 0000049F 50                  <1>     push    ax
    32 000004A0 88D0                <1>     mov     al, dl
    33 000004A2 2C80                <1>     sub     al, 0x80                ; Convert 80h/81h to 0/1
    34 000004A4 2E3A06[C831]        <1>     cmp     al, [cs:num_drives]     ; Compare with our drive count
    35 000004A9 58                  <1>     pop     ax
    36 000004AA 0F833D04            <1>     jae     .chain_to_original      ; Drive not ours, chain
    37                              <1> 
    38                              <1>     ; This is our drive - save registers and dispatch
    39                              <1>     INT13_SAVE_REGS
   192 000004AE 1E                  <2>  push ds
   193 000004AF 06                  <2>  push es
   194 000004B0 53                  <2>  push bx
   195 000004B1 51                  <2>  push cx
   196 000004B2 52                  <2>  push dx
   197 000004B3 56                  <2>  push si
   198 000004B4 57                  <2>  push di
   199 000004B5 55                  <2>  push bp
    40                              <1> 
    41                              <1>     ; Set up BP to access saved registers
    42 000004B6 89E5                <1>     mov     bp, sp
    43                              <1> 
    44                              <1>     ; Set DS to ROM segment for access to our data
    45 000004B8 0E                  <1>     push    cs
    46 000004B9 1F                  <1>     pop     ds
    47                              <1> 
    48                              <1>     ; Dispatch based on function number in AH
    49 000004BA 80FC00              <1>     cmp     ah, FN_RESET
    50 000004BD 0F84BA00            <1>     je      .fn_reset
    51 000004C1 80FC01              <1>     cmp     ah, FN_GET_STATUS
    52 000004C4 0F84DB00            <1>     je      .fn_get_status
    53 000004C8 80FC02              <1>     cmp     ah, FN_READ_SECTORS
    54 000004CB 0F84FC00            <1>     je      .fn_read_sectors
    55 000004CF 80FC03              <1>     cmp     ah, FN_WRITE_SECTORS
    56 000004D2 0F841D01            <1>     je      .fn_write_sectors
    57 000004D6 80FC04              <1>     cmp     ah, FN_VERIFY_SECTORS
    58 000004D9 0F843E01            <1>     je      .fn_verify_sectors
    59 000004DD 80FC05              <1>     cmp     ah, FN_FORMAT_TRACK
    60 000004E0 0F845F01            <1>     je      .fn_format_track
    61 000004E4 80FC08              <1>     cmp     ah, FN_GET_PARAMETERS
    62 000004E7 0F848001            <1>     je      .fn_get_parameters
    63                              <1> 
    64                              <1> %if ENABLE_EXTENDED
    65                              <1>     ; Extended functions (16KB build only)
    66 000004EB 80FC09              <1>     cmp     ah, FN_INIT_DRIVE
    67 000004EE 0F84A101            <1>     je      .fn_init_drive
    68 000004F2 80FC0A              <1>     cmp     ah, FN_READ_LONG
    69 000004F5 0F84C201            <1>     je      .fn_read_long
    70 000004F9 80FC0B              <1>     cmp     ah, FN_WRITE_LONG
    71 000004FC 0F84E301            <1>     je      .fn_write_long
    72 00000500 80FC0C              <1>     cmp     ah, FN_SEEK
    73 00000503 0F840402            <1>     je      .fn_seek
    74 00000507 80FC0D              <1>     cmp     ah, FN_RESET_ALTERNATE
    75 0000050A 0F842502            <1>     je      .fn_reset_alternate
    76 0000050E 80FC10              <1>     cmp     ah, FN_TEST_READY
    77 00000511 0F844602            <1>     je      .fn_test_ready
    78 00000515 80FC11              <1>     cmp     ah, FN_RECALIBRATE
    79 00000518 0F846702            <1>     je      .fn_recalibrate
    80 0000051C 80FC14              <1>     cmp     ah, FN_CTRL_DIAGNOSTIC
    81 0000051F 0F848802            <1>     je      .fn_diagnostic
    82 00000523 80FC15              <1>     cmp     ah, FN_GET_DISK_TYPE
    83 00000526 0F84A902            <1>     je      .fn_get_disk_type
    84                              <1> %endif
    85                              <1> 
    86                              <1> %if ENABLE_LBA
    87                              <1>     ; LBA extension functions (16KB build only)
    88 0000052A 80FC41              <1>     cmp     ah, FN_CHECK_EXTENSIONS
    89 0000052D 0F84CA02            <1>     je      .fn_check_extensions
    90 00000531 80FC42              <1>     cmp     ah, FN_EXT_READ
    91 00000534 0F84EB02            <1>     je      .fn_ext_read
    92 00000538 80FC43              <1>     cmp     ah, FN_EXT_WRITE
    93 0000053B 0F840C03            <1>     je      .fn_ext_write
    94 0000053F 80FC44              <1>     cmp     ah, FN_EXT_VERIFY
    95 00000542 0F842D03            <1>     je      .fn_ext_verify
    96 00000546 80FC47              <1>     cmp     ah, FN_EXT_SEEK
    97 00000549 0F844E03            <1>     je      .fn_ext_seek
    98 0000054D 80FC48              <1>     cmp     ah, FN_GET_EXT_PARAMS
    99 00000550 0F846F03            <1>     je      .fn_get_ext_params
   100                              <1> %endif
   101                              <1> 
   102                              <1>     ; Unknown function - return invalid command error
   103 00000554 B401                <1>     mov     ah, ST_BAD_COMMAND
   104                              <1>     INT13_RETURN
   217 00000556 894608              <2>  mov [bp + 8], ax
   218                              <2> 
   219 00000559 06                  <2>  push es
   220 0000055A 53                  <2>  push bx
   221 0000055B BB4000              <2>  mov bx, BDA_SEG
   222 0000055E 8EC3                <2>  mov es, bx
   223 00000560 2688267400          <2>  mov [es:BDA_HDD_STATUS], ah
   224 00000565 5B                  <2>  pop bx
   225 00000566 07                  <2>  pop es
   226                              <2>  INT13_RESTORE_REGS
   204 00000567 5D                  <3>  pop bp
   205 00000568 5F                  <3>  pop di
   206 00000569 5E                  <3>  pop si
   207 0000056A 5A                  <3>  pop dx
   208 0000056B 59                  <3>  pop cx
   209 0000056C 5B                  <3>  pop bx
   210 0000056D 07                  <3>  pop es
   211 0000056E 1F                  <3>  pop ds
   227                              <2> 
   228 0000056F 08E4                <2>  or ah, ah
   229 00000571 7404                <2>  jz %%no_error
   230 00000573 F9                  <2>  stc
   231 00000574 CA0200              <2>  retf 2
   232                              <2> %%no_error:
   233 00000577 F8                  <2>  clc
   234 00000578 CA0200              <2>  retf 2
   105                              <1> 
   106                              <1> ;------------------------------------------------------------------------------
   107                              <1> ; Function Dispatch Table
   108                              <1> ;------------------------------------------------------------------------------
   109                              <1> .fn_reset:
   110 0000057B E8E803              <1>     call    int13h_reset
   111                              <1>     INT13_RETURN
   217 0000057E 894608              <2>  mov [bp + 8], ax
   218                              <2> 
   219 00000581 06                  <2>  push es
   220 00000582 53                  <2>  push bx
   221 00000583 BB4000              <2>  mov bx, BDA_SEG
   222 00000586 8EC3                <2>  mov es, bx
   223 00000588 2688267400          <2>  mov [es:BDA_HDD_STATUS], ah
   224 0000058D 5B                  <2>  pop bx
   225 0000058E 07                  <2>  pop es
   226                              <2>  INT13_RESTORE_REGS
   204 0000058F 5D                  <3>  pop bp
   205 00000590 5F                  <3>  pop di
   206 00000591 5E                  <3>  pop si
   207 00000592 5A                  <3>  pop dx
   208 00000593 59                  <3>  pop cx
   209 00000594 5B                  <3>  pop bx
   210 00000595 07                  <3>  pop es
   211 00000596 1F                  <3>  pop ds
   227                              <2> 
   228 00000597 08E4                <2>  or ah, ah
   229 00000599 7404                <2>  jz %%no_error
   230 0000059B F9                  <2>  stc
   231 0000059C CA0200              <2>  retf 2
   232                              <2> %%no_error:
   233 0000059F F8                  <2>  clc
   234 000005A0 CA0200              <2>  retf 2
   112                              <1> 
   113                              <1> .fn_get_status:
   114 000005A3 E82804              <1>     call    int13h_get_status
   115                              <1>     INT13_RETURN
   217 000005A6 894608              <2>  mov [bp + 8], ax
   218                              <2> 
   219 000005A9 06                  <2>  push es
   220 000005AA 53                  <2>  push bx
   221 000005AB BB4000              <2>  mov bx, BDA_SEG
   222 000005AE 8EC3                <2>  mov es, bx
   223 000005B0 2688267400          <2>  mov [es:BDA_HDD_STATUS], ah
   224 000005B5 5B                  <2>  pop bx
   225 000005B6 07                  <2>  pop es
   226                              <2>  INT13_RESTORE_REGS
   204 000005B7 5D                  <3>  pop bp
   205 000005B8 5F                  <3>  pop di
   206 000005B9 5E                  <3>  pop si
   207 000005BA 5A                  <3>  pop dx
   208 000005BB 59                  <3>  pop cx
   209 000005BC 5B                  <3>  pop bx
   210 000005BD 07                  <3>  pop es
   211 000005BE 1F                  <3>  pop ds
   227                              <2> 
   228 000005BF 08E4                <2>  or ah, ah
   229 000005C1 7404                <2>  jz %%no_error
   230 000005C3 F9                  <2>  stc
   231 000005C4 CA0200              <2>  retf 2
   232                              <2> %%no_error:
   233 000005C7 F8                  <2>  clc
   234 000005C8 CA0200              <2>  retf 2
   116                              <1> 
   117                              <1> .fn_read_sectors:
   118 000005CB E81104              <1>     call    int13h_read_sectors
   119                              <1>     INT13_RETURN
   217 000005CE 894608              <2>  mov [bp + 8], ax
   218                              <2> 
   219 000005D1 06                  <2>  push es
   220 000005D2 53                  <2>  push bx
   221 000005D3 BB4000              <2>  mov bx, BDA_SEG
   222 000005D6 8EC3                <2>  mov es, bx
   223 000005D8 2688267400          <2>  mov [es:BDA_HDD_STATUS], ah
   224 000005DD 5B                  <2>  pop bx
   225 000005DE 07                  <2>  pop es
   226                              <2>  INT13_RESTORE_REGS
   204 000005DF 5D                  <3>  pop bp
   205 000005E0 5F                  <3>  pop di
   206 000005E1 5E                  <3>  pop si
   207 000005E2 5A                  <3>  pop dx
   208 000005E3 59                  <3>  pop cx
   209 000005E4 5B                  <3>  pop bx
   210 000005E5 07                  <3>  pop es
   211 000005E6 1F                  <3>  pop ds
   227                              <2> 
   228 000005E7 08E4                <2>  or ah, ah
   229 000005E9 7404                <2>  jz %%no_error
   230 000005EB F9                  <2>  stc
   231 000005EC CA0200              <2>  retf 2
   232                              <2> %%no_error:
   233 000005EF F8                  <2>  clc
   234 000005F0 CA0200              <2>  retf 2
   120                              <1> 
   121                              <1> .fn_write_sectors:
   122 000005F3 E87E04              <1>     call    int13h_write_sectors
   123                              <1>     INT13_RETURN
   217 000005F6 894608              <2>  mov [bp + 8], ax
   218                              <2> 
   219 000005F9 06                  <2>  push es
   220 000005FA 53                  <2>  push bx
   221 000005FB BB4000              <2>  mov bx, BDA_SEG
   222 000005FE 8EC3                <2>  mov es, bx
   223 00000600 2688267400          <2>  mov [es:BDA_HDD_STATUS], ah
   224 00000605 5B                  <2>  pop bx
   225 00000606 07                  <2>  pop es
   226                              <2>  INT13_RESTORE_REGS
   204 00000607 5D                  <3>  pop bp
   205 00000608 5F                  <3>  pop di
   206 00000609 5E                  <3>  pop si
   207 0000060A 5A                  <3>  pop dx
   208 0000060B 59                  <3>  pop cx
   209 0000060C 5B                  <3>  pop bx
   210 0000060D 07                  <3>  pop es
   211 0000060E 1F                  <3>  pop ds
   227                              <2> 
   228 0000060F 08E4                <2>  or ah, ah
   229 00000611 7404                <2>  jz %%no_error
   230 00000613 F9                  <2>  stc
   231 00000614 CA0200              <2>  retf 2
   232                              <2> %%no_error:
   233 00000617 F8                  <2>  clc
   234 00000618 CA0200              <2>  retf 2
   124                              <1> 
   125                              <1> .fn_verify_sectors:
   126 0000061B E81F05              <1>     call    int13h_verify_sectors
   127                              <1>     INT13_RETURN
   217 0000061E 894608              <2>  mov [bp + 8], ax
   218                              <2> 
   219 00000621 06                  <2>  push es
   220 00000622 53                  <2>  push bx
   221 00000623 BB4000              <2>  mov bx, BDA_SEG
   222 00000626 8EC3                <2>  mov es, bx
   223 00000628 2688267400          <2>  mov [es:BDA_HDD_STATUS], ah
   224 0000062D 5B                  <2>  pop bx
   225 0000062E 07                  <2>  pop es
   226                              <2>  INT13_RESTORE_REGS
   204 0000062F 5D                  <3>  pop bp
   205 00000630 5F                  <3>  pop di
   206 00000631 5E                  <3>  pop si
   207 00000632 5A                  <3>  pop dx
   208 00000633 59                  <3>  pop cx
   209 00000634 5B                  <3>  pop bx
   210 00000635 07                  <3>  pop es
   211 00000636 1F                  <3>  pop ds
   227                              <2> 
   228 00000637 08E4                <2>  or ah, ah
   229 00000639 7404                <2>  jz %%no_error
   230 0000063B F9                  <2>  stc
   231 0000063C CA0200              <2>  retf 2
   232                              <2> %%no_error:
   233 0000063F F8                  <2>  clc
   234 00000640 CA0200              <2>  retf 2
   128                              <1> 
   129                              <1> .fn_format_track:
   130 00000643 E85B05              <1>     call    int13h_format_track
   131                              <1>     INT13_RETURN
   217 00000646 894608              <2>  mov [bp + 8], ax
   218                              <2> 
   219 00000649 06                  <2>  push es
   220 0000064A 53                  <2>  push bx
   221 0000064B BB4000              <2>  mov bx, BDA_SEG
   222 0000064E 8EC3                <2>  mov es, bx
   223 00000650 2688267400          <2>  mov [es:BDA_HDD_STATUS], ah
   224 00000655 5B                  <2>  pop bx
   225 00000656 07                  <2>  pop es
   226                              <2>  INT13_RESTORE_REGS
   204 00000657 5D                  <3>  pop bp
   205 00000658 5F                  <3>  pop di
   206 00000659 5E                  <3>  pop si
   207 0000065A 5A                  <3>  pop dx
   208 0000065B 59                  <3>  pop cx
   209 0000065C 5B                  <3>  pop bx
   210 0000065D 07                  <3>  pop es
   211 0000065E 1F                  <3>  pop ds
   227                              <2> 
   228 0000065F 08E4                <2>  or ah, ah
   229 00000661 7404                <2>  jz %%no_error
   230 00000663 F9                  <2>  stc
   231 00000664 CA0200              <2>  retf 2
   232                              <2> %%no_error:
   233 00000667 F8                  <2>  clc
   234 00000668 CA0200              <2>  retf 2
   132                              <1> 
   133                              <1> .fn_get_parameters:
   134 0000066B E88F05              <1>     call    int13h_get_parameters
   135                              <1>     INT13_RETURN
   217 0000066E 894608              <2>  mov [bp + 8], ax
   218                              <2> 
   219 00000671 06                  <2>  push es
   220 00000672 53                  <2>  push bx
   221 00000673 BB4000              <2>  mov bx, BDA_SEG
   222 00000676 8EC3                <2>  mov es, bx
   223 00000678 2688267400          <2>  mov [es:BDA_HDD_STATUS], ah
   224 0000067D 5B                  <2>  pop bx
   225 0000067E 07                  <2>  pop es
   226                              <2>  INT13_RESTORE_REGS
   204 0000067F 5D                  <3>  pop bp
   205 00000680 5F                  <3>  pop di
   206 00000681 5E                  <3>  pop si
   207 00000682 5A                  <3>  pop dx
   208 00000683 59                  <3>  pop cx
   209 00000684 5B                  <3>  pop bx
   210 00000685 07                  <3>  pop es
   211 00000686 1F                  <3>  pop ds
   227                              <2> 
   228 00000687 08E4                <2>  or ah, ah
   229 00000689 7404                <2>  jz %%no_error
   230 0000068B F9                  <2>  stc
   231 0000068C CA0200              <2>  retf 2
   232                              <2> %%no_error:
   233 0000068F F8                  <2>  clc
   234 00000690 CA0200              <2>  retf 2
   136                              <1> 
   137                              <1> %if ENABLE_EXTENDED
   138                              <1> .fn_init_drive:
   139 00000693 E8B80C              <1>     call    int13h_init_drive
   140                              <1>     INT13_RETURN
   217 00000696 894608              <2>  mov [bp + 8], ax
   218                              <2> 
   219 00000699 06                  <2>  push es
   220 0000069A 53                  <2>  push bx
   221 0000069B BB4000              <2>  mov bx, BDA_SEG
   222 0000069E 8EC3                <2>  mov es, bx
   223 000006A0 2688267400          <2>  mov [es:BDA_HDD_STATUS], ah
   224 000006A5 5B                  <2>  pop bx
   225 000006A6 07                  <2>  pop es
   226                              <2>  INT13_RESTORE_REGS
   204 000006A7 5D                  <3>  pop bp
   205 000006A8 5F                  <3>  pop di
   206 000006A9 5E                  <3>  pop si
   207 000006AA 5A                  <3>  pop dx
   208 000006AB 59                  <3>  pop cx
   209 000006AC 5B                  <3>  pop bx
   210 000006AD 07                  <3>  pop es
   211 000006AE 1F                  <3>  pop ds
   227                              <2> 
   228 000006AF 08E4                <2>  or ah, ah
   229 000006B1 7404                <2>  jz %%no_error
   230 000006B3 F9                  <2>  stc
   231 000006B4 CA0200              <2>  retf 2
   232                              <2> %%no_error:
   233 000006B7 F8                  <2>  clc
   234 000006B8 CA0200              <2>  retf 2
   141                              <1> 
   142                              <1> .fn_read_long:
   143 000006BB E8FE0C              <1>     call    int13h_read_long
   144                              <1>     INT13_RETURN
   217 000006BE 894608              <2>  mov [bp + 8], ax
   218                              <2> 
   219 000006C1 06                  <2>  push es
   220 000006C2 53                  <2>  push bx
   221 000006C3 BB4000              <2>  mov bx, BDA_SEG
   222 000006C6 8EC3                <2>  mov es, bx
   223 000006C8 2688267400          <2>  mov [es:BDA_HDD_STATUS], ah
   224 000006CD 5B                  <2>  pop bx
   225 000006CE 07                  <2>  pop es
   226                              <2>  INT13_RESTORE_REGS
   204 000006CF 5D                  <3>  pop bp
   205 000006D0 5F                  <3>  pop di
   206 000006D1 5E                  <3>  pop si
   207 000006D2 5A                  <3>  pop dx
   208 000006D3 59                  <3>  pop cx
   209 000006D4 5B                  <3>  pop bx
   210 000006D5 07                  <3>  pop es
   211 000006D6 1F                  <3>  pop ds
   227                              <2> 
   228 000006D7 08E4                <2>  or ah, ah
   229 000006D9 7404                <2>  jz %%no_error
   230 000006DB F9                  <2>  stc
   231 000006DC CA0200              <2>  retf 2
   232                              <2> %%no_error:
   233 000006DF F8                  <2>  clc
   234 000006E0 CA0200              <2>  retf 2
   145                              <1> 
   146                              <1> .fn_write_long:
   147 000006E3 E83E0D              <1>     call    int13h_write_long
   148                              <1>     INT13_RETURN
   217 000006E6 894608              <2>  mov [bp + 8], ax
   218                              <2> 
   219 000006E9 06                  <2>  push es
   220 000006EA 53                  <2>  push bx
   221 000006EB BB4000              <2>  mov bx, BDA_SEG
   222 000006EE 8EC3                <2>  mov es, bx
   223 000006F0 2688267400          <2>  mov [es:BDA_HDD_STATUS], ah
   224 000006F5 5B                  <2>  pop bx
   225 000006F6 07                  <2>  pop es
   226                              <2>  INT13_RESTORE_REGS
   204 000006F7 5D                  <3>  pop bp
   205 000006F8 5F                  <3>  pop di
   206 000006F9 5E                  <3>  pop si
   207 000006FA 5A                  <3>  pop dx
   208 000006FB 59                  <3>  pop cx
   209 000006FC 5B                  <3>  pop bx
   210 000006FD 07                  <3>  pop es
   211 000006FE 1F                  <3>  pop ds
   227                              <2> 
   228 000006FF 08E4                <2>  or ah, ah
   229 00000701 7404                <2>  jz %%no_error
   230 00000703 F9                  <2>  stc
   231 00000704 CA0200              <2>  retf 2
   232                              <2> %%no_error:
   233 00000707 F8                  <2>  clc
   234 00000708 CA0200              <2>  retf 2
   149                              <1> 
   150                              <1> .fn_seek:
   151 0000070B E88A0D              <1>     call    int13h_seek
   152                              <1>     INT13_RETURN
   217 0000070E 894608              <2>  mov [bp + 8], ax
   218                              <2> 
   219 00000711 06                  <2>  push es
   220 00000712 53                  <2>  push bx
   221 00000713 BB4000              <2>  mov bx, BDA_SEG
   222 00000716 8EC3                <2>  mov es, bx
   223 00000718 2688267400          <2>  mov [es:BDA_HDD_STATUS], ah
   224 0000071D 5B                  <2>  pop bx
   225 0000071E 07                  <2>  pop es
   226                              <2>  INT13_RESTORE_REGS
   204 0000071F 5D                  <3>  pop bp
   205 00000720 5F                  <3>  pop di
   206 00000721 5E                  <3>  pop si
   207 00000722 5A                  <3>  pop dx
   208 00000723 59                  <3>  pop cx
   209 00000724 5B                  <3>  pop bx
   210 00000725 07                  <3>  pop es
   211 00000726 1F                  <3>  pop ds
   227                              <2> 
   228 00000727 08E4                <2>  or ah, ah
   229 00000729 7404                <2>  jz %%no_error
   230 0000072B F9                  <2>  stc
   231 0000072C CA0200              <2>  retf 2
   232                              <2> %%no_error:
   233 0000072F F8                  <2>  clc
   234 00000730 CA0200              <2>  retf 2
   153                              <1> 
   154                              <1> .fn_reset_alternate:
   155 00000733 E83002              <1>     call    int13h_reset             ; Same as regular reset
   156                              <1>     INT13_RETURN
   217 00000736 894608              <2>  mov [bp + 8], ax
   218                              <2> 
   219 00000739 06                  <2>  push es
   220 0000073A 53                  <2>  push bx
   221 0000073B BB4000              <2>  mov bx, BDA_SEG
   222 0000073E 8EC3                <2>  mov es, bx
   223 00000740 2688267400          <2>  mov [es:BDA_HDD_STATUS], ah
   224 00000745 5B                  <2>  pop bx
   225 00000746 07                  <2>  pop es
   226                              <2>  INT13_RESTORE_REGS
   204 00000747 5D                  <3>  pop bp
   205 00000748 5F                  <3>  pop di
   206 00000749 5E                  <3>  pop si
   207 0000074A 5A                  <3>  pop dx
   208 0000074B 59                  <3>  pop cx
   209 0000074C 5B                  <3>  pop bx
   210 0000074D 07                  <3>  pop es
   211 0000074E 1F                  <3>  pop ds
   227                              <2> 
   228 0000074F 08E4                <2>  or ah, ah
   229 00000751 7404                <2>  jz %%no_error
   230 00000753 F9                  <2>  stc
   231 00000754 CA0200              <2>  retf 2
   232                              <2> %%no_error:
   233 00000757 F8                  <2>  clc
   234 00000758 CA0200              <2>  retf 2
   157                              <1> 
   158                              <1> .fn_test_ready:
   159 0000075B E8890D              <1>     call    int13h_test_ready
   160                              <1>     INT13_RETURN
   217 0000075E 894608              <2>  mov [bp + 8], ax
   218                              <2> 
   219 00000761 06                  <2>  push es
   220 00000762 53                  <2>  push bx
   221 00000763 BB4000              <2>  mov bx, BDA_SEG
   222 00000766 8EC3                <2>  mov es, bx
   223 00000768 2688267400          <2>  mov [es:BDA_HDD_STATUS], ah
   224 0000076D 5B                  <2>  pop bx
   225 0000076E 07                  <2>  pop es
   226                              <2>  INT13_RESTORE_REGS
   204 0000076F 5D                  <3>  pop bp
   205 00000770 5F                  <3>  pop di
   206 00000771 5E                  <3>  pop si
   207 00000772 5A                  <3>  pop dx
   208 00000773 59                  <3>  pop cx
   209 00000774 5B                  <3>  pop bx
   210 00000775 07                  <3>  pop es
   211 00000776 1F                  <3>  pop ds
   227                              <2> 
   228 00000777 08E4                <2>  or ah, ah
   229 00000779 7404                <2>  jz %%no_error
   230 0000077B F9                  <2>  stc
   231 0000077C CA0200              <2>  retf 2
   232                              <2> %%no_error:
   233 0000077F F8                  <2>  clc
   234 00000780 CA0200              <2>  retf 2
   161                              <1> 
   162                              <1> .fn_recalibrate:
   163 00000783 E87D0D              <1>     call    int13h_recalibrate
   164                              <1>     INT13_RETURN
   217 00000786 894608              <2>  mov [bp + 8], ax
   218                              <2> 
   219 00000789 06                  <2>  push es
   220 0000078A 53                  <2>  push bx
   221 0000078B BB4000              <2>  mov bx, BDA_SEG
   222 0000078E 8EC3                <2>  mov es, bx
   223 00000790 2688267400          <2>  mov [es:BDA_HDD_STATUS], ah
   224 00000795 5B                  <2>  pop bx
   225 00000796 07                  <2>  pop es
   226                              <2>  INT13_RESTORE_REGS
   204 00000797 5D                  <3>  pop bp
   205 00000798 5F                  <3>  pop di
   206 00000799 5E                  <3>  pop si
   207 0000079A 5A                  <3>  pop dx
   208 0000079B 59                  <3>  pop cx
   209 0000079C 5B                  <3>  pop bx
   210 0000079D 07                  <3>  pop es
   211 0000079E 1F                  <3>  pop ds
   227                              <2> 
   228 0000079F 08E4                <2>  or ah, ah
   229 000007A1 7404                <2>  jz %%no_error
   230 000007A3 F9                  <2>  stc
   231 000007A4 CA0200              <2>  retf 2
   232                              <2> %%no_error:
   233 000007A7 F8                  <2>  clc
   234 000007A8 CA0200              <2>  retf 2
   165                              <1> 
   166                              <1> .fn_diagnostic:
   167 000007AB E8A30D              <1>     call    int13h_diagnostic
   168                              <1>     INT13_RETURN
   217 000007AE 894608              <2>  mov [bp + 8], ax
   218                              <2> 
   219 000007B1 06                  <2>  push es
   220 000007B2 53                  <2>  push bx
   221 000007B3 BB4000              <2>  mov bx, BDA_SEG
   222 000007B6 8EC3                <2>  mov es, bx
   223 000007B8 2688267400          <2>  mov [es:BDA_HDD_STATUS], ah
   224 000007BD 5B                  <2>  pop bx
   225 000007BE 07                  <2>  pop es
   226                              <2>  INT13_RESTORE_REGS
   204 000007BF 5D                  <3>  pop bp
   205 000007C0 5F                  <3>  pop di
   206 000007C1 5E                  <3>  pop si
   207 000007C2 5A                  <3>  pop dx
   208 000007C3 59                  <3>  pop cx
   209 000007C4 5B                  <3>  pop bx
   210 000007C5 07                  <3>  pop es
   211 000007C6 1F                  <3>  pop ds
   227                              <2> 
   228 000007C7 08E4                <2>  or ah, ah
   229 000007C9 7404                <2>  jz %%no_error
   230 000007CB F9                  <2>  stc
   231 000007CC CA0200              <2>  retf 2
   232                              <2> %%no_error:
   233 000007CF F8                  <2>  clc
   234 000007D0 CA0200              <2>  retf 2
   169                              <1> 
   170                              <1> .fn_get_disk_type:
   171 000007D3 E8B50D              <1>     call    int13h_get_disk_type
   172                              <1>     INT13_RETURN
   217 000007D6 894608              <2>  mov [bp + 8], ax
   218                              <2> 
   219 000007D9 06                  <2>  push es
   220 000007DA 53                  <2>  push bx
   221 000007DB BB4000              <2>  mov bx, BDA_SEG
   222 000007DE 8EC3                <2>  mov es, bx
   223 000007E0 2688267400          <2>  mov [es:BDA_HDD_STATUS], ah
   224 000007E5 5B                  <2>  pop bx
   225 000007E6 07                  <2>  pop es
   226                              <2>  INT13_RESTORE_REGS
   204 000007E7 5D                  <3>  pop bp
   205 000007E8 5F                  <3>  pop di
   206 000007E9 5E                  <3>  pop si
   207 000007EA 5A                  <3>  pop dx
   208 000007EB 59                  <3>  pop cx
   209 000007EC 5B                  <3>  pop bx
   210 000007ED 07                  <3>  pop es
   211 000007EE 1F                  <3>  pop ds
   227                              <2> 
   228 000007EF 08E4                <2>  or ah, ah
   229 000007F1 7404                <2>  jz %%no_error
   230 000007F3 F9                  <2>  stc
   231 000007F4 CA0200              <2>  retf 2
   232                              <2> %%no_error:
   233 000007F7 F8                  <2>  clc
   234 000007F8 CA0200              <2>  retf 2
   173                              <1> %endif
   174                              <1> 
   175                              <1> %if ENABLE_LBA
   176                              <1> .fn_check_extensions:
   177 000007FB E8C00D              <1>     call    int13h_check_extensions
   178                              <1>     INT13_RETURN
   217 000007FE 894608              <2>  mov [bp + 8], ax
   218                              <2> 
   219 00000801 06                  <2>  push es
   220 00000802 53                  <2>  push bx
   221 00000803 BB4000              <2>  mov bx, BDA_SEG
   222 00000806 8EC3                <2>  mov es, bx
   223 00000808 2688267400          <2>  mov [es:BDA_HDD_STATUS], ah
   224 0000080D 5B                  <2>  pop bx
   225 0000080E 07                  <2>  pop es
   226                              <2>  INT13_RESTORE_REGS
   204 0000080F 5D                  <3>  pop bp
   205 00000810 5F                  <3>  pop di
   206 00000811 5E                  <3>  pop si
   207 00000812 5A                  <3>  pop dx
   208 00000813 59                  <3>  pop cx
   209 00000814 5B                  <3>  pop bx
   210 00000815 07                  <3>  pop es
   211 00000816 1F                  <3>  pop ds
   227                              <2> 
   228 00000817 08E4                <2>  or ah, ah
   229 00000819 7404                <2>  jz %%no_error
   230 0000081B F9                  <2>  stc
   231 0000081C CA0200              <2>  retf 2
   232                              <2> %%no_error:
   233 0000081F F8                  <2>  clc
   234 00000820 CA0200              <2>  retf 2
   179                              <1> 
   180                              <1> .fn_ext_read:
   181 00000823 E8B30D              <1>     call    int13h_ext_read
   182                              <1>     INT13_RETURN
   217 00000826 894608              <2>  mov [bp + 8], ax
   218                              <2> 
   219 00000829 06                  <2>  push es
   220 0000082A 53                  <2>  push bx
   221 0000082B BB4000              <2>  mov bx, BDA_SEG
   222 0000082E 8EC3                <2>  mov es, bx
   223 00000830 2688267400          <2>  mov [es:BDA_HDD_STATUS], ah
   224 00000835 5B                  <2>  pop bx
   225 00000836 07                  <2>  pop es
   226                              <2>  INT13_RESTORE_REGS
   204 00000837 5D                  <3>  pop bp
   205 00000838 5F                  <3>  pop di
   206 00000839 5E                  <3>  pop si
   207 0000083A 5A                  <3>  pop dx
   208 0000083B 59                  <3>  pop cx
   209 0000083C 5B                  <3>  pop bx
   210 0000083D 07                  <3>  pop es
   211 0000083E 1F                  <3>  pop ds
   227                              <2> 
   228 0000083F 08E4                <2>  or ah, ah
   229 00000841 7404                <2>  jz %%no_error
   230 00000843 F9                  <2>  stc
   231 00000844 CA0200              <2>  retf 2
   232                              <2> %%no_error:
   233 00000847 F8                  <2>  clc
   234 00000848 CA0200              <2>  retf 2
   183                              <1> 
   184                              <1> .fn_ext_write:
   185 0000084B E8660E              <1>     call    int13h_ext_write
   186                              <1>     INT13_RETURN
   217 0000084E 894608              <2>  mov [bp + 8], ax
   218                              <2> 
   219 00000851 06                  <2>  push es
   220 00000852 53                  <2>  push bx
   221 00000853 BB4000              <2>  mov bx, BDA_SEG
   222 00000856 8EC3                <2>  mov es, bx
   223 00000858 2688267400          <2>  mov [es:BDA_HDD_STATUS], ah
   224 0000085D 5B                  <2>  pop bx
   225 0000085E 07                  <2>  pop es
   226                              <2>  INT13_RESTORE_REGS
   204 0000085F 5D                  <3>  pop bp
   205 00000860 5F                  <3>  pop di
   206 00000861 5E                  <3>  pop si
   207 00000862 5A                  <3>  pop dx
   208 00000863 59                  <3>  pop cx
   209 00000864 5B                  <3>  pop bx
   210 00000865 07                  <3>  pop es
   211 00000866 1F                  <3>  pop ds
   227                              <2> 
   228 00000867 08E4                <2>  or ah, ah
   229 00000869 7404                <2>  jz %%no_error
   230 0000086B F9                  <2>  stc
   231 0000086C CA0200              <2>  retf 2
   232                              <2> %%no_error:
   233 0000086F F8                  <2>  clc
   234 00000870 CA0200              <2>  retf 2
   187                              <1> 
   188                              <1> .fn_ext_verify:
   189 00000873 E84C0F              <1>     call    int13h_ext_verify
   190                              <1>     INT13_RETURN
   217 00000876 894608              <2>  mov [bp + 8], ax
   218                              <2> 
   219 00000879 06                  <2>  push es
   220 0000087A 53                  <2>  push bx
   221 0000087B BB4000              <2>  mov bx, BDA_SEG
   222 0000087E 8EC3                <2>  mov es, bx
   223 00000880 2688267400          <2>  mov [es:BDA_HDD_STATUS], ah
   224 00000885 5B                  <2>  pop bx
   225 00000886 07                  <2>  pop es
   226                              <2>  INT13_RESTORE_REGS
   204 00000887 5D                  <3>  pop bp
   205 00000888 5F                  <3>  pop di
   206 00000889 5E                  <3>  pop si
   207 0000088A 5A                  <3>  pop dx
   208 0000088B 59                  <3>  pop cx
   209 0000088C 5B                  <3>  pop bx
   210 0000088D 07                  <3>  pop es
   211 0000088E 1F                  <3>  pop ds
   227                              <2> 
   228 0000088F 08E4                <2>  or ah, ah
   229 00000891 7404                <2>  jz %%no_error
   230 00000893 F9                  <2>  stc
   231 00000894 CA0200              <2>  retf 2
   232                              <2> %%no_error:
   233 00000897 F8                  <2>  clc
   234 00000898 CA0200              <2>  retf 2
   191                              <1> 
   192                              <1> .fn_ext_seek:
   193 0000089B E8E90F              <1>     call    int13h_ext_seek
   194                              <1>     INT13_RETURN
   217 0000089E 894608              <2>  mov [bp + 8], ax
   218                              <2> 
   219 000008A1 06                  <2>  push es
   220 000008A2 53                  <2>  push bx
   221 000008A3 BB4000              <2>  mov bx, BDA_SEG
   222 000008A6 8EC3                <2>  mov es, bx
   223 000008A8 2688267400          <2>  mov [es:BDA_HDD_STATUS], ah
   224 000008AD 5B                  <2>  pop bx
   225 000008AE 07                  <2>  pop es
   226                              <2>  INT13_RESTORE_REGS
   204 000008AF 5D                  <3>  pop bp
   205 000008B0 5F                  <3>  pop di
   206 000008B1 5E                  <3>  pop si
   207 000008B2 5A                  <3>  pop dx
   208 000008B3 59                  <3>  pop cx
   209 000008B4 5B                  <3>  pop bx
   210 000008B5 07                  <3>  pop es
   211 000008B6 1F                  <3>  pop ds
   227                              <2> 
   228 000008B7 08E4                <2>  or ah, ah
   229 000008B9 7404                <2>  jz %%no_error
   230 000008BB F9                  <2>  stc
   231 000008BC CA0200              <2>  retf 2
   232                              <2> %%no_error:
   233 000008BF F8                  <2>  clc
   234 000008C0 CA0200              <2>  retf 2
   195                              <1> 
   196                              <1> .fn_get_ext_params:
   197 000008C3 E82610              <1>     call    int13h_get_ext_params
   198                              <1>     INT13_RETURN
   217 000008C6 894608              <2>  mov [bp + 8], ax
   218                              <2> 
   219 000008C9 06                  <2>  push es
   220 000008CA 53                  <2>  push bx
   221 000008CB BB4000              <2>  mov bx, BDA_SEG
   222 000008CE 8EC3                <2>  mov es, bx
   223 000008D0 2688267400          <2>  mov [es:BDA_HDD_STATUS], ah
   224 000008D5 5B                  <2>  pop bx
   225 000008D6 07                  <2>  pop es
   226                              <2>  INT13_RESTORE_REGS
   204 000008D7 5D                  <3>  pop bp
   205 000008D8 5F                  <3>  pop di
   206 000008D9 5E                  <3>  pop si
   207 000008DA 5A                  <3>  pop dx
   208 000008DB 59                  <3>  pop cx
   209 000008DC 5B                  <3>  pop bx
   210 000008DD 07                  <3>  pop es
   211 000008DE 1F                  <3>  pop ds
   227                              <2> 
   228 000008DF 08E4                <2>  or ah, ah
   229 000008E1 7404                <2>  jz %%no_error
   230 000008E3 F9                  <2>  stc
   231 000008E4 CA0200              <2>  retf 2
   232                              <2> %%no_error:
   233 000008E7 F8                  <2>  clc
   234 000008E8 CA0200              <2>  retf 2
   199                              <1> %endif
   200                              <1> 
   201                              <1> ;------------------------------------------------------------------------------
   202                              <1> ; Chain to Original INT 13h (for floppy or unhandled drives)
   203                              <1> ;------------------------------------------------------------------------------
   204                              <1> .chain_to_original:
   205                              <1>     ; Jump to original handler (saved during init)
   206 000008EB 2EFF2E[9031]        <1>     jmp     far [cs:old_int13h]
   207                              <1> 
   208                              <1> ;==============================================================================
   209                              <1> ; Helper: Get Drive Parameters Pointer
   210                              <1> ;==============================================================================
   211                              <1> ; Returns pointer to drive parameter structure for given drive.
   212                              <1> ;
   213                              <1> ; Input:  DL = drive number (80h or 81h)
   214                              <1> ; Output: SI = pointer to drive_params structure
   215                              <1> ;         CF = 0 if valid, CF = 1 if invalid drive
   216                              <1> ; Destroys: AX
   217                              <1> ;==============================================================================
   218                              <1> get_drive_params:
   219 000008F0 88D0                <1>     mov     al, dl
   220 000008F2 2C80                <1>     sub     al, 0x80                ; Convert to 0/1
   221                              <1> 
   222 000008F4 3A06[C831]          <1>     cmp     al, [num_drives]        ; Valid drive?
   223 000008F8 730E                <1>     jae     .invalid
   224                              <1> 
   225                              <1>     ; Calculate pointer
   226 000008FA 84C0                <1>     test    al, al
   227 000008FC 7405                <1>     jz      .drive0
   228 000008FE BE[A031]            <1>     mov     si, drive1_params
   229 00000901 F8                  <1>     clc
   230 00000902 C3                  <1>     ret
   231                              <1> 
   232                              <1> .drive0:
   233 00000903 BE[9831]            <1>     mov     si, drive0_params
   234 00000906 F8                  <1>     clc
   235 00000907 C3                  <1>     ret
   236                              <1> 
   237                              <1> .invalid:
   238 00000908 F9                  <1>     stc
   239 00000909 C3                  <1>     ret
   240                              <1> 
   241                              <1> ;==============================================================================
   242                              <1> ; Helper: Get FDPT Pointer
   243                              <1> ;==============================================================================
   244                              <1> ; Returns pointer to FDPT for given drive.
   245                              <1> ;
   246                              <1> ; Input:  DL = drive number (80h or 81h)
   247                              <1> ; Output: SI = pointer to FDPT structure
   248                              <1> ;         CF = 0 if valid, CF = 1 if invalid drive
   249                              <1> ; Destroys: AX
   250                              <1> ;==============================================================================
   251                              <1> get_fdpt_ptr:
   252 0000090A 88D0                <1>     mov     al, dl
   253 0000090C 2C80                <1>     sub     al, 0x80
   254                              <1> 
   255 0000090E 3A06[C831]          <1>     cmp     al, [num_drives]
   256 00000912 730E                <1>     jae     .invalid
   257                              <1> 
   258 00000914 84C0                <1>     test    al, al
   259 00000916 7405                <1>     jz      .drive0
   260 00000918 BE[B831]            <1>     mov     si, fdpt_drive1
   261 0000091B F8                  <1>     clc
   262 0000091C C3                  <1>     ret
   263                              <1> 
   264                              <1> .drive0:
   265 0000091D BE[A831]            <1>     mov     si, fdpt_drive0
   266 00000920 F8                  <1>     clc
   267 00000921 C3                  <1>     ret
   268                              <1> 
   269                              <1> .invalid:
   270 00000922 F9                  <1>     stc
   271 00000923 C3                  <1>     ret
   272                              <1> 
   273                              <1> ;==============================================================================
   274                              <1> ; Helper: Select Drive on WD Controller
   275                              <1> ;==============================================================================
   276                              <1> ; Sets up SDH register to select the appropriate drive.
   277                              <1> ;
   278                              <1> ; Input:  DL = drive number (80h or 81h)
   279                              <1> ;         DH = head number
   280                              <1> ; Output: SDH register written
   281                              <1> ; Destroys: AX, DX
   282                              <1> ;==============================================================================
   283                              <1> select_drive:
   284 00000924 52                  <1>     push    dx
   285                              <1> 
   286                              <1>     ; Calculate SDH value
   287 00000925 88F0                <1>     mov     al, dh                  ; Head in low 4 bits
   288 00000927 240F                <1>     and     al, 0x0F
   289 00000929 0CA0                <1>     or      al, SDH_SIZE_512        ; 512-byte sectors
   290                              <1> 
   291                              <1>     ; Set drive select bit if drive 1
   292 0000092B 80FA81              <1>     cmp     dl, 0x81
   293 0000092E 7502                <1>     jne     .write_sdh
   294 00000930 0C10                <1>     or      al, SDH_DRV1
   295                              <1> 
   296                              <1> .write_sdh:
   297 00000932 8B16[C931]          <1>     mov     dx, [current_base]
   298 00000936 83C206              <1>     add     dx, WD_SDH
   299 00000939 EE                  <1>     out     dx, al
   300                              <1> 
   301 0000093A 5A                  <1>     pop     dx
   302 0000093B C3                  <1>     ret
   303                              <1> 
   304                              <1> ;==============================================================================
   305                              <1> ; Helper: Wait for Drive Ready
   306                              <1> ;==============================================================================
   307                              <1> ; Waits for drive to become ready (BSY clear, DRDY set).
   308                              <1> ;
   309                              <1> ; Output: CF = 0 if ready, CF = 1 if timeout
   310                              <1> ;         AL = status register value
   311                              <1> ; Destroys: AX, CX, DX
   312                              <1> ;==============================================================================
   313                              <1> wait_drive_ready:
   314 0000093C 8B16[C931]          <1>     mov     dx, [current_base]
   315 00000940 83C207              <1>     add     dx, WD_STATUS
   316 00000943 B9FFFF              <1>     mov     cx, TIMEOUT_DRDY
   317                              <1> 
   318                              <1> .wait_loop:
   319 00000946 EC                  <1>     in      al, dx
   320 00000947 A880                <1>     test    al, STS_BSY             ; Busy?
   321 00000949 7504                <1>     jnz     .continue
   322 0000094B A840                <1>     test    al, STS_DRDY            ; Ready?
   323 0000094D 7504                <1>     jnz     .ready
   324                              <1> 
   325                              <1> .continue:
   326 0000094F E2F5                <1>     loop    .wait_loop
   327                              <1> 
   328                              <1>     ; Timeout
   329 00000951 F9                  <1>     stc
   330 00000952 C3                  <1>     ret
   331                              <1> 
   332                              <1> .ready:
   333 00000953 F8                  <1>     clc
   334 00000954 C3                  <1>     ret
   335                              <1> 
   336                              <1> ;==============================================================================
   337                              <1> ; Helper: Store Last Status
   338                              <1> ;==============================================================================
   339                              <1> ; Stores status in BDA for subsequent GET_STATUS calls.
   340                              <1> ;
   341                              <1> ; Input: AH = status code
   342                              <1> ; Destroys: Nothing (preserves all registers)
   343                              <1> ;==============================================================================
   344                              <1> store_status:
   345 00000955 06                  <1>     push    es
   346 00000956 53                  <1>     push    bx
   347 00000957 50                  <1>     push    ax
   348                              <1> 
   349 00000958 BB4000              <1>     mov     bx, BDA_SEG
   350 0000095B 8EC3                <1>     mov     es, bx
   351 0000095D 2688267400          <1>     mov     [es:BDA_HDD_STATUS], ah
   352                              <1> 
   353 00000962 58                  <1>     pop     ax
   354 00000963 5B                  <1>     pop     bx
   355 00000964 07                  <1>     pop     es
   356 00000965 C3                  <1>     ret
   217                                  %include "func_basic.asm"
     1                              <1> ;==============================================================================
     2                              <1> ; FluxRipper HDD BIOS - Basic INT 13h Functions (00h-08h)
     3                              <1> ;==============================================================================
     4                              <1> ; Implements core INT 13h functions required for basic disk access.
     5                              <1> ;
     6                              <1> ; Functions:
     7                              <1> ;   00h - Reset disk system
     8                              <1> ;   01h - Get status of last operation
     9                              <1> ;   02h - Read sectors
    10                              <1> ;   03h - Write sectors
    11                              <1> ;   04h - Verify sectors
    12                              <1> ;   05h - Format track
    13                              <1> ;   08h - Get drive parameters
    14                              <1> ;
    15                              <1> ; SPDX-License-Identifier: BSD-3-Clause
    16                              <1> ; Copyright (c) 2025 FluxRipper Project
    17                              <1> ;==============================================================================
    18                              <1> 
    19                              <1> ;==============================================================================
    20                              <1> ; Function 00h: Reset Disk System
    21                              <1> ;==============================================================================
    22                              <1> ; Resets the disk controller and recalibrates the drive.
    23                              <1> ;
    24                              <1> ; Input:  DL = drive number (80h, 81h)
    25                              <1> ; Output: AH = status (0 = success)
    26                              <1> ;         CF = 0 if success, 1 if error
    27                              <1> ;==============================================================================
    28                              <1> int13h_reset:
    29 00000966 53                  <1>     push    bx
    30 00000967 51                  <1>     push    cx
    31 00000968 52                  <1>     push    dx
    32                              <1> 
    33                              <1>     ; Select the drive
    34 00000969 E8B8FF              <1>     call    select_drive
    35                              <1> 
    36                              <1>     ; Issue software reset to controller
    37 0000096C 8B16[C931]          <1>     mov     dx, [current_base]
    38 00000970 81C20602            <1>     add     dx, WD_DEV_CTRL - WD_BASE_PRIMARY + WD_BASE_ALTERNATE
    39 00000974 B004                <1>     mov     al, CTRL_SRST           ; Assert reset
    40 00000976 EE                  <1>     out     dx, al
    41                              <1> 
    42                              <1>     ; Wait a bit
    43 00000977 B96400              <1>     mov     cx, 100
    44 0000097A E8FCF7              <1>     call    delay_us
    45                              <1> 
    46                              <1>     ; Clear reset
    47 0000097D 30C0                <1>     xor     al, al
    48 0000097F EE                  <1>     out     dx, al
    49                              <1> 
    50                              <1>     ; Wait for BSY to clear
    51 00000980 8B16[C931]          <1>     mov     dx, [current_base]
    52 00000984 83C207              <1>     add     dx, WD_STATUS
    53 00000987 B9FFFF              <1>     mov     cx, TIMEOUT_RESET
    54                              <1> 
    55                              <1> .wait_bsy:
    56 0000098A EC                  <1>     in      al, dx
    57 0000098B A880                <1>     test    al, STS_BSY
    58 0000098D 7406                <1>     jz      .bsy_clear
    59 0000098F E2F9                <1>     loop    .wait_bsy
    60                              <1> 
    61                              <1>     ; Timeout
    62 00000991 B480                <1>     mov     ah, ST_TIMEOUT
    63 00000993 EB35                <1>     jmp     .done
    64                              <1> 
    65                              <1> .bsy_clear:
    66                              <1>     ; Check for errors
    67 00000995 A801                <1>     test    al, STS_ERR
    68 00000997 740C                <1>     jz      .no_error
    69                              <1> 
    70                              <1>     ; Read error register
    71 00000999 8B16[C931]          <1>     mov     dx, [current_base]
    72 0000099D 83C201              <1>     add     dx, WD_ERROR
    73 000009A0 EC                  <1>     in      al, dx
    74 000009A1 B405                <1>     mov     ah, ST_RESET_FAILED
    75 000009A3 EB25                <1>     jmp     .done
    76                              <1> 
    77                              <1> .no_error:
    78                              <1>     ; Issue recalibrate command
    79 000009A5 8B16[C931]          <1>     mov     dx, [current_base]
    80 000009A9 83C207              <1>     add     dx, WD_COMMAND
    81 000009AC B010                <1>     mov     al, CMD_RECALIBRATE
    82 000009AE EE                  <1>     out     dx, al
    83                              <1> 
    84                              <1>     ; Wait for completion
    85 000009AF E88AFF              <1>     call    wait_drive_ready
    86 000009B2 7210                <1>     jc      .timeout
    87                              <1> 
    88                              <1>     ; Check status
    89 000009B4 8B16[C931]          <1>     mov     dx, [current_base]
    90 000009B8 83C207              <1>     add     dx, WD_STATUS
    91 000009BB EC                  <1>     in      al, dx
    92 000009BC A801                <1>     test    al, STS_ERR
    93 000009BE 7508                <1>     jnz     .recal_error
    94                              <1> 
    95 000009C0 B400                <1>     mov     ah, ST_SUCCESS
    96 000009C2 EB06                <1>     jmp     .done
    97                              <1> 
    98                              <1> .timeout:
    99 000009C4 B480                <1>     mov     ah, ST_TIMEOUT
   100 000009C6 EB02                <1>     jmp     .done
   101                              <1> 
   102                              <1> .recal_error:
   103 000009C8 B440                <1>     mov     ah, ST_SEEK_ERROR
   104                              <1> 
   105                              <1> .done:
   106 000009CA 5A                  <1>     pop     dx
   107 000009CB 59                  <1>     pop     cx
   108 000009CC 5B                  <1>     pop     bx
   109 000009CD C3                  <1>     ret
   110                              <1> 
   111                              <1> ;==============================================================================
   112                              <1> ; Function 01h: Get Status of Last Operation
   113                              <1> ;==============================================================================
   114                              <1> ; Returns the status of the last INT 13h operation.
   115                              <1> ;
   116                              <1> ; Input:  DL = drive number
   117                              <1> ; Output: AH = status from last operation
   118                              <1> ;         AL = 0
   119                              <1> ;         CF = 0 if last operation succeeded, 1 if failed
   120                              <1> ;==============================================================================
   121                              <1> int13h_get_status:
   122 000009CE 06                  <1>     push    es
   123 000009CF 53                  <1>     push    bx
   124                              <1> 
   125                              <1>     ; Read status from BDA
   126 000009D0 BB4000              <1>     mov     bx, BDA_SEG
   127 000009D3 8EC3                <1>     mov     es, bx
   128 000009D5 268A267400          <1>     mov     ah, [es:BDA_HDD_STATUS]
   129 000009DA 30C0                <1>     xor     al, al
   130                              <1> 
   131 000009DC 5B                  <1>     pop     bx
   132 000009DD 07                  <1>     pop     es
   133 000009DE C3                  <1>     ret
   134                              <1> 
   135                              <1> ;==============================================================================
   136                              <1> ; Function 02h: Read Sectors
   137                              <1> ;==============================================================================
   138                              <1> ; Reads sectors from disk to memory.
   139                              <1> ;
   140                              <1> ; Input:  AL = number of sectors to read
   141                              <1> ;         CH = cylinder low 8 bits
   142                              <1> ;         CL = sector (bits 0-5) + cylinder high (bits 6-7)
   143                              <1> ;         DH = head number
   144                              <1> ;         DL = drive number
   145                              <1> ;         ES:BX = buffer address
   146                              <1> ; Output: AH = status
   147                              <1> ;         AL = sectors read
   148                              <1> ;         CF = 0 if success, 1 if error
   149                              <1> ;==============================================================================
   150                              <1> int13h_read_sectors:
   151 000009DF 53                  <1>     push    bx
   152 000009E0 51                  <1>     push    cx
   153 000009E1 52                  <1>     push    dx
   154 000009E2 56                  <1>     push    si
   155 000009E3 57                  <1>     push    di
   156                              <1> 
   157                              <1>     ; Save sector count
   158 000009E4 A2[720A]            <1>     mov     [.sector_count], al
   159 000009E7 C606[730A]00        <1>     mov     byte [.sectors_done], 0
   160                              <1> 
   161                              <1>     ; Select drive and head
   162 000009EC E835FF              <1>     call    select_drive
   163                              <1> 
   164                              <1>     ; Wait for drive ready
   165 000009EF E84AFF              <1>     call    wait_drive_ready
   166 000009F2 7273                <1>     jc      .timeout
   167                              <1> 
   168                              <1>     ; Set up task file registers
   169                              <1>     ; Sector count
   170 000009F4 A0[720A]            <1>     mov     al, [.sector_count]
   171 000009F7 8B16[C931]          <1>     mov     dx, [current_base]
   172 000009FB 83C202              <1>     add     dx, WD_SECCNT
   173 000009FE EE                  <1>     out     dx, al
   174                              <1> 
   175                              <1>     ; Sector number (bits 0-5 of CL)
   176 000009FF 88C8                <1>     mov     al, cl
   177 00000A01 243F                <1>     and     al, 0x3F
   178 00000A03 42                  <1>     inc     dx                      ; WD_SECNUM
   179 00000A04 EE                  <1>     out     dx, al
   180                              <1> 
   181                              <1>     ; Cylinder low (CH)
   182 00000A05 88E8                <1>     mov     al, ch
   183 00000A07 42                  <1>     inc     dx                      ; WD_CYL_LO
   184 00000A08 EE                  <1>     out     dx, al
   185                              <1> 
   186                              <1>     ; Cylinder high (bits 6-7 of CL)
   187 00000A09 88C8                <1>     mov     al, cl
   188 00000A0B C0E806              <1>     shr     al, 6
   189 00000A0E 42                  <1>     inc     dx                      ; WD_CYL_HI
   190 00000A0F EE                  <1>     out     dx, al
   191                              <1> 
   192                              <1>     ; Issue READ command
   193 00000A10 8B16[C931]          <1>     mov     dx, [current_base]
   194 00000A14 83C207              <1>     add     dx, WD_COMMAND
   195 00000A17 B020                <1>     mov     al, CMD_READ
   196 00000A19 EE                  <1>     out     dx, al
   197                              <1> 
   198                              <1>     ; Read sector data
   199 00000A1A 89DF                <1>     mov     di, bx                  ; ES:DI = buffer
   200 00000A1C 8A0E[720A]          <1>     mov     cl, [.sector_count]
   201                              <1> 
   202                              <1> .read_sector_loop:
   203                              <1>     ; Wait for DRQ
   204 00000A20 8B16[C931]          <1>     mov     dx, [current_base]
   205 00000A24 83C207              <1>     add     dx, WD_STATUS
   206 00000A27 B9FFFF              <1>     mov     cx, TIMEOUT_DRQ_SET
   207                              <1> 
   208                              <1> .wait_drq:
   209 00000A2A EC                  <1>     in      al, dx
   210 00000A2B A801                <1>     test    al, STS_ERR
   211 00000A2D 7528                <1>     jnz     .read_error
   212 00000A2F A808                <1>     test    al, STS_DRQ
   213 00000A31 7504                <1>     jnz     .drq_set
   214 00000A33 E2F5                <1>     loop    .wait_drq
   215 00000A35 EB30                <1>     jmp     .timeout
   216                              <1> 
   217                              <1> .drq_set:
   218                              <1>     ; Read 256 words (512 bytes) from data register
   219 00000A37 8B16[C931]          <1>     mov     dx, [current_base]
   220 00000A3B 83C200              <1>     add     dx, WD_DATA
   221 00000A3E B90001              <1>     mov     cx, 256
   222 00000A41 F36D                <1>     rep insw                        ; Read words to ES:DI
   223                              <1> 
   224                              <1>     ; Increment sectors done
   225 00000A43 FE06[730A]          <1>     inc     byte [.sectors_done]
   226                              <1> 
   227                              <1>     ; Check if more sectors to read
   228 00000A47 A0[730A]            <1>     mov     al, [.sectors_done]
   229 00000A4A 3A06[720A]          <1>     cmp     al, [.sector_count]
   230 00000A4E 72D0                <1>     jb      .read_sector_loop
   231                              <1> 
   232                              <1>     ; Success
   233 00000A50 A0[730A]            <1>     mov     al, [.sectors_done]
   234 00000A53 B400                <1>     mov     ah, ST_SUCCESS
   235 00000A55 EB15                <1>     jmp     .done
   236                              <1> 
   237                              <1> .read_error:
   238                              <1>     ; Get error code
   239 00000A57 8B16[C931]          <1>     mov     dx, [current_base]
   240 00000A5B 83C201              <1>     add     dx, WD_ERROR
   241 00000A5E EC                  <1>     in      al, dx
   242 00000A5F E8C901              <1>     call    translate_error
   243 00000A62 A0[730A]            <1>     mov     al, [.sectors_done]
   244 00000A65 EB05                <1>     jmp     .done
   245                              <1> 
   246                              <1> .timeout:
   247 00000A67 B480                <1>     mov     ah, ST_TIMEOUT
   248 00000A69 A0[730A]            <1>     mov     al, [.sectors_done]
   249                              <1> 
   250                              <1> .done:
   251 00000A6C 5F                  <1>     pop     di
   252 00000A6D 5E                  <1>     pop     si
   253 00000A6E 5A                  <1>     pop     dx
   254 00000A6F 59                  <1>     pop     cx
   255 00000A70 5B                  <1>     pop     bx
   256 00000A71 C3                  <1>     ret
   257                              <1> 
   258 00000A72 00                  <1> .sector_count:  db 0
   259 00000A73 00                  <1> .sectors_done:  db 0
   260                              <1> 
   261                              <1> ;==============================================================================
   262                              <1> ; Function 03h: Write Sectors
   263                              <1> ;==============================================================================
   264                              <1> ; Writes sectors from memory to disk.
   265                              <1> ;
   266                              <1> ; Input:  AL = number of sectors to write
   267                              <1> ;         CH = cylinder low 8 bits
   268                              <1> ;         CL = sector (bits 0-5) + cylinder high (bits 6-7)
   269                              <1> ;         DH = head number
   270                              <1> ;         DL = drive number
   271                              <1> ;         ES:BX = buffer address
   272                              <1> ; Output: AH = status
   273                              <1> ;         AL = sectors written
   274                              <1> ;         CF = 0 if success, 1 if error
   275                              <1> ;==============================================================================
   276                              <1> int13h_write_sectors:
   277 00000A74 53                  <1>     push    bx
   278 00000A75 51                  <1>     push    cx
   279 00000A76 52                  <1>     push    dx
   280 00000A77 56                  <1>     push    si
   281 00000A78 57                  <1>     push    di
   282                              <1> 
   283                              <1>     ; Save sector count
   284 00000A79 A2[3B0B]            <1>     mov     [.sector_count], al
   285 00000A7C C606[3C0B]00        <1>     mov     byte [.sectors_done], 0
   286                              <1> 
   287                              <1>     ; Select drive and head
   288 00000A81 E8A0FE              <1>     call    select_drive
   289                              <1> 
   290                              <1>     ; Wait for drive ready
   291 00000A84 E8B5FE              <1>     call    wait_drive_ready
   292 00000A87 0F82A100            <1>     jc      .timeout
   293                              <1> 
   294                              <1>     ; Set up task file registers
   295 00000A8B A0[3B0B]            <1>     mov     al, [.sector_count]
   296 00000A8E 8B16[C931]          <1>     mov     dx, [current_base]
   297 00000A92 83C202              <1>     add     dx, WD_SECCNT
   298 00000A95 EE                  <1>     out     dx, al
   299                              <1> 
   300 00000A96 88C8                <1>     mov     al, cl
   301 00000A98 243F                <1>     and     al, 0x3F
   302 00000A9A 42                  <1>     inc     dx
   303 00000A9B EE                  <1>     out     dx, al
   304                              <1> 
   305 00000A9C 88E8                <1>     mov     al, ch
   306 00000A9E 42                  <1>     inc     dx
   307 00000A9F EE                  <1>     out     dx, al
   308                              <1> 
   309 00000AA0 88C8                <1>     mov     al, cl
   310 00000AA2 C0E806              <1>     shr     al, 6
   311 00000AA5 42                  <1>     inc     dx
   312 00000AA6 EE                  <1>     out     dx, al
   313                              <1> 
   314                              <1>     ; Issue WRITE command
   315 00000AA7 8B16[C931]          <1>     mov     dx, [current_base]
   316 00000AAB 83C207              <1>     add     dx, WD_COMMAND
   317 00000AAE B030                <1>     mov     al, CMD_WRITE
   318 00000AB0 EE                  <1>     out     dx, al
   319                              <1> 
   320                              <1>     ; Write sector data
   321 00000AB1 89DE                <1>     mov     si, bx                  ; DS:SI = buffer (need to set up DS)
   322 00000AB3 06                  <1>     push    es
   323 00000AB4 1F                  <1>     pop     ds                      ; DS = ES (buffer segment)
   324                              <1> 
   325                              <1> .write_sector_loop:
   326                              <1>     ; Wait for DRQ
   327 00000AB5 1E                  <1>     push    ds
   328 00000AB6 0E                  <1>     push    cs
   329 00000AB7 1F                  <1>     pop     ds
   330 00000AB8 8B16[C931]          <1>     mov     dx, [current_base]
   331 00000ABC 1F                  <1>     pop     ds
   332 00000ABD 83C207              <1>     add     dx, WD_STATUS
   333 00000AC0 B9FFFF              <1>     mov     cx, TIMEOUT_DRQ_SET
   334                              <1> 
   335                              <1> .wait_drq:
   336 00000AC3 EC                  <1>     in      al, dx
   337 00000AC4 A801                <1>     test    al, STS_ERR
   338 00000AC6 7549                <1>     jnz     .write_error
   339 00000AC8 A808                <1>     test    al, STS_DRQ
   340 00000ACA 7504                <1>     jnz     .drq_set
   341 00000ACC E2F5                <1>     loop    .wait_drq
   342 00000ACE EB5C                <1>     jmp     .timeout
   343                              <1> 
   344                              <1> .drq_set:
   345                              <1>     ; Write 256 words from buffer
   346 00000AD0 1E                  <1>     push    ds
   347 00000AD1 0E                  <1>     push    cs
   348 00000AD2 1F                  <1>     pop     ds
   349 00000AD3 8B16[C931]          <1>     mov     dx, [current_base]
   350 00000AD7 1F                  <1>     pop     ds
   351 00000AD8 83C200              <1>     add     dx, WD_DATA
   352 00000ADB B90001              <1>     mov     cx, 256
   353 00000ADE F36F                <1>     rep outsw                       ; Write words from DS:SI
   354                              <1> 
   355                              <1>     ; Wait for BSY to clear (sector written)
   356 00000AE0 1E                  <1>     push    ds
   357 00000AE1 0E                  <1>     push    cs
   358 00000AE2 1F                  <1>     pop     ds
   359 00000AE3 8B16[C931]          <1>     mov     dx, [current_base]
   360 00000AE7 1F                  <1>     pop     ds
   361 00000AE8 83C207              <1>     add     dx, WD_STATUS
   362 00000AEB B9FFFF              <1>     mov     cx, TIMEOUT_BSY_CLR
   363                              <1> 
   364                              <1> .wait_bsy:
   365 00000AEE EC                  <1>     in      al, dx
   366 00000AEF A880                <1>     test    al, STS_BSY
   367 00000AF1 7404                <1>     jz      .bsy_clear
   368 00000AF3 E2F9                <1>     loop    .wait_bsy
   369 00000AF5 EB35                <1>     jmp     .timeout
   370                              <1> 
   371                              <1> .bsy_clear:
   372                              <1>     ; Check for write fault
   373 00000AF7 A820                <1>     test    al, STS_DWF
   374 00000AF9 7528                <1>     jnz     .write_fault
   375                              <1> 
   376                              <1>     ; Increment sectors done
   377 00000AFB 0E                  <1>     push    cs
   378 00000AFC 1F                  <1>     pop     ds
   379 00000AFD FE06[3C0B]          <1>     inc     byte [.sectors_done]
   380                              <1> 
   381                              <1>     ; Check if more sectors
   382 00000B01 A0[3C0B]            <1>     mov     al, [.sectors_done]
   383 00000B04 3A06[3B0B]          <1>     cmp     al, [.sector_count]
   384 00000B08 72AB                <1>     jb      .write_sector_loop
   385                              <1> 
   386                              <1>     ; Success
   387 00000B0A A0[3C0B]            <1>     mov     al, [.sectors_done]
   388 00000B0D B400                <1>     mov     ah, ST_SUCCESS
   389 00000B0F EB22                <1>     jmp     .done
   390                              <1> 
   391                              <1> .write_error:
   392 00000B11 0E                  <1>     push    cs
   393 00000B12 1F                  <1>     pop     ds
   394 00000B13 8B16[C931]          <1>     mov     dx, [current_base]
   395 00000B17 83C201              <1>     add     dx, WD_ERROR
   396 00000B1A EC                  <1>     in      al, dx
   397 00000B1B E80D01              <1>     call    translate_error
   398 00000B1E A0[3C0B]            <1>     mov     al, [.sectors_done]
   399 00000B21 EB10                <1>     jmp     .done
   400                              <1> 
   401                              <1> .write_fault:
   402 00000B23 0E                  <1>     push    cs
   403 00000B24 1F                  <1>     pop     ds
   404 00000B25 B4CC                <1>     mov     ah, ST_WRITE_FAULT
   405 00000B27 A0[3C0B]            <1>     mov     al, [.sectors_done]
   406 00000B2A EB07                <1>     jmp     .done
   407                              <1> 
   408                              <1> .timeout:
   409 00000B2C 0E                  <1>     push    cs
   410 00000B2D 1F                  <1>     pop     ds
   411 00000B2E B480                <1>     mov     ah, ST_TIMEOUT
   412 00000B30 A0[3C0B]            <1>     mov     al, [.sectors_done]
   413                              <1> 
   414                              <1> .done:
   415 00000B33 0E                  <1>     push    cs
   416 00000B34 1F                  <1>     pop     ds                      ; Restore DS to ROM segment
   417 00000B35 5F                  <1>     pop     di
   418 00000B36 5E                  <1>     pop     si
   419 00000B37 5A                  <1>     pop     dx
   420 00000B38 59                  <1>     pop     cx
   421 00000B39 5B                  <1>     pop     bx
   422 00000B3A C3                  <1>     ret
   423                              <1> 
   424 00000B3B 00                  <1> .sector_count:  db 0
   425 00000B3C 00                  <1> .sectors_done:  db 0
   426                              <1> 
   427                              <1> ;==============================================================================
   428                              <1> ; Function 04h: Verify Sectors
   429                              <1> ;==============================================================================
   430                              <1> ; Verifies sectors on disk (reads and checks CRC, discards data).
   431                              <1> ;
   432                              <1> ; Input:  AL = number of sectors to verify
   433                              <1> ;         CH = cylinder low
   434                              <1> ;         CL = sector + cylinder high
   435                              <1> ;         DH = head
   436                              <1> ;         DL = drive
   437                              <1> ; Output: AH = status
   438                              <1> ;         AL = sectors verified
   439                              <1> ;         CF = 0 if success, 1 if error
   440                              <1> ;==============================================================================
   441                              <1> int13h_verify_sectors:
   442 00000B3D 53                  <1>     push    bx
   443 00000B3E 51                  <1>     push    cx
   444 00000B3F 52                  <1>     push    dx
   445                              <1> 
   446                              <1>     ; Save sector count
   447 00000B40 A2[A00B]            <1>     mov     [.sector_count], al
   448                              <1> 
   449                              <1>     ; Select drive
   450 00000B43 E8DEFD              <1>     call    select_drive
   451                              <1> 
   452                              <1>     ; Wait for ready
   453 00000B46 E8F3FD              <1>     call    wait_drive_ready
   454 00000B49 724D                <1>     jc      .timeout
   455                              <1> 
   456                              <1>     ; Set up task file
   457 00000B4B A0[A00B]            <1>     mov     al, [.sector_count]
   458 00000B4E 8B16[C931]          <1>     mov     dx, [current_base]
   459 00000B52 83C202              <1>     add     dx, WD_SECCNT
   460 00000B55 EE                  <1>     out     dx, al
   461                              <1> 
   462 00000B56 88C8                <1>     mov     al, cl
   463 00000B58 243F                <1>     and     al, 0x3F
   464 00000B5A 42                  <1>     inc     dx
   465 00000B5B EE                  <1>     out     dx, al
   466                              <1> 
   467 00000B5C 88E8                <1>     mov     al, ch
   468 00000B5E 42                  <1>     inc     dx
   469 00000B5F EE                  <1>     out     dx, al
   470                              <1> 
   471 00000B60 88C8                <1>     mov     al, cl
   472 00000B62 C0E806              <1>     shr     al, 6
   473 00000B65 42                  <1>     inc     dx
   474 00000B66 EE                  <1>     out     dx, al
   475                              <1> 
   476                              <1>     ; Issue VERIFY command
   477 00000B67 8B16[C931]          <1>     mov     dx, [current_base]
   478 00000B6B 83C207              <1>     add     dx, WD_COMMAND
   479 00000B6E B040                <1>     mov     al, CMD_VERIFY
   480 00000B70 EE                  <1>     out     dx, al
   481                              <1> 
   482                              <1>     ; Wait for completion
   483 00000B71 E8C8FD              <1>     call    wait_drive_ready
   484 00000B74 7222                <1>     jc      .timeout
   485                              <1> 
   486                              <1>     ; Check status
   487 00000B76 8B16[C931]          <1>     mov     dx, [current_base]
   488 00000B7A 83C207              <1>     add     dx, WD_STATUS
   489 00000B7D EC                  <1>     in      al, dx
   490 00000B7E A801                <1>     test    al, STS_ERR
   491 00000B80 7507                <1>     jnz     .error
   492                              <1> 
   493 00000B82 A0[A00B]            <1>     mov     al, [.sector_count]
   494 00000B85 B400                <1>     mov     ah, ST_SUCCESS
   495 00000B87 EB13                <1>     jmp     .done
   496                              <1> 
   497                              <1> .error:
   498 00000B89 8B16[C931]          <1>     mov     dx, [current_base]
   499 00000B8D 83C201              <1>     add     dx, WD_ERROR
   500 00000B90 EC                  <1>     in      al, dx
   501 00000B91 E89700              <1>     call    translate_error
   502 00000B94 30C0                <1>     xor     al, al
   503 00000B96 EB04                <1>     jmp     .done
   504                              <1> 
   505                              <1> .timeout:
   506 00000B98 B480                <1>     mov     ah, ST_TIMEOUT
   507 00000B9A 30C0                <1>     xor     al, al
   508                              <1> 
   509                              <1> .done:
   510 00000B9C 5A                  <1>     pop     dx
   511 00000B9D 59                  <1>     pop     cx
   512 00000B9E 5B                  <1>     pop     bx
   513 00000B9F C3                  <1>     ret
   514                              <1> 
   515 00000BA0 00                  <1> .sector_count:  db 0
   516                              <1> 
   517                              <1> ;==============================================================================
   518                              <1> ; Function 05h: Format Track
   519                              <1> ;==============================================================================
   520                              <1> ; Formats a track with specified interleave.
   521                              <1> ;
   522                              <1> ; Input:  AL = interleave factor (ignored, use 1:1)
   523                              <1> ;         CH = cylinder low
   524                              <1> ;         CL = cylinder high bits (6-7)
   525                              <1> ;         DH = head
   526                              <1> ;         DL = drive
   527                              <1> ;         ES:BX = address list (not used on WD controllers)
   528                              <1> ; Output: AH = status
   529                              <1> ;         CF = 0 if success, 1 if error
   530                              <1> ;==============================================================================
   531                              <1> int13h_format_track:
   532 00000BA1 53                  <1>     push    bx
   533 00000BA2 51                  <1>     push    cx
   534 00000BA3 52                  <1>     push    dx
   535                              <1> 
   536                              <1>     ; Select drive
   537 00000BA4 E87DFD              <1>     call    select_drive
   538                              <1> 
   539                              <1>     ; Wait for ready
   540 00000BA7 E892FD              <1>     call    wait_drive_ready
   541 00000BAA 724B                <1>     jc      .timeout
   542                              <1> 
   543                              <1>     ; Set up task file
   544                              <1>     ; Sector count = sectors per track from FDPT
   545 00000BAC 56                  <1>     push    si
   546 00000BAD E85AFD              <1>     call    get_fdpt_ptr
   547 00000BB0 8A440E              <1>     mov     al, [si + FDPT_SECTORS]
   548 00000BB3 5E                  <1>     pop     si
   549                              <1> 
   550 00000BB4 8B16[C931]          <1>     mov     dx, [current_base]
   551 00000BB8 83C202              <1>     add     dx, WD_SECCNT
   552 00000BBB EE                  <1>     out     dx, al
   553                              <1> 
   554                              <1>     ; Sector number = 1
   555 00000BBC B001                <1>     mov     al, 1
   556 00000BBE 42                  <1>     inc     dx
   557 00000BBF EE                  <1>     out     dx, al
   558                              <1> 
   559                              <1>     ; Cylinder
   560 00000BC0 88E8                <1>     mov     al, ch
   561 00000BC2 42                  <1>     inc     dx
   562 00000BC3 EE                  <1>     out     dx, al
   563                              <1> 
   564 00000BC4 88C8                <1>     mov     al, cl
   565 00000BC6 C0E806              <1>     shr     al, 6
   566 00000BC9 42                  <1>     inc     dx
   567 00000BCA EE                  <1>     out     dx, al
   568                              <1> 
   569                              <1>     ; Issue FORMAT command
   570 00000BCB 8B16[C931]          <1>     mov     dx, [current_base]
   571 00000BCF 83C207              <1>     add     dx, WD_COMMAND
   572 00000BD2 B050                <1>     mov     al, CMD_FORMAT
   573 00000BD4 EE                  <1>     out     dx, al
   574                              <1> 
   575                              <1>     ; Wait for completion
   576 00000BD5 E864FD              <1>     call    wait_drive_ready
   577 00000BD8 721D                <1>     jc      .timeout
   578                              <1> 
   579                              <1>     ; Check status
   580 00000BDA 8B16[C931]          <1>     mov     dx, [current_base]
   581 00000BDE 83C207              <1>     add     dx, WD_STATUS
   582 00000BE1 EC                  <1>     in      al, dx
   583 00000BE2 A801                <1>     test    al, STS_ERR
   584 00000BE4 7504                <1>     jnz     .error
   585                              <1> 
   586 00000BE6 B400                <1>     mov     ah, ST_SUCCESS
   587 00000BE8 EB0F                <1>     jmp     .done
   588                              <1> 
   589                              <1> .error:
   590 00000BEA 8B16[C931]          <1>     mov     dx, [current_base]
   591 00000BEE 83C201              <1>     add     dx, WD_ERROR
   592 00000BF1 EC                  <1>     in      al, dx
   593 00000BF2 E83600              <1>     call    translate_error
   594 00000BF5 EB02                <1>     jmp     .done
   595                              <1> 
   596                              <1> .timeout:
   597 00000BF7 B480                <1>     mov     ah, ST_TIMEOUT
   598                              <1> 
   599                              <1> .done:
   600 00000BF9 5A                  <1>     pop     dx
   601 00000BFA 59                  <1>     pop     cx
   602 00000BFB 5B                  <1>     pop     bx
   603 00000BFC C3                  <1>     ret
   604                              <1> 
   605                              <1> ;==============================================================================
   606                              <1> ; Function 08h: Get Drive Parameters
   607                              <1> ;==============================================================================
   608                              <1> ; Returns drive geometry information.
   609                              <1> ;
   610                              <1> ; Input:  DL = drive number
   611                              <1> ; Output: AH = status
   612                              <1> ;         BL = drive type (not used, returned as 0)
   613                              <1> ;         CH = max cylinder low 8 bits
   614                              <1> ;         CL = max sector (bits 0-5) + max cylinder high (bits 6-7)
   615                              <1> ;         DH = max head number
   616                              <1> ;         DL = number of drives
   617                              <1> ;         ES:DI = FDPT pointer
   618                              <1> ;         CF = 0 if success, 1 if error
   619                              <1> ;==============================================================================
   620                              <1> int13h_get_parameters:
   621 00000BFD 53                  <1>     push    bx
   622 00000BFE 56                  <1>     push    si
   623                              <1> 
   624                              <1>     ; Get FDPT pointer for this drive
   625 00000BFF E808FD              <1>     call    get_fdpt_ptr
   626 00000C02 7222                <1>     jc      .invalid_drive
   627                              <1> 
   628                              <1>     ; Read geometry from FDPT
   629 00000C04 8B04                <1>     mov     ax, [si + FDPT_MAX_CYL]
   630 00000C06 48                  <1>     dec     ax                      ; Max = count - 1
   631 00000C07 88C5                <1>     mov     ch, al                  ; Low 8 bits
   632 00000C09 C0E406              <1>     shl     ah, 6                   ; High 2 bits to bits 6-7
   633 00000C0C 8A440E              <1>     mov     al, [si + FDPT_SECTORS]
   634 00000C0F 08E0                <1>     or      al, ah                  ; Combine with max sector
   635 00000C11 88C1                <1>     mov     cl, al
   636                              <1> 
   637 00000C13 8A7402              <1>     mov     dh, [si + FDPT_MAX_HEAD]
   638 00000C16 FECE                <1>     dec     dh                      ; Max = count - 1
   639                              <1> 
   640                              <1>     ; Return number of drives
   641 00000C18 8A16[C831]          <1>     mov     dl, [num_drives]
   642                              <1> 
   643                              <1>     ; Return drive type (0 for HD)
   644 00000C1C 30DB                <1>     xor     bl, bl
   645                              <1> 
   646                              <1>     ; Return FDPT pointer in ES:DI
   647 00000C1E 0E                  <1>     push    cs
   648 00000C1F 07                  <1>     pop     es
   649 00000C20 89F7                <1>     mov     di, si
   650                              <1> 
   651 00000C22 B400                <1>     mov     ah, ST_SUCCESS
   652 00000C24 EB02                <1>     jmp     .done
   653                              <1> 
   654                              <1> .invalid_drive:
   655 00000C26 B401                <1>     mov     ah, ST_BAD_COMMAND
   656                              <1> 
   657                              <1> .done:
   658 00000C28 5E                  <1>     pop     si
   659 00000C29 5B                  <1>     pop     bx
   660 00000C2A C3                  <1>     ret
   661                              <1> 
   662                              <1> ;==============================================================================
   663                              <1> ; Helper: Translate WD Error to INT 13h Status
   664                              <1> ;==============================================================================
   665                              <1> ; Input:  AL = WD error register value
   666                              <1> ; Output: AH = INT 13h status code
   667                              <1> ;==============================================================================
   668                              <1> translate_error:
   669 00000C2B 53                  <1>     push    bx
   670                              <1> 
   671                              <1>     ; Default to undefined error
   672 00000C2C B4BB                <1>     mov     ah, ST_UNDEFINED
   673                              <1> 
   674 00000C2E A880                <1>     test    al, ERR_BBK
   675 00000C30 7516                <1>     jnz     .bad_sector
   676 00000C32 A840                <1>     test    al, ERR_UNC
   677 00000C34 7516                <1>     jnz     .crc_error
   678 00000C36 A810                <1>     test    al, ERR_IDNF
   679 00000C38 7516                <1>     jnz     .sector_not_found
   680 00000C3A A804                <1>     test    al, ERR_ABRT
   681 00000C3C 7516                <1>     jnz     .controller
   682 00000C3E A802                <1>     test    al, ERR_TK0NF
   683 00000C40 7516                <1>     jnz     .seek
   684 00000C42 A801                <1>     test    al, ERR_AMNF
   685 00000C44 7516                <1>     jnz     .addr_mark
   686 00000C46 EB16                <1>     jmp     .done
   687                              <1> 
   688                              <1> .bad_sector:
   689 00000C48 B40A                <1>     mov     ah, ST_BAD_SECTOR
   690 00000C4A EB12                <1>     jmp     .done
   691                              <1> 
   692                              <1> .crc_error:
   693 00000C4C B410                <1>     mov     ah, ST_CRC_ERROR
   694 00000C4E EB0E                <1>     jmp     .done
   695                              <1> 
   696                              <1> .sector_not_found:
   697 00000C50 B404                <1>     mov     ah, ST_SECTOR_NOT_FOUND
   698 00000C52 EB0A                <1>     jmp     .done
   699                              <1> 
   700                              <1> .controller:
   701 00000C54 B420                <1>     mov     ah, ST_CONTROLLER
   702 00000C56 EB06                <1>     jmp     .done
   703                              <1> 
   704                              <1> .seek:
   705 00000C58 B440                <1>     mov     ah, ST_SEEK_ERROR
   706 00000C5A EB02                <1>     jmp     .done
   707                              <1> 
   708                              <1> .addr_mark:
   709 00000C5C B402                <1>     mov     ah, ST_ADDR_MARK
   710                              <1> 
   711                              <1> .done:
   712 00000C5E 5B                  <1>     pop     bx
   713 00000C5F C3                  <1>     ret
   218                                  %include "wd_io.asm"
     1                              <1> ;==============================================================================
     2                              <1> ; FluxRipper HDD BIOS - WD Controller I/O Primitives
     3                              <1> ;==============================================================================
     4                              <1> ; Low-level routines for WD task file register access.
     5                              <1> ;
     6                              <1> ; SPDX-License-Identifier: BSD-3-Clause
     7                              <1> ; Copyright (c) 2025 FluxRipper Project
     8                              <1> ;==============================================================================
     9                              <1> 
    10                              <1> ;==============================================================================
    11                              <1> ; Write Command to WD Controller
    12                              <1> ;==============================================================================
    13                              <1> ; Waits for controller ready, then issues command.
    14                              <1> ;
    15                              <1> ; Input:  AL = command code
    16                              <1> ; Output: CF = 0 if command accepted, CF = 1 if timeout
    17                              <1> ; Destroys: AX, CX, DX
    18                              <1> ;==============================================================================
    19                              <1> wd_write_command:
    20 00000C60 50                  <1>     push    ax                      ; Save command
    21                              <1> 
    22                              <1>     ; Wait for BSY clear
    23 00000C61 E8D8FC              <1>     call    wait_drive_ready
    24 00000C64 720B                <1>     jc      .timeout
    25                              <1> 
    26                              <1>     ; Issue command
    27 00000C66 58                  <1>     pop     ax
    28 00000C67 8B16[C931]          <1>     mov     dx, [current_base]
    29 00000C6B 83C207              <1>     add     dx, WD_COMMAND
    30 00000C6E EE                  <1>     out     dx, al
    31                              <1> 
    32 00000C6F F8                  <1>     clc
    33 00000C70 C3                  <1>     ret
    34                              <1> 
    35                              <1> .timeout:
    36 00000C71 58                  <1>     pop     ax                      ; Clean up stack
    37 00000C72 F9                  <1>     stc
    38 00000C73 C3                  <1>     ret
    39                              <1> 
    40                              <1> ;==============================================================================
    41                              <1> ; Read Status Register
    42                              <1> ;==============================================================================
    43                              <1> ; Reads the status register without clearing interrupt.
    44                              <1> ;
    45                              <1> ; Output: AL = status register value
    46                              <1> ; Destroys: DX
    47                              <1> ;==============================================================================
    48                              <1> wd_read_status:
    49 00000C74 8B16[C931]          <1>     mov     dx, [current_base]
    50 00000C78 83C207              <1>     add     dx, WD_STATUS
    51 00000C7B EC                  <1>     in      al, dx
    52 00000C7C C3                  <1>     ret
    53                              <1> 
    54                              <1> ;==============================================================================
    55                              <1> ; Read Alternate Status Register
    56                              <1> ;==============================================================================
    57                              <1> ; Reads status without clearing pending interrupt.
    58                              <1> ;
    59                              <1> ; Output: AL = status register value
    60                              <1> ; Destroys: DX
    61                              <1> ;==============================================================================
    62                              <1> wd_read_alt_status:
    63 00000C7D 8B16[C931]          <1>     mov     dx, [current_base]
    64 00000C81 81C20602            <1>     add     dx, WD_ALT_STATUS - WD_BASE_PRIMARY + WD_BASE_ALTERNATE
    65 00000C85 EC                  <1>     in      al, dx
    66 00000C86 C3                  <1>     ret
    67                              <1> 
    68                              <1> ;==============================================================================
    69                              <1> ; Read Error Register
    70                              <1> ;==============================================================================
    71                              <1> ; Reads the error register (valid after STS_ERR is set).
    72                              <1> ;
    73                              <1> ; Output: AL = error register value
    74                              <1> ; Destroys: DX
    75                              <1> ;==============================================================================
    76                              <1> wd_read_error:
    77 00000C87 8B16[C931]          <1>     mov     dx, [current_base]
    78 00000C8B 83C201              <1>     add     dx, WD_ERROR
    79 00000C8E EC                  <1>     in      al, dx
    80 00000C8F C3                  <1>     ret
    81                              <1> 
    82                              <1> ;==============================================================================
    83                              <1> ; Set Up Task File
    84                              <1> ;==============================================================================
    85                              <1> ; Writes C/H/S address and sector count to task file.
    86                              <1> ;
    87                              <1> ; Input:  AL = sector count
    88                              <1> ;         BL = sector number (1-63)
    89                              <1> ;         CX = cylinder (0-65535)
    90                              <1> ;         DH = head (0-255)
    91                              <1> ;         DL = drive (80h or 81h)
    92                              <1> ; Output: None
    93                              <1> ; Destroys: AX, DX
    94                              <1> ;==============================================================================
    95                              <1> wd_setup_taskfile:
    96 00000C90 53                  <1>     push    bx
    97 00000C91 51                  <1>     push    cx
    98                              <1> 
    99                              <1>     ; Write sector count
   100 00000C92 8B16[C931]          <1>     mov     dx, [current_base]
   101 00000C96 83C202              <1>     add     dx, WD_SECCNT
   102 00000C99 EE                  <1>     out     dx, al
   103                              <1> 
   104                              <1>     ; Write sector number
   105 00000C9A 88D8                <1>     mov     al, bl
   106 00000C9C 42                  <1>     inc     dx                      ; WD_SECNUM
   107 00000C9D EE                  <1>     out     dx, al
   108                              <1> 
   109                              <1>     ; Write cylinder low
   110 00000C9E 88C8                <1>     mov     al, cl
   111 00000CA0 42                  <1>     inc     dx                      ; WD_CYL_LO
   112 00000CA1 EE                  <1>     out     dx, al
   113                              <1> 
   114                              <1>     ; Write cylinder high
   115 00000CA2 88E8                <1>     mov     al, ch
   116 00000CA4 42                  <1>     inc     dx                      ; WD_CYL_HI
   117 00000CA5 EE                  <1>     out     dx, al
   118                              <1> 
   119                              <1>     ; Write SDH (head and drive select)
   120 00000CA6 59                  <1>     pop     cx
   121 00000CA7 88F0                <1>     mov     al, dh                  ; Head
   122 00000CA9 240F                <1>     and     al, 0x0F
   123 00000CAB 0CA0                <1>     or      al, SDH_SIZE_512        ; 512-byte sectors
   124 00000CAD 80FA81              <1>     cmp     dl, 0x81                ; Drive 1?
   125 00000CB0 7502                <1>     jne     .drive0
   126 00000CB2 0C10                <1>     or      al, SDH_DRV1
   127                              <1> .drive0:
   128 00000CB4 42                  <1>     inc     dx                      ; WD_SDH
   129 00000CB5 EE                  <1>     out     dx, al
   130                              <1> 
   131 00000CB6 5B                  <1>     pop     bx
   132 00000CB7 C3                  <1>     ret
   133                              <1> 
   134                              <1> ;==============================================================================
   135                              <1> ; Read Sector Data
   136                              <1> ;==============================================================================
   137                              <1> ; Reads 512 bytes from data register to memory.
   138                              <1> ;
   139                              <1> ; Input:  ES:DI = destination buffer
   140                              <1> ; Output: ES:DI updated (DI += 512)
   141                              <1> ; Destroys: AX, CX, DX, DI
   142                              <1> ;==============================================================================
   143                              <1> wd_read_sector_data:
   144 00000CB8 8B16[C931]          <1>     mov     dx, [current_base]
   145 00000CBC 83C200              <1>     add     dx, WD_DATA
   146 00000CBF B90001              <1>     mov     cx, 256                 ; 256 words = 512 bytes
   147 00000CC2 F36D                <1>     rep insw
   148 00000CC4 C3                  <1>     ret
   149                              <1> 
   150                              <1> ;==============================================================================
   151                              <1> ; Write Sector Data
   152                              <1> ;==============================================================================
   153                              <1> ; Writes 512 bytes from memory to data register.
   154                              <1> ;
   155                              <1> ; Input:  DS:SI = source buffer
   156                              <1> ; Output: DS:SI updated (SI += 512)
   157                              <1> ; Destroys: AX, CX, DX, SI
   158                              <1> ;==============================================================================
   159                              <1> wd_write_sector_data:
   160 00000CC5 8B16[C931]          <1>     mov     dx, [current_base]
   161 00000CC9 83C200              <1>     add     dx, WD_DATA
   162 00000CCC B90001              <1>     mov     cx, 256                 ; 256 words = 512 bytes
   163 00000CCF F36F                <1>     rep outsw
   164 00000CD1 C3                  <1>     ret
   165                              <1> 
   166                              <1> ;==============================================================================
   167                              <1> ; Soft Reset Controller
   168                              <1> ;==============================================================================
   169                              <1> ; Issues a software reset to the controller.
   170                              <1> ;
   171                              <1> ; Output: CF = 0 if reset successful, CF = 1 if failed
   172                              <1> ; Destroys: AX, CX, DX
   173                              <1> ;==============================================================================
   174                              <1> wd_soft_reset:
   175                              <1>     ; Assert SRST
   176 00000CD2 8B16[C931]          <1>     mov     dx, [current_base]
   177 00000CD6 81C20602            <1>     add     dx, WD_DEV_CTRL - WD_BASE_PRIMARY + WD_BASE_ALTERNATE
   178 00000CDA B004                <1>     mov     al, CTRL_SRST
   179 00000CDC EE                  <1>     out     dx, al
   180                              <1> 
   181                              <1>     ; Wait 5us minimum
   182 00000CDD B90A00              <1>     mov     cx, 10
   183 00000CE0 E896F4              <1>     call    delay_us
   184                              <1> 
   185                              <1>     ; Clear SRST
   186 00000CE3 30C0                <1>     xor     al, al
   187 00000CE5 EE                  <1>     out     dx, al
   188                              <1> 
   189                              <1>     ; Wait for BSY to clear (up to 31 seconds per ATA spec, but we use shorter)
   190 00000CE6 8B16[C931]          <1>     mov     dx, [current_base]
   191 00000CEA 83C207              <1>     add     dx, WD_STATUS
   192 00000CED B9FFFF              <1>     mov     cx, 0xFFFF
   193                              <1> 
   194                              <1> .wait_bsy:
   195 00000CF0 EC                  <1>     in      al, dx
   196 00000CF1 A880                <1>     test    al, STS_BSY
   197 00000CF3 7404                <1>     jz      .bsy_clear
   198 00000CF5 E2F9                <1>     loop    .wait_bsy
   199                              <1> 
   200 00000CF7 F9                  <1>     stc                             ; Timeout
   201 00000CF8 C3                  <1>     ret
   202                              <1> 
   203                              <1> .bsy_clear:
   204 00000CF9 F8                  <1>     clc
   205 00000CFA C3                  <1>     ret
   206                              <1> 
   207                              <1> ;==============================================================================
   208                              <1> ; Wait for DRQ
   209                              <1> ;==============================================================================
   210                              <1> ; Waits for Data Request bit to be set.
   211                              <1> ;
   212                              <1> ; Output: CF = 0 if DRQ set, CF = 1 if timeout or error
   213                              <1> ;         AL = status register value
   214                              <1> ; Destroys: AX, CX, DX
   215                              <1> ;==============================================================================
   216                              <1> wd_wait_drq:
   217 00000CFB 8B16[C931]          <1>     mov     dx, [current_base]
   218 00000CFF 83C207              <1>     add     dx, WD_STATUS
   219 00000D02 B9FFFF              <1>     mov     cx, TIMEOUT_DRQ_SET
   220                              <1> 
   221                              <1> .loop:
   222 00000D05 EC                  <1>     in      al, dx
   223 00000D06 A801                <1>     test    al, STS_ERR             ; Error?
   224 00000D08 7508                <1>     jnz     .error
   225 00000D0A A808                <1>     test    al, STS_DRQ             ; DRQ set?
   226 00000D0C 7506                <1>     jnz     .done
   227 00000D0E E2F5                <1>     loop    .loop
   228                              <1> 
   229 00000D10 F9                  <1>     stc                             ; Timeout
   230 00000D11 C3                  <1>     ret
   231                              <1> 
   232                              <1> .error:
   233 00000D12 F9                  <1>     stc
   234 00000D13 C3                  <1>     ret
   235                              <1> 
   236                              <1> .done:
   237 00000D14 F8                  <1>     clc
   238 00000D15 C3                  <1>     ret
   239                              <1> 
   240                              <1> ;==============================================================================
   241                              <1> ; Wait for BSY Clear
   242                              <1> ;==============================================================================
   243                              <1> ; Waits for Busy bit to clear.
   244                              <1> ;
   245                              <1> ; Output: CF = 0 if BSY clear, CF = 1 if timeout
   246                              <1> ;         AL = status register value
   247                              <1> ; Destroys: AX, CX, DX
   248                              <1> ;==============================================================================
   249                              <1> wd_wait_not_busy:
   250 00000D16 8B16[C931]          <1>     mov     dx, [current_base]
   251 00000D1A 83C207              <1>     add     dx, WD_STATUS
   252 00000D1D B9FFFF              <1>     mov     cx, TIMEOUT_BSY_CLR
   253                              <1> 
   254                              <1> .loop:
   255 00000D20 EC                  <1>     in      al, dx
   256 00000D21 A880                <1>     test    al, STS_BSY
   257 00000D23 7404                <1>     jz      .done
   258 00000D25 E2F9                <1>     loop    .loop
   259                              <1> 
   260 00000D27 F9                  <1>     stc                             ; Timeout
   261 00000D28 C3                  <1>     ret
   262                              <1> 
   263                              <1> .done:
   264 00000D29 F8                  <1>     clc
   265 00000D2A C3                  <1>     ret
   266                              <1> 
   267                              <1> ;==============================================================================
   268                              <1> ; Disable Interrupts
   269                              <1> ;==============================================================================
   270                              <1> ; Disables interrupt generation from controller.
   271                              <1> ;
   272                              <1> ; Destroys: AL, DX
   273                              <1> ;==============================================================================
   274                              <1> wd_disable_irq:
   275 00000D2B 8B16[C931]          <1>     mov     dx, [current_base]
   276 00000D2F 81C20602            <1>     add     dx, WD_DEV_CTRL - WD_BASE_PRIMARY + WD_BASE_ALTERNATE
   277 00000D33 B002                <1>     mov     al, CTRL_NIEN
   278 00000D35 EE                  <1>     out     dx, al
   279 00000D36 C3                  <1>     ret
   280                              <1> 
   281                              <1> ;==============================================================================
   282                              <1> ; Enable Interrupts
   283                              <1> ;==============================================================================
   284                              <1> ; Enables interrupt generation from controller.
   285                              <1> ;
   286                              <1> ; Destroys: AL, DX
   287                              <1> ;==============================================================================
   288                              <1> wd_enable_irq:
   289 00000D37 8B16[C931]          <1>     mov     dx, [current_base]
   290 00000D3B 81C20602            <1>     add     dx, WD_DEV_CTRL - WD_BASE_PRIMARY + WD_BASE_ALTERNATE
   291 00000D3F 30C0                <1>     xor     al, al
   292 00000D41 EE                  <1>     out     dx, al
   293 00000D42 C3                  <1>     ret
   219                                  %include "geometry.asm"
     1                              <1> ;==============================================================================
     2                              <1> ; FluxRipper HDD BIOS - Geometry Translation
     3                              <1> ;==============================================================================
     4                              <1> ; C/H/S to LBA translation and parameter conversion routines.
     5                              <1> ;
     6                              <1> ; Translation Modes:
     7                              <1> ;   - None:   Physical = Logical (small drives)
     8                              <1> ;   - Normal: Standard INT 13h limits (1024 cyl / 16 heads / 63 sectors)
     9                              <1> ;   - Large:  ECHS mapping for drives > 504MB
    10                              <1> ;   - LBA:    Direct LBA addressing (bypasses C/H/S entirely)
    11                              <1> ;
    12                              <1> ; SPDX-License-Identifier: BSD-3-Clause
    13                              <1> ; Copyright (c) 2025 FluxRipper Project
    14                              <1> ;==============================================================================
    15                              <1> 
    16                              <1> ;==============================================================================
    17                              <1> ; Convert CHS to LBA
    18                              <1> ;==============================================================================
    19                              <1> ; Converts Cylinder/Head/Sector address to Linear Block Address.
    20                              <1> ;
    21                              <1> ; Formula: LBA = (C * H_max + H) * S_max + S - 1
    22                              <1> ;
    23                              <1> ; Input:  CX = cylinder (as packed in INT 13h format)
    24                              <1> ;         DH = head
    25                              <1> ;         DL = drive (to look up geometry)
    26                              <1> ;         (Also uses: CL bits 0-5 = sector)
    27                              <1> ; Output: DX:AX = 32-bit LBA
    28                              <1> ;         CF = 0 if success, CF = 1 if invalid parameters
    29                              <1> ; Destroys: BX, CX
    30                              <1> ;==============================================================================
    31                              <1> chs_to_lba:
    32 00000D43 56                  <1>     push    si
    33                              <1> 
    34                              <1>     ; Get drive geometry
    35 00000D44 52                  <1>     push    dx
    36 00000D45 E8A8FB              <1>     call    get_drive_params
    37 00000D48 5A                  <1>     pop     dx
    38 00000D49 7244                <1>     jc      .error
    39                              <1> 
    40                              <1>     ; Extract physical geometry
    41                              <1>     ; SI points to drive params: [cyl_lo, cyl_hi, heads, sectors, flags, ...]
    42                              <1> 
    43                              <1>     ; Extract cylinder from CX
    44                              <1>     ; CH = low 8 bits, CL bits 6-7 = high 2 bits
    45 00000D4B 89CB                <1>     mov     bx, cx
    46 00000D4D 88F8                <1>     mov     al, bh                  ; AL = low 8 bits (CH)
    47 00000D4F 88DC                <1>     mov     ah, bl                  ; AH = CL
    48 00000D51 C0EC06              <1>     shr     ah, 6                   ; AH = high 2 bits
    49                              <1>     ; AX now has cylinder number
    50                              <1> 
    51 00000D54 50                  <1>     push    ax                      ; Save cylinder
    52                              <1> 
    53                              <1>     ; Heads per cylinder
    54 00000D55 30FF                <1>     xor     bh, bh
    55 00000D57 8A5C02              <1>     mov     bl, [si + 2]            ; BX = heads per cylinder
    56                              <1> 
    57                              <1>     ; Cylinder * heads
    58 00000D5A F7E3                <1>     mul     bx                      ; DX:AX = cylinder * heads
    59                              <1> 
    60                              <1>     ; Add head number
    61 00000D5C 30FF                <1>     xor     bh, bh
    62 00000D5E 88F3                <1>     mov     bl, dh                  ; BX = head
    63 00000D60 01D8                <1>     add     ax, bx
    64 00000D62 83D200              <1>     adc     dx, 0                   ; DX:AX = (C * H) + H
    65                              <1> 
    66                              <1>     ; Sectors per track
    67 00000D65 30FF                <1>     xor     bh, bh
    68 00000D67 8A5C03              <1>     mov     bl, [si + 3]            ; BX = sectors per track
    69                              <1> 
    70                              <1>     ; (C*H + H) * sectors
    71 00000D6A 52                  <1>     push    dx                      ; Save high word
    72 00000D6B F7E3                <1>     mul     bx                      ; DX:AX = low * sectors
    73 00000D6D 89C1                <1>     mov     cx, ax                  ; Save low result
    74 00000D6F 58                  <1>     pop     ax                      ; Get saved high word
    75 00000D70 52                  <1>     push    dx                      ; Save new high word
    76 00000D71 F7E3                <1>     mul     bx                      ; DX:AX = high * sectors
    77 00000D73 5B                  <1>     pop     bx                      ; Get saved high
    78 00000D74 01D8                <1>     add     ax, bx                  ; Combine
    79 00000D76 89C2                <1>     mov     dx, ax                  ; DX = final high word
    80 00000D78 89C8                <1>     mov     ax, cx                  ; AX = final low word
    81                              <1> 
    82                              <1>     ; Add (sector - 1)
    83 00000D7A 59                  <1>     pop     cx                      ; Restore cylinder (not needed, but clean stack)
    84 00000D7B 50                  <1>     push    ax
    85 00000D7C 88C8                <1>     mov     al, cl
    86 00000D7E 243F                <1>     and     al, 0x3F                ; Extract sector number (1-63)
    87 00000D80 FEC8                <1>     dec     al                      ; Sector - 1 (sectors are 1-based)
    88 00000D82 30E4                <1>     xor     ah, ah
    89 00000D84 89C3                <1>     mov     bx, ax                  ; BX = sector - 1
    90 00000D86 58                  <1>     pop     ax
    91 00000D87 01D8                <1>     add     ax, bx
    92 00000D89 83D200              <1>     adc     dx, 0                   ; DX:AX = final LBA
    93                              <1> 
    94 00000D8C F8                  <1>     clc
    95 00000D8D 5E                  <1>     pop     si
    96 00000D8E C3                  <1>     ret
    97                              <1> 
    98                              <1> .error:
    99 00000D8F F9                  <1>     stc
   100 00000D90 5E                  <1>     pop     si
   101 00000D91 C3                  <1>     ret
   102                              <1> 
   103                              <1> ;==============================================================================
   104                              <1> ; Convert LBA to CHS
   105                              <1> ;==============================================================================
   106                              <1> ; Converts Linear Block Address to Cylinder/Head/Sector.
   107                              <1> ;
   108                              <1> ; Formula:
   109                              <1> ;   Sector   = (LBA mod S_max) + 1
   110                              <1> ;   Head     = (LBA / S_max) mod H_max
   111                              <1> ;   Cylinder = LBA / (S_max * H_max)
   112                              <1> ;
   113                              <1> ; Input:  DX:AX = 32-bit LBA
   114                              <1> ;         BL = drive (80h or 81h)
   115                              <1> ; Output: CH = cylinder low 8 bits
   116                              <1> ;         CL = sector (bits 0-5) | cylinder high (bits 6-7)
   117                              <1> ;         DH = head
   118                              <1> ;         CF = 0 if success, CF = 1 if out of range
   119                              <1> ; Destroys: AX, BX, DX, SI
   120                              <1> ;==============================================================================
   121                              <1> lba_to_chs:
   122 00000D92 57                  <1>     push    di
   123                              <1> 
   124                              <1>     ; Save LBA
   125 00000D93 89D7                <1>     mov     di, dx                  ; DI = LBA high
   126 00000D95 50                  <1>     push    ax                      ; Stack: LBA low
   127                              <1> 
   128                              <1>     ; Get drive geometry
   129 00000D96 53                  <1>     push    bx
   130 00000D97 88DA                <1>     mov     dl, bl
   131 00000D99 E854FB              <1>     call    get_drive_params
   132 00000D9C 5B                  <1>     pop     bx
   133 00000D9D 7237                <1>     jc      .error
   134                              <1> 
   135                              <1>     ; Get sectors per track
   136 00000D9F 30ED                <1>     xor     ch, ch
   137 00000DA1 8A4C03              <1>     mov     cl, [si + 3]            ; CX = sectors per track
   138                              <1> 
   139                              <1>     ; LBA / sectors_per_track
   140 00000DA4 58                  <1>     pop     ax                      ; AX = LBA low
   141 00000DA5 89FA                <1>     mov     dx, di                  ; DX = LBA high
   142 00000DA7 F7F1                <1>     div     cx                      ; AX = quotient, DX = remainder
   143 00000DA9 FEC2                <1>     inc     dl                      ; Sector = remainder + 1 (1-based)
   144 00000DAB 8816[DA0D]          <1>     mov     [.sector], dl           ; Save sector
   145                              <1> 
   146                              <1>     ; Quotient / heads
   147 00000DAF 31D2                <1>     xor     dx, dx                  ; Clear for division
   148 00000DB1 30ED                <1>     xor     ch, ch
   149 00000DB3 8A4C02              <1>     mov     cl, [si + 2]            ; CX = heads
   150 00000DB6 F7F1                <1>     div     cx                      ; AX = cylinder, DX = head
   151                              <1> 
   152 00000DB8 8816[DB0D]          <1>     mov     [.head], dl             ; Save head
   153                              <1> 
   154                              <1>     ; Check cylinder limit
   155 00000DBC 3D0004              <1>     cmp     ax, 1024                ; INT 13h limit
   156 00000DBF 7312                <1>     jae     .overflow
   157                              <1> 
   158                              <1>     ; Pack result
   159 00000DC1 88C5                <1>     mov     ch, al                  ; CH = cylinder low 8 bits
   160 00000DC3 8A0E[DA0D]          <1>     mov     cl, [.sector]           ; CL = sector
   161 00000DC7 C0E406              <1>     shl     ah, 6                   ; Cylinder high bits to 6-7
   162 00000DCA 08E1                <1>     or      cl, ah                  ; CL = sector | (cyl_high << 6)
   163 00000DCC 8A36[DB0D]          <1>     mov     dh, [.head]             ; DH = head
   164                              <1> 
   165 00000DD0 F8                  <1>     clc
   166 00000DD1 5F                  <1>     pop     di
   167 00000DD2 C3                  <1>     ret
   168                              <1> 
   169                              <1> .overflow:
   170                              <1>     ; Cylinder too large for CHS
   171 00000DD3 F9                  <1>     stc
   172 00000DD4 5F                  <1>     pop     di
   173 00000DD5 C3                  <1>     ret
   174                              <1> 
   175                              <1> .error:
   176 00000DD6 58                  <1>     pop     ax                      ; Clean stack
   177 00000DD7 F9                  <1>     stc
   178 00000DD8 5F                  <1>     pop     di
   179 00000DD9 C3                  <1>     ret
   180                              <1> 
   181 00000DDA 00                  <1> .sector:    db 0
   182 00000DDB 00                  <1> .head:      db 0
   183                              <1> 
   184                              <1> ;==============================================================================
   185                              <1> ; Get Translated Geometry
   186                              <1> ;==============================================================================
   187                              <1> ; Returns logical geometry for a drive (may differ from physical).
   188                              <1> ;
   189                              <1> ; For drives with >1024 cylinders, applies ECHS translation:
   190                              <1> ;   - Double heads, halve cylinders until cylinders <= 1024
   191                              <1> ;
   192                              <1> ; Input:  DL = drive (80h or 81h)
   193                              <1> ; Output: AX = logical cylinders
   194                              <1> ;         BL = logical heads
   195                              <1> ;         BH = logical sectors per track
   196                              <1> ;         CF = 0 if success
   197                              <1> ; Destroys: CX, SI
   198                              <1> ;==============================================================================
   199                              <1> get_translated_geometry:
   200 00000DDC 52                  <1>     push    dx
   201                              <1> 
   202                              <1>     ; Get physical geometry
   203 00000DDD E810FB              <1>     call    get_drive_params
   204 00000DE0 7222                <1>     jc      .error
   205                              <1> 
   206                              <1>     ; Read physical values
   207 00000DE2 8B04                <1>     mov     ax, [si + 0]            ; Cylinders
   208 00000DE4 30ED                <1>     xor     ch, ch
   209 00000DE6 8A4C02              <1>     mov     cl, [si + 2]            ; Heads
   210 00000DE9 8A7C03              <1>     mov     bh, [si + 3]            ; Sectors
   211                              <1> 
   212                              <1>     ; Check if translation needed
   213 00000DEC 3D0004              <1>     cmp     ax, 1024
   214 00000DEF 760E                <1>     jbe     .no_translation
   215                              <1> 
   216                              <1>     ; Apply ECHS translation
   217                              <1>     ; Double heads, halve cylinders until cyl <= 1024
   218                              <1> .translate_loop:
   219 00000DF1 80F980              <1>     cmp     cl, 128                 ; Max heads we can report
   220 00000DF4 7309                <1>     jae     .no_translation         ; Can't translate further
   221 00000DF6 D0E1                <1>     shl     cl, 1                   ; Double heads
   222 00000DF8 D1E8                <1>     shr     ax, 1                   ; Halve cylinders
   223 00000DFA 3D0004              <1>     cmp     ax, 1024
   224 00000DFD 77F2                <1>     ja      .translate_loop
   225                              <1> 
   226                              <1> .no_translation:
   227 00000DFF 88CB                <1>     mov     bl, cl                  ; BL = heads
   228                              <1> 
   229 00000E01 F8                  <1>     clc
   230 00000E02 5A                  <1>     pop     dx
   231 00000E03 C3                  <1>     ret
   232                              <1> 
   233                              <1> .error:
   234 00000E04 F9                  <1>     stc
   235 00000E05 5A                  <1>     pop     dx
   236 00000E06 C3                  <1>     ret
   237                              <1> 
   238                              <1> ;==============================================================================
   239                              <1> ; Calculate Total Sectors
   240                              <1> ;==============================================================================
   241                              <1> ; Returns total sector count for a drive.
   242                              <1> ;
   243                              <1> ; Input:  DL = drive (80h or 81h)
   244                              <1> ; Output: DX:AX = 32-bit sector count
   245                              <1> ;         CF = 0 if success
   246                              <1> ; Destroys: BX, CX, SI
   247                              <1> ;==============================================================================
   248                              <1> calc_total_sectors:
   249                              <1>     ; Get drive parameters
   250 00000E07 E8E6FA              <1>     call    get_drive_params
   251 00000E0A 7220                <1>     jc      .error
   252                              <1> 
   253                              <1>     ; Total = Cylinders * Heads * Sectors
   254 00000E0C 8B04                <1>     mov     ax, [si + 0]            ; AX = cylinders
   255 00000E0E 30FF                <1>     xor     bh, bh
   256 00000E10 8A5C02              <1>     mov     bl, [si + 2]            ; BX = heads
   257 00000E13 F7E3                <1>     mul     bx                      ; DX:AX = cyl * heads
   258                              <1> 
   259 00000E15 30FF                <1>     xor     bh, bh
   260 00000E17 8A5C03              <1>     mov     bl, [si + 3]            ; BX = sectors
   261                              <1>     ; Multiply 32-bit result by sectors
   262 00000E1A 52                  <1>     push    dx                      ; Save high word
   263 00000E1B F7E3                <1>     mul     bx                      ; DX:AX = low * sectors
   264 00000E1D 89C1                <1>     mov     cx, ax                  ; Save low result
   265 00000E1F 58                  <1>     pop     ax                      ; Get saved high word
   266 00000E20 52                  <1>     push    dx                      ; Save new high word
   267 00000E21 F7E3                <1>     mul     bx                      ; DX:AX = high * sectors
   268 00000E23 5B                  <1>     pop     bx                      ; Get saved high
   269 00000E24 01D8                <1>     add     ax, bx                  ; Combine
   270 00000E26 89C2                <1>     mov     dx, ax                  ; DX = final high word
   271 00000E28 89C8                <1>     mov     ax, cx                  ; AX = final low word
   272                              <1> 
   273 00000E2A F8                  <1>     clc
   274 00000E2B C3                  <1>     ret
   275                              <1> 
   276                              <1> .error:
   277 00000E2C 31C0                <1>     xor     ax, ax
   278 00000E2E 31D2                <1>     xor     dx, dx
   279 00000E30 F9                  <1>     stc
   280 00000E31 C3                  <1>     ret
   281                              <1> 
   282                              <1> ;==============================================================================
   283                              <1> ; Validate CHS Parameters
   284                              <1> ;==============================================================================
   285                              <1> ; Checks if C/H/S values are within drive limits.
   286                              <1> ;
   287                              <1> ; Input:  CX = packed cylinder/sector
   288                              <1> ;         DH = head
   289                              <1> ;         DL = drive
   290                              <1> ; Output: CF = 0 if valid, CF = 1 if invalid
   291                              <1> ; Destroys: AX, BX, SI
   292                              <1> ;==============================================================================
   293                              <1> validate_chs:
   294 00000E32 52                  <1>     push    dx
   295                              <1> 
   296                              <1>     ; Get drive parameters
   297 00000E33 E8BAFA              <1>     call    get_drive_params
   298 00000E36 7220                <1>     jc      .invalid
   299                              <1> 
   300                              <1>     ; Extract and check cylinder
   301 00000E38 88E8                <1>     mov     al, ch                  ; Low 8 bits
   302 00000E3A 88CC                <1>     mov     ah, cl
   303 00000E3C C0EC06              <1>     shr     ah, 6                   ; High 2 bits
   304 00000E3F 3B04                <1>     cmp     ax, [si + 0]            ; Compare with max
   305 00000E41 7315                <1>     jae     .invalid
   306                              <1> 
   307                              <1>     ; Check head
   308 00000E43 3A7402              <1>     cmp     dh, [si + 2]
   309 00000E46 7310                <1>     jae     .invalid
   310                              <1> 
   311                              <1>     ; Check sector (1-based)
   312 00000E48 88C8                <1>     mov     al, cl
   313 00000E4A 243F                <1>     and     al, 0x3F
   314 00000E4C 84C0                <1>     test    al, al                  ; Sector 0 invalid
   315 00000E4E 7408                <1>     jz      .invalid
   316 00000E50 3A4403              <1>     cmp     al, [si + 3]
   317 00000E53 7703                <1>     ja      .invalid
   318                              <1> 
   319 00000E55 F8                  <1>     clc
   320 00000E56 5A                  <1>     pop     dx
   321 00000E57 C3                  <1>     ret
   322                              <1> 
   323                              <1> .invalid:
   324 00000E58 F9                  <1>     stc
   325 00000E59 5A                  <1>     pop     dx
   326 00000E5A C3                  <1>     ret
   220                                  %include "boot.asm"
     1                              <1> ;==============================================================================
     2                              <1> ; FluxRipper HDD BIOS - Boot Sector Loading
     3                              <1> ;==============================================================================
     4                              <1> ; Handles loading and executing the MBR boot sector.
     5                              <1> ;
     6                              <1> ; Boot Process:
     7                              <1> ;   1. Read sector 0 (MBR) from first hard disk
     8                              <1> ;   2. Verify boot signature (55 AA)
     9                              <1> ;   3. Jump to loaded code at 0000:7C00
    10                              <1> ;
    11                              <1> ; SPDX-License-Identifier: BSD-3-Clause
    12                              <1> ; Copyright (c) 2025 FluxRipper Project
    13                              <1> ;==============================================================================
    14                              <1> 
    15                              <1> ;==============================================================================
    16                              <1> ; Boot Signature Constants
    17                              <1> ;==============================================================================
    18                              <1> %define BOOT_SEG        0x0000      ; Boot sector loads at 0000:7C00
    19                              <1> %define BOOT_OFF        0x7C00      ; Offset within segment
    20                              <1> %define BOOT_SIG_OFF    0x1FE       ; Signature offset in sector
    21                              <1> %define BOOT_SIG_LO     0x55        ; Signature low byte
    22                              <1> %define BOOT_SIG_HI     0xAA        ; Signature high byte
    23                              <1> 
    24                              <1> ;==============================================================================
    25                              <1> ; Load Boot Sector
    26                              <1> ;==============================================================================
    27                              <1> ; Attempts to load and verify the MBR from the first hard disk.
    28                              <1> ;
    29                              <1> ; Input:  DL = drive number to boot from
    30                              <1> ; Output: CF = 0 if boot sector loaded and valid
    31                              <1> ;         CF = 1 if failed (no valid boot sector)
    32                              <1> ;         ES:BX = 0000:7C00 (boot sector location)
    33                              <1> ; Destroys: AX, BX, CX, DX, ES
    34                              <1> ;==============================================================================
    35                              <1> load_boot_sector:
    36 00000E5B 56                  <1>     push    si
    37 00000E5C 57                  <1>     push    di
    38                              <1> 
    39                              <1>     ; Set up destination at 0000:7C00
    40 00000E5D 31C0                <1>     xor     ax, ax
    41 00000E5F 8EC0                <1>     mov     es, ax
    42 00000E61 BB007C              <1>     mov     bx, BOOT_OFF
    43                              <1> 
    44                              <1>     ; Set up INT 13h parameters for reading sector 0
    45                              <1>     ; AL = 1 sector
    46                              <1>     ; CH = cylinder 0
    47                              <1>     ; CL = sector 1 (sectors are 1-based)
    48                              <1>     ; DH = head 0
    49                              <1>     ; DL = drive number (passed in)
    50 00000E64 B80102              <1>     mov     ax, 0x0201              ; AH=02 (read), AL=01 (1 sector)
    51 00000E67 B90100              <1>     mov     cx, 0x0001              ; CH=0 (cyl), CL=1 (sector)
    52 00000E6A 30F6                <1>     xor     dh, dh                  ; Head 0
    53                              <1> 
    54                              <1>     ; Read the sector
    55 00000E6C CD13                <1>     int     0x13
    56 00000E6E 7213                <1>     jc      .read_failed
    57                              <1> 
    58                              <1>     ; Verify boot signature
    59 00000E70 BFFE7D              <1>     mov     di, BOOT_OFF + BOOT_SIG_OFF
    60 00000E73 26803D55            <1>     cmp     byte [es:di], BOOT_SIG_LO
    61 00000E77 750D                <1>     jne     .bad_signature
    62 00000E79 26807D01AA          <1>     cmp     byte [es:di + 1], BOOT_SIG_HI
    63 00000E7E 7506                <1>     jne     .bad_signature
    64                              <1> 
    65                              <1>     ; Success - boot sector loaded
    66 00000E80 F8                  <1>     clc
    67 00000E81 EB04                <1>     jmp     .done
    68                              <1> 
    69                              <1> .read_failed:
    70                              <1>     ; Read error - AH contains error code
    71 00000E83 F9                  <1>     stc
    72 00000E84 EB01                <1>     jmp     .done
    73                              <1> 
    74                              <1> .bad_signature:
    75                              <1>     ; Invalid boot signature
    76 00000E86 F9                  <1>     stc
    77                              <1> 
    78                              <1> .done:
    79 00000E87 5F                  <1>     pop     di
    80 00000E88 5E                  <1>     pop     si
    81 00000E89 C3                  <1>     ret
    82                              <1> 
    83                              <1> ;==============================================================================
    84                              <1> ; Execute Boot Sector
    85                              <1> ;==============================================================================
    86                              <1> ; Transfers control to the loaded boot sector.
    87                              <1> ; This function does not return on success.
    88                              <1> ;
    89                              <1> ; Input:  DL = drive number (passed to boot code)
    90                              <1> ; Note:   Boot sector must be loaded at 0000:7C00
    91                              <1> ; Destroys: Everything (never returns)
    92                              <1> ;==============================================================================
    93                              <1> execute_boot_sector:
    94                              <1>     ; Set up segment registers for boot code
    95 00000E8A 31C0                <1>     xor     ax, ax
    96 00000E8C 8ED8                <1>     mov     ds, ax
    97 00000E8E 8EC0                <1>     mov     es, ax
    98 00000E90 8ED0                <1>     mov     ss, ax
    99 00000E92 BC007C              <1>     mov     sp, BOOT_OFF            ; Stack just below boot code
   100                              <1> 
   101                              <1>     ; DL already contains drive number
   102                              <1> 
   103                              <1>     ; Far jump to boot sector
   104 00000E95 EA007C0000          <1>     jmp     BOOT_SEG:BOOT_OFF
   105                              <1> 
   106                              <1> ;==============================================================================
   107                              <1> ; Find Bootable Partition
   108                              <1> ;==============================================================================
   109                              <1> ; Scans the MBR partition table for a bootable (active) partition.
   110                              <1> ;
   111                              <1> ; Input:  ES:BX = MBR location (0000:7C00)
   112                              <1> ; Output: CF = 0 if found, SI = pointer to partition entry
   113                              <1> ;         CF = 1 if no bootable partition
   114                              <1> ; Destroys: AX, CX, SI
   115                              <1> ;==============================================================================
   116                              <1> find_bootable_partition:
   117                              <1>     ; Partition table starts at offset 1BEh in MBR
   118 00000E9A BEBE7D              <1>     mov     si, BOOT_OFF + 0x1BE
   119 00000E9D B90400              <1>     mov     cx, 4                   ; 4 partition entries
   120                              <1> 
   121                              <1> .check_entry:
   122                              <1>     ; Check boot indicator (first byte of entry)
   123 00000EA0 268A04              <1>     mov     al, [es:si]
   124 00000EA3 A880                <1>     test    al, 0x80                ; Boot flag set?
   125 00000EA5 7507                <1>     jnz     .found
   126                              <1> 
   127                              <1>     ; Next entry (16 bytes each)
   128 00000EA7 83C610              <1>     add     si, 16
   129 00000EAA E2F4                <1>     loop    .check_entry
   130                              <1> 
   131                              <1>     ; No bootable partition found
   132 00000EAC F9                  <1>     stc
   133 00000EAD C3                  <1>     ret
   134                              <1> 
   135                              <1> .found:
   136 00000EAE F8                  <1>     clc
   137 00000EAF C3                  <1>     ret
   138                              <1> 
   139                              <1> ;==============================================================================
   140                              <1> ; Get Partition CHS
   141                              <1> ;==============================================================================
   142                              <1> ; Extracts starting CHS from partition table entry.
   143                              <1> ;
   144                              <1> ; Input:  ES:SI = partition table entry
   145                              <1> ; Output: CH = cylinder low
   146                              <1> ;         CL = sector | (cylinder high << 6)
   147                              <1> ;         DH = head
   148                              <1> ; Destroys: AX
   149                              <1> ;==============================================================================
   150                              <1> get_partition_chs:
   151                              <1>     ; Partition entry format:
   152                              <1>     ;   +0: Boot indicator
   153                              <1>     ;   +1: Starting head
   154                              <1>     ;   +2: Starting sector/cylinder
   155                              <1>     ;   +3: Starting cylinder high
   156                              <1>     ;   +4: System ID
   157                              <1>     ;   +5: Ending head
   158                              <1>     ;   +6: Ending sector/cylinder
   159                              <1>     ;   +7: Ending cylinder high
   160                              <1>     ;   +8: Starting LBA (4 bytes)
   161                              <1>     ;   +12: Sector count (4 bytes)
   162                              <1> 
   163 00000EB0 268A7401            <1>     mov     dh, [es:si + 1]         ; Starting head
   164 00000EB4 268A4C02            <1>     mov     cl, [es:si + 2]         ; Sector and cyl high bits
   165 00000EB8 268A6C03            <1>     mov     ch, [es:si + 3]         ; Cylinder low
   166 00000EBC C3                  <1>     ret
   167                              <1> 
   168                              <1> ;==============================================================================
   169                              <1> ; Get Partition LBA
   170                              <1> ;==============================================================================
   171                              <1> ; Extracts starting LBA from partition table entry.
   172                              <1> ;
   173                              <1> ; Input:  ES:SI = partition table entry
   174                              <1> ; Output: DX:AX = 32-bit starting LBA
   175                              <1> ; Destroys: Nothing else
   176                              <1> ;==============================================================================
   177                              <1> get_partition_lba:
   178 00000EBD 268B4408            <1>     mov     ax, [es:si + 8]         ; Low word
   179 00000EC1 268B540A            <1>     mov     dx, [es:si + 10]        ; High word
   180 00000EC5 C3                  <1>     ret
   181                              <1> 
   182                              <1> ;==============================================================================
   183                              <1> ; Boot with Retry
   184                              <1> ;==============================================================================
   185                              <1> ; Attempts to boot, with retry on failure.
   186                              <1> ;
   187                              <1> ; Input:  DL = drive number
   188                              <1> ; Output: Does not return on success
   189                              <1> ;         CF = 1 if all retries failed
   190                              <1> ; Destroys: AX, BX, CX, DX, ES
   191                              <1> ;==============================================================================
   192                              <1> boot_with_retry:
   193 00000EC6 B90300              <1>     mov     cx, 3                   ; 3 attempts
   194                              <1> 
   195                              <1> .try_boot:
   196 00000EC9 51                  <1>     push    cx
   197 00000ECA 52                  <1>     push    dx
   198                              <1> 
   199                              <1>     ; Reset disk system
   200 00000ECB 31C0                <1>     xor     ax, ax
   201 00000ECD CD13                <1>     int     0x13
   202                              <1> 
   203 00000ECF 5A                  <1>     pop     dx
   204 00000ED0 52                  <1>     push    dx
   205                              <1> 
   206                              <1>     ; Try to load boot sector
   207 00000ED1 E887FF              <1>     call    load_boot_sector
   208 00000ED4 7213                <1>     jc      .retry
   209                              <1> 
   210                              <1>     ; Verify signature
   211 00000ED6 31C0                <1>     xor     ax, ax
   212 00000ED8 8EC0                <1>     mov     es, ax
   213 00000EDA BFFE7D              <1>     mov     di, BOOT_OFF + BOOT_SIG_OFF
   214 00000EDD 26813D55AA          <1>     cmp     word [es:di], 0xAA55
   215 00000EE2 7505                <1>     jne     .retry
   216                              <1> 
   217                              <1>     ; Success - boot
   218 00000EE4 5A                  <1>     pop     dx
   219 00000EE5 59                  <1>     pop     cx
   220 00000EE6 E8A1FF              <1>     call    execute_boot_sector     ; Does not return
   221                              <1> 
   222                              <1> .retry:
   223 00000EE9 5A                  <1>     pop     dx
   224 00000EEA 59                  <1>     pop     cx
   225 00000EEB E2DC                <1>     loop    .try_boot
   226                              <1> 
   227                              <1>     ; All attempts failed
   228 00000EED F9                  <1>     stc
   229 00000EEE C3                  <1>     ret
   221                                  %include "strings.asm"
     1                              <1> ;==============================================================================
     2                              <1> ; FluxRipper HDD BIOS - String Constants and Messages
     3                              <1> ;==============================================================================
     4                              <1> ; All user-visible strings for the BIOS.
     5                              <1> ;
     6                              <1> ; SPDX-License-Identifier: BSD-3-Clause
     7                              <1> ; Copyright (c) 2025 FluxRipper Project
     8                              <1> ;==============================================================================
     9                              <1> 
    10                              <1> ;==============================================================================
    11                              <1> ; Initialization Messages
    12                              <1> ;==============================================================================
    13                              <1> 
    14                              <1> msg_banner:
    15 00000EEF 0D0A                <1>     db      0x0D, 0x0A
    16 00000EF1 466C75785269707065- <1>     db      "FluxRipper HDD BIOS v1.0", 0x0D, 0x0A
    16 00000EFA 72204844442042494F- <1>
    16 00000F03 532076312E300D0A    <1>
    17                              <1> %if BUILD_16KB
    18 00000F0B 53542D3530362F4553- <1>     db      "ST-506/ESDI Controller (16KB)", 0x0D, 0x0A
    18 00000F14 444920436F6E74726F- <1>
    18 00000F1D 6C6C6572202831364B- <1>
    18 00000F26 42290D0A            <1>
    19                              <1> %else
    20                              <1>     db      "ST-506 Controller (8KB)", 0x0D, 0x0A
    21                              <1> %endif
    22 00000F2A 286329203230323520- <1>     db      "(c) 2025 FluxRipper Project", 0x0D, 0x0A
    22 00000F33 466C75785269707065- <1>
    22 00000F3C 722050726F6A656374- <1>
    22 00000F45 0D0A                <1>
    23 00000F47 00                  <1>     db      0
    24                              <1> 
    25                              <1> msg_ready:
    26 00000F48 52656164792E0D0A00  <1>     db      "Ready.", 0x0D, 0x0A, 0
    27                              <1> 
    28                              <1> msg_error:
    29 00000F51 496E6974206661696C- <1>     db      "Init failed!", 0x0D, 0x0A, 0
    29 00000F5A 6564210D0A00        <1>
    30                              <1> 
    31                              <1> msg_drives_found:
    32 00000F60 4472697665733A2000  <1>     db      "Drives: ", 0
    33                              <1> 
    34                              <1> msg_drives_suffix:
    35 00000F69 206465746563746564- <1>     db      " detected", 0
    35 00000F72 00                  <1>
    36                              <1> 
    37                              <1> msg_drive0:
    38 00000F73 20204844303A2000    <1>     db      "  HD0: ", 0
    39                              <1> 
    40                              <1> msg_drive1:
    41 00000F7B 20204844313A2000    <1>     db      "  HD1: ", 0
    42                              <1> 
    43                              <1> ;==============================================================================
    44                              <1> ; Interface Type Strings
    45                              <1> ;==============================================================================
    46                              <1> 
    47                              <1> msg_mfm:
    48 00000F83 204D464D00          <1>     db      " MFM", 0
    49                              <1> 
    50                              <1> msg_rll:
    51 00000F88 20524C4C00          <1>     db      " RLL", 0
    52                              <1> 
    53                              <1> msg_esdi:
    54 00000F8D 204553444900        <1>     db      " ESDI", 0
    55                              <1> 
    56                              <1> ;==============================================================================
    57                              <1> ; Personality Strings
    58                              <1> ;==============================================================================
    59                              <1> 
    60                              <1> msg_wd1002:
    61 00000F93 574431303032202858- <1>     db      "WD1002 (XT MFM)", 0
    61 00000F9C 54204D464D2900      <1>
    62                              <1> 
    63                              <1> msg_wd1003:
    64 00000FA3 574431303033202841- <1>     db      "WD1003 (AT MFM)", 0
    64 00000FAC 54204D464D2900      <1>
    65                              <1> 
    66                              <1> msg_wd1006:
    67 00000FB3 574431303036202841- <1>     db      "WD1006 (AT RLL)", 0
    67 00000FBC 5420524C4C2900      <1>
    68                              <1> 
    69                              <1> msg_wd1007:
    70 00000FC3 574431303037202841- <1>     db      "WD1007 (AT ESDI)", 0
    70 00000FCC 5420455344492900    <1>
    71                              <1> 
    72                              <1> ;==============================================================================
    73                              <1> ; Error Messages
    74                              <1> ;==============================================================================
    75                              <1> 
    76                              <1> msg_err_timeout:
    77 00000FD4 54696D656F757400    <1>     db      "Timeout", 0
    78                              <1> 
    79                              <1> msg_err_not_ready:
    80 00000FDC 4472697665206E6F74- <1>     db      "Drive not ready", 0
    80 00000FE5 20726561647900      <1>
    81                              <1> 
    82                              <1> msg_err_seek:
    83 00000FEC 5365656B206572726F- <1>     db      "Seek error", 0
    83 00000FF5 7200                <1>
    84                              <1> 
    85                              <1> msg_err_read:
    86 00000FF7 52656164206572726F- <1>     db      "Read error", 0
    86 00001000 7200                <1>
    87                              <1> 
    88                              <1> msg_err_write:
    89 00001002 577269746520657272- <1>     db      "Write error", 0
    89 0000100B 6F7200              <1>
    90                              <1> 
    91                              <1> msg_err_crc:
    92 0000100E 435243206572726F72- <1>     db      "CRC error", 0
    92 00001017 00                  <1>
    93                              <1> 
    94                              <1> msg_err_controller:
    95 00001018 436F6E74726F6C6C65- <1>     db      "Controller error", 0
    95 00001021 72206572726F7200    <1>
    96                              <1> 
    97                              <1> msg_err_no_drive:
    98 00001029 4E6F20647269766500  <1>     db      "No drive", 0
    99                              <1> 
   100                              <1> ;==============================================================================
   101                              <1> ; Discovery Messages
   102                              <1> ;==============================================================================
   103                              <1> 
   104                              <1> msg_discovery_wait:
   105 00001032 57616974696E672066- <1>     db      "Waiting for drive discovery...", 0
   105 0000103B 6F7220647269766520- <1>
   105 00001044 646973636F76657279- <1>
   105 0000104D 2E2E2E00            <1>
   106                              <1> 
   107                              <1> msg_discovery_done:
   108 00001051 446973636F76657279- <1>     db      "Discovery complete", 0x0D, 0x0A, 0
   108 0000105A 20636F6D706C657465- <1>
   108 00001063 0D0A00              <1>
   109                              <1> 
   110                              <1> msg_discovery_fail:
   111 00001066 446973636F76657279- <1>     db      "Discovery failed", 0x0D, 0x0A, 0
   111 0000106F 206661696C65640D0A- <1>
   111 00001078 00                  <1>
   112                              <1> 
   113                              <1> ;==============================================================================
   114                              <1> ; Boot Messages
   115                              <1> ;==============================================================================
   116                              <1> 
   117                              <1> msg_booting:
   118 00001079 426F6F74696E672066- <1>     db      "Booting from HD", 0
   118 00001082 726F6D20484400      <1>
   119                              <1> 
   120                              <1> msg_boot_fail:
   121 00001089 426F6F74206661696C- <1>     db      "Boot failed", 0x0D, 0x0A, 0
   121 00001092 65640D0A00          <1>
   122                              <1> 
   123                              <1> msg_no_boot:
   124 00001097 4E6F20626F6F746162- <1>     db      "No bootable partition", 0x0D, 0x0A, 0
   124 000010A0 6C6520706172746974- <1>
   124 000010A9 696F6E0D0A00        <1>
   125                              <1> 
   126                              <1> msg_invalid_mbr:
   127 000010AF 496E76616C6964204D- <1>     db      "Invalid MBR signature", 0x0D, 0x0A, 0
   127 000010B8 4252207369676E6174- <1>
   127 000010C1 7572650D0A00        <1>
   128                              <1> 
   129                              <1> ;==============================================================================
   130                              <1> ; Diagnostic Messages (16KB only)
   131                              <1> ;==============================================================================
   132                              <1> 
   133                              <1> %if BUILD_16KB
   134                              <1> 
   135                              <1> msg_diag_menu:
   136 000010C7 0D0A                <1>     db      0x0D, 0x0A
   137 000010C9 3D3D3D20466C757852- <1>     db      "=== FluxRipper Diagnostics ===", 0x0D, 0x0A
   137 000010D2 697070657220446961- <1>
   137 000010DB 676E6F737469637320- <1>
   137 000010E4 3D3D3D0D0A          <1>
   138 000010E9 20312E205375726661- <1>     db      " 1. Surface Scan", 0x0D, 0x0A
   138 000010F2 6365205363616E0D0A  <1>
   139 000010FB 20322E205365656B20- <1>     db      " 2. Seek Test", 0x0D, 0x0A
   139 00001104 546573740D0A        <1>
   140 0000110A 20332E20466C757820- <1>     db      " 3. Flux Histogram", 0x0D, 0x0A
   140 00001113 486973746F6772616D- <1>
   140 0000111C 0D0A                <1>
   141 0000111E 20342E204572726F72- <1>     db      " 4. Error Log", 0x0D, 0x0A
   141 00001127 204C6F670D0A        <1>
   142 0000112D 20352E205370696E64- <1>     db      " 5. Spindle Test", 0x0D, 0x0A
   142 00001136 6C6520546573740D0A  <1>
   143 0000113F 20362E204553444920- <1>     db      " 6. ESDI Query", 0x0D, 0x0A
   143 00001148 51756572790D0A      <1>
   144 0000114F 20372E204578706F72- <1>     db      " 7. Export Report", 0x0D, 0x0A
   144 00001158 74205265706F72740D- <1>
   144 00001161 0A                  <1>
   145 00001162 20302E20457869740D- <1>     db      " 0. Exit", 0x0D, 0x0A
   145 0000116B 0A                  <1>
   146 0000116C 53656C6563743A2000  <1>     db      "Select: ", 0
   147                              <1> 
   148                              <1> msg_press_f3:
   149 00001175 507265737320463320- <1>     db      "Press F3 for diagnostics", 0x0D, 0x0A, 0
   149 0000117E 666F7220646961676E- <1>
   149 00001187 6F73746963730D0A00  <1>
   150                              <1> 
   151                              <1> msg_surface_scan:
   152 00001190 537572666163652053- <1>     db      "Surface Scan - ", 0
   152 00001199 63616E202D2000      <1>
   153                              <1> 
   154                              <1> msg_seek_test:
   155 000011A0 5365656B2054657374- <1>     db      "Seek Test - ", 0
   155 000011A9 202D2000            <1>
   156                              <1> 
   157                              <1> msg_flux_hist:
   158 000011AD 466C75782048697374- <1>     db      "Flux Histogram", 0x0D, 0x0A, 0
   158 000011B6 6F6772616D0D0A00    <1>
   159                              <1> 
   160                              <1> msg_error_log:
   161 000011BE 4572726F72204C6F67- <1>     db      "Error Log:", 0x0D, 0x0A, 0
   161 000011C7 3A0D0A00            <1>
   162                              <1> 
   163                              <1> msg_spindle:
   164 000011CB 5370696E646C652052- <1>     db      "Spindle RPM: ", 0
   164 000011D4 504D3A2000          <1>
   165                              <1> 
   166                              <1> msg_esdi_query:
   167 000011D9 455344492044726976- <1>     db      "ESDI Drive Query:", 0x0D, 0x0A, 0
   167 000011E2 652051756572793A0D- <1>
   167 000011EB 0A00                <1>
   168                              <1> 
   169                              <1> msg_cylinder:
   170 000011ED 43796C3A2000        <1>     db      "Cyl: ", 0
   171                              <1> 
   172                              <1> msg_head:
   173 000011F3 2048643A2000        <1>     db      " Hd: ", 0
   174                              <1> 
   175                              <1> msg_sector:
   176 000011F9 205365633A2000      <1>     db      " Sec: ", 0
   177                              <1> 
   178                              <1> msg_pass:
   179 00001200 20504153530D0A00    <1>     db      " PASS", 0x0D, 0x0A, 0
   180                              <1> 
   181                              <1> msg_fail:
   182 00001208 204641494C0D0A00    <1>     db      " FAIL", 0x0D, 0x0A, 0
   183                              <1> 
   184                              <1> msg_testing:
   185 00001210 54657374696E672E2E- <1>     db      "Testing...", 0
   185 00001219 2E00                <1>
   186                              <1> 
   187                              <1> msg_complete:
   188 0000121B 436F6D706C6574650D- <1>     db      "Complete", 0x0D, 0x0A, 0
   188 00001224 0A00                <1>
   189                              <1> 
   190                              <1> msg_rpm:
   191 00001226 2052504D00          <1>     db      " RPM", 0
   192                              <1> 
   193                              <1> msg_percent:
   194 0000122B 2500                <1>     db      "%", 0
   195                              <1> 
   196                              <1> %endif
   197                              <1> 
   198                              <1> ;==============================================================================
   199                              <1> ; Setup Utility Messages (16KB only)
   200                              <1> ;==============================================================================
   201                              <1> 
   202                              <1> %if BUILD_16KB
   203                              <1> 
   204                              <1> msg_setup_banner:
   205 0000122D 0D0A                <1>     db      0x0D, 0x0A
   206 0000122F 3D3D3D20466C757852- <1>     db      "=== FluxRipper Setup ===", 0x0D, 0x0A, 0
   206 00001238 697070657220536574- <1>
   206 00001241 7570203D3D3D0D0A00  <1>
   207                              <1> 
   208                              <1> msg_setup_drive:
   209 0000124A 447269766520436F6E- <1>     db      "Drive Configuration:", 0x0D, 0x0A, 0
   209 00001253 66696775726174696F- <1>
   209 0000125C 6E3A0D0A00          <1>
   210                              <1> 
   211                              <1> msg_setup_type:
   212 00001261 2020547970653A2000  <1>     db      "  Type: ", 0
   213                              <1> 
   214                              <1> msg_setup_cyls:
   215 0000126A 202043796C696E6465- <1>     db      "  Cylinders: ", 0
   215 00001273 72733A2000          <1>
   216                              <1> 
   217                              <1> msg_setup_heads:
   218 00001278 202048656164733A20- <1>     db      "  Heads: ", 0
   218 00001281 00                  <1>
   219                              <1> 
   220                              <1> msg_setup_spt:
   221 00001282 2020536563746F7273- <1>     db      "  Sectors/Track: ", 0
   221 0000128B 2F547261636B3A2000  <1>
   222                              <1> 
   223                              <1> msg_setup_capacity:
   224 00001294 202043617061636974- <1>     db      "  Capacity: ", 0
   224 0000129D 793A2000            <1>
   225                              <1> 
   226                              <1> msg_setup_mb:
   227 000012A1 204D4200            <1>     db      " MB", 0
   228                              <1> 
   229                              <1> msg_setup_save:
   230 000012A5 0D0A53617665206368- <1>     db      0x0D, 0x0A, "Save changes? (Y/N): ", 0
   230 000012AE 616E6765733F202859- <1>
   230 000012B7 2F4E293A2000        <1>
   231                              <1> 
   232                              <1> msg_setup_saved:
   233 000012BD 436F6E666967757261- <1>     db      "Configuration saved.", 0x0D, 0x0A, 0
   233 000012C6 74696F6E2073617665- <1>
   233 000012CF 642E0D0A00          <1>
   234                              <1> 
   235                              <1> msg_setup_cancelled:
   236 000012D4 43616E63656C6C6564- <1>     db      "Cancelled.", 0x0D, 0x0A, 0
   236 000012DD 2E0D0A00            <1>
   237                              <1> 
   238                              <1> %endif
   239                              <1> 
   240                              <1> ;==============================================================================
   241                              <1> ; Numeric Formatting
   242                              <1> ;==============================================================================
   243                              <1> 
   244                              <1> msg_slash:
   245 000012E1 2F00                <1>     db      "/", 0
   246                              <1> 
   247                              <1> msg_colon:
   248 000012E3 3A2000              <1>     db      ": ", 0
   249                              <1> 
   250                              <1> msg_space:
   251 000012E6 2000                <1>     db      " ", 0
   252                              <1> 
   253                              <1> msg_crlf:
   254 000012E8 0D0A00              <1>     db      0x0D, 0x0A, 0
   255                              <1> 
   256                              <1> ;==============================================================================
   257                              <1> ; Print Personality String
   258                              <1> ;==============================================================================
   259                              <1> ; Prints the name of the detected WD personality.
   260                              <1> ;
   261                              <1> ; Input:  AL = personality code (0-3)
   262                              <1> ; Destroys: SI
   263                              <1> ;==============================================================================
   264                              <1> print_personality:
   265 000012EB 50                  <1>     push    ax
   266                              <1> 
   267 000012EC 3C00                <1>     cmp     al, PERSONALITY_WD1002
   268 000012EE 7505                <1>     jne     .check_1003
   269 000012F0 BE[930F]            <1>     mov     si, msg_wd1002
   270 000012F3 EB15                <1>     jmp     .print
   271                              <1> 
   272                              <1> .check_1003:
   273 000012F5 3C01                <1>     cmp     al, PERSONALITY_WD1003
   274 000012F7 7505                <1>     jne     .check_1006
   275 000012F9 BE[A30F]            <1>     mov     si, msg_wd1003
   276 000012FC EB0C                <1>     jmp     .print
   277                              <1> 
   278                              <1> .check_1006:
   279 000012FE 3C02                <1>     cmp     al, PERSONALITY_WD1006
   280 00001300 7505                <1>     jne     .check_1007
   281 00001302 BE[B30F]            <1>     mov     si, msg_wd1006
   282 00001305 EB03                <1>     jmp     .print
   283                              <1> 
   284                              <1> .check_1007:
   285 00001307 BE[C30F]            <1>     mov     si, msg_wd1007
   286                              <1> 
   287                              <1> .print:
   288 0000130A E8B3ED              <1>     call    print_string
   289                              <1> 
   290 0000130D 58                  <1>     pop     ax
   291 0000130E C3                  <1>     ret
   292                              <1> 
   293                              <1> ;==============================================================================
   294                              <1> ; Print Error Message
   295                              <1> ;==============================================================================
   296                              <1> ; Prints error description based on INT 13h status code.
   297                              <1> ;
   298                              <1> ; Input:  AH = status code
   299                              <1> ; Destroys: SI
   300                              <1> ;==============================================================================
   301                              <1> print_error_msg:
   302 0000130F 50                  <1>     push    ax
   303                              <1> 
   304 00001310 80FC80              <1>     cmp     ah, ST_TIMEOUT
   305 00001313 7505                <1>     jne     .check_not_ready
   306 00001315 BE[D40F]            <1>     mov     si, msg_err_timeout
   307 00001318 EB2F                <1>     jmp     .print
   308                              <1> 
   309                              <1> .check_not_ready:
   310 0000131A 80FCAA              <1>     cmp     ah, ST_NOT_READY
   311 0000131D 7505                <1>     jne     .check_seek
   312 0000131F BE[DC0F]            <1>     mov     si, msg_err_not_ready
   313 00001322 EB25                <1>     jmp     .print
   314                              <1> 
   315                              <1> .check_seek:
   316 00001324 80FC40              <1>     cmp     ah, ST_SEEK_ERROR
   317 00001327 7505                <1>     jne     .check_crc
   318 00001329 BE[EC0F]            <1>     mov     si, msg_err_seek
   319 0000132C EB1B                <1>     jmp     .print
   320                              <1> 
   321                              <1> .check_crc:
   322 0000132E 80FC10              <1>     cmp     ah, ST_CRC_ERROR
   323 00001331 7505                <1>     jne     .check_controller
   324 00001333 BE[0E10]            <1>     mov     si, msg_err_crc
   325 00001336 EB11                <1>     jmp     .print
   326                              <1> 
   327                              <1> .check_controller:
   328 00001338 80FC20              <1>     cmp     ah, ST_CONTROLLER
   329 0000133B 7505                <1>     jne     .default
   330 0000133D BE[1810]            <1>     mov     si, msg_err_controller
   331 00001340 EB07                <1>     jmp     .print
   332                              <1> 
   333                              <1> .default:
   334                              <1>     ; Print hex code for unknown errors
   335 00001342 88E0                <1>     mov     al, ah
   336 00001344 E8A7ED              <1>     call    print_hex_byte
   337 00001347 EB03                <1>     jmp     .done
   338                              <1> 
   339                              <1> .print:
   340 00001349 E874ED              <1>     call    print_string
   341                              <1> 
   342                              <1> .done:
   343 0000134C 58                  <1>     pop     ax
   344 0000134D C3                  <1>     ret
   222                                  
   223                                  %if BUILD_16KB
   224                                  %include "func_extended.asm"
     1                              <1> ;==============================================================================
     2                              <1> ; FluxRipper HDD BIOS - Extended INT 13h Functions (09h-15h)
     3                              <1> ;==============================================================================
     4                              <1> ; Implements extended INT 13h functions for AT-class systems.
     5                              <1> ;
     6                              <1> ; Functions:
     7                              <1> ;   09h - Initialize drive parameters
     8                              <1> ;   0Ah - Read long (sector + ECC)
     9                              <1> ;   0Bh - Write long (sector + ECC)
    10                              <1> ;   0Ch - Seek to cylinder
    11                              <1> ;   0Dh - Alternate disk reset
    12                              <1> ;   10h - Test drive ready
    13                              <1> ;   11h - Recalibrate drive
    14                              <1> ;   14h - Controller internal diagnostic
    15                              <1> ;   15h - Get disk type
    16                              <1> ;
    17                              <1> ; SPDX-License-Identifier: BSD-3-Clause
    18                              <1> ; Copyright (c) 2025 FluxRipper Project
    19                              <1> ;==============================================================================
    20                              <1> 
    21                              <1> %if ENABLE_EXTENDED
    22                              <1> 
    23                              <1> ;==============================================================================
    24                              <1> ; Function 09h: Initialize Drive Parameters
    25                              <1> ;==============================================================================
    26                              <1> ; Sets up the drive with specified parameters from FDPT.
    27                              <1> ;
    28                              <1> ; Input:  DL = drive number
    29                              <1> ; Output: AH = status
    30                              <1> ;         CF = 0 if success
    31                              <1> ;==============================================================================
    32                              <1> int13h_init_drive:
    33 0000134E 53                  <1>     push    bx
    34 0000134F 51                  <1>     push    cx
    35 00001350 52                  <1>     push    dx
    36 00001351 56                  <1>     push    si
    37                              <1> 
    38                              <1>     ; Get FDPT for this drive
    39 00001352 E8B5F5              <1>     call    get_fdpt_ptr
    40 00001355 724D                <1>     jc      .invalid_drive
    41                              <1> 
    42                              <1>     ; Select drive
    43 00001357 E8CAF5              <1>     call    select_drive
    44                              <1> 
    45                              <1>     ; Wait for drive ready
    46 0000135A E8DFF5              <1>     call    wait_drive_ready
    47 0000135D 7249                <1>     jc      .timeout
    48                              <1> 
    49                              <1>     ; Set up INITIALIZE DRIVE PARAMETERS command
    50                              <1>     ; This tells the controller the drive geometry
    51                              <1> 
    52                              <1>     ; Sector count = sectors per track
    53 0000135F 8A440E              <1>     mov     al, [si + FDPT_SECTORS]
    54 00001362 8B16[C931]          <1>     mov     dx, [current_base]
    55 00001366 83C202              <1>     add     dx, WD_SECCNT
    56 00001369 EE                  <1>     out     dx, al
    57                              <1> 
    58                              <1>     ; SDH = max head number
    59 0000136A 8A4402              <1>     mov     al, [si + FDPT_MAX_HEAD]
    60 0000136D FEC8                <1>     dec     al                      ; Convert count to max (0-based)
    61 0000136F 240F                <1>     and     al, 0x0F
    62 00001371 0CA0                <1>     or      al, SDH_SIZE_512
    63                              <1>     ; Add drive select
    64 00001373 8A5E06              <1>     mov     bl, [bp + 6]            ; Get DL from stack
    65 00001376 80FB81              <1>     cmp     bl, 0x81
    66 00001379 7502                <1>     jne     .drive0_init
    67 0000137B 0C10                <1>     or      al, SDH_DRV1
    68                              <1> .drive0_init:
    69 0000137D 8B16[C931]          <1>     mov     dx, [current_base]
    70 00001381 83C206              <1>     add     dx, WD_SDH
    71 00001384 EE                  <1>     out     dx, al
    72                              <1> 
    73                              <1>     ; Issue INITIALIZE DRIVE PARAMETERS command
    74 00001385 8B16[C931]          <1>     mov     dx, [current_base]
    75 00001389 83C207              <1>     add     dx, WD_COMMAND
    76 0000138C B091                <1>     mov     al, CMD_INIT_PARAM
    77 0000138E EE                  <1>     out     dx, al
    78                              <1> 
    79                              <1>     ; Wait for completion
    80 0000138F E8AAF5              <1>     call    wait_drive_ready
    81 00001392 7214                <1>     jc      .timeout
    82                              <1> 
    83                              <1>     ; Check status
    84 00001394 8B16[C931]          <1>     mov     dx, [current_base]
    85 00001398 83C207              <1>     add     dx, WD_STATUS
    86 0000139B EC                  <1>     in      al, dx
    87 0000139C A801                <1>     test    al, STS_ERR
    88 0000139E 750C                <1>     jnz     .error
    89                              <1> 
    90 000013A0 B400                <1>     mov     ah, ST_SUCCESS
    91 000013A2 EB13                <1>     jmp     .done
    92                              <1> 
    93                              <1> .invalid_drive:
    94 000013A4 B401                <1>     mov     ah, ST_BAD_COMMAND
    95 000013A6 EB0F                <1>     jmp     .done
    96                              <1> 
    97                              <1> .timeout:
    98 000013A8 B480                <1>     mov     ah, ST_TIMEOUT
    99 000013AA EB0B                <1>     jmp     .done
   100                              <1> 
   101                              <1> .error:
   102 000013AC 8B16[C931]          <1>     mov     dx, [current_base]
   103 000013B0 83C201              <1>     add     dx, WD_ERROR
   104 000013B3 EC                  <1>     in      al, dx
   105 000013B4 E874F8              <1>     call    translate_error
   106                              <1> 
   107                              <1> .done:
   108 000013B7 5E                  <1>     pop     si
   109 000013B8 5A                  <1>     pop     dx
   110 000013B9 59                  <1>     pop     cx
   111 000013BA 5B                  <1>     pop     bx
   112 000013BB C3                  <1>     ret
   113                              <1> 
   114                              <1> ;==============================================================================
   115                              <1> ; Function 0Ah: Read Long (Sector + ECC)
   116                              <1> ;==============================================================================
   117                              <1> ; Reads sector data plus ECC bytes (typically 4-7 extra bytes).
   118                              <1> ;
   119                              <1> ; Input:  AL = sector count (usually 1)
   120                              <1> ;         CH = cylinder low
   121                              <1> ;         CL = sector + cylinder high
   122                              <1> ;         DH = head
   123                              <1> ;         DL = drive
   124                              <1> ;         ES:BX = buffer
   125                              <1> ; Output: AH = status
   126                              <1> ;         AL = sectors read
   127                              <1> ;         CF = 0 if success
   128                              <1> ;==============================================================================
   129                              <1> int13h_read_long:
   130 000013BC 53                  <1>     push    bx
   131 000013BD 51                  <1>     push    cx
   132 000013BE 52                  <1>     push    dx
   133 000013BF 57                  <1>     push    di
   134                              <1> 
   135                              <1>     ; Save count
   136 000013C0 A2[2314]            <1>     mov     [.count], al
   137                              <1> 
   138                              <1>     ; Select drive
   139 000013C3 E85EF5              <1>     call    select_drive
   140                              <1> 
   141                              <1>     ; Wait ready
   142 000013C6 E873F5              <1>     call    wait_drive_ready
   143 000013C9 7240                <1>     jc      .timeout
   144                              <1> 
   145                              <1>     ; Set up task file (same as regular read)
   146 000013CB A0[2314]            <1>     mov     al, [.count]
   147 000013CE 8B16[C931]          <1>     mov     dx, [current_base]
   148 000013D2 83C202              <1>     add     dx, WD_SECCNT
   149 000013D5 EE                  <1>     out     dx, al
   150                              <1> 
   151 000013D6 88C8                <1>     mov     al, cl
   152 000013D8 243F                <1>     and     al, 0x3F
   153 000013DA 42                  <1>     inc     dx
   154 000013DB EE                  <1>     out     dx, al
   155                              <1> 
   156 000013DC 88E8                <1>     mov     al, ch
   157 000013DE 42                  <1>     inc     dx
   158 000013DF EE                  <1>     out     dx, al
   159                              <1> 
   160 000013E0 88C8                <1>     mov     al, cl
   161 000013E2 C0E806              <1>     shr     al, 6
   162 000013E5 42                  <1>     inc     dx
   163 000013E6 EE                  <1>     out     dx, al
   164                              <1> 
   165                              <1>     ; Issue READ LONG command
   166 000013E7 8B16[C931]          <1>     mov     dx, [current_base]
   167 000013EB 83C207              <1>     add     dx, WD_COMMAND
   168 000013EE B022                <1>     mov     al, CMD_READ_LONG
   169 000013F0 EE                  <1>     out     dx, al
   170                              <1> 
   171                              <1>     ; Wait for DRQ
   172 000013F1 E807F9              <1>     call    wd_wait_drq
   173 000013F4 721B                <1>     jc      .error
   174                              <1> 
   175                              <1>     ; Read 516 bytes (512 data + 4 ECC) per sector
   176 000013F6 89DF                <1>     mov     di, bx
   177 000013F8 B90201              <1>     mov     cx, 258                 ; 258 words = 516 bytes
   178 000013FB 8B16[C931]          <1>     mov     dx, [current_base]
   179 000013FF 83C200              <1>     add     dx, WD_DATA
   180 00001402 F36D                <1>     rep insw
   181                              <1> 
   182 00001404 A0[2314]            <1>     mov     al, [.count]
   183 00001407 B400                <1>     mov     ah, ST_SUCCESS
   184 00001409 EB13                <1>     jmp     .done
   185                              <1> 
   186                              <1> .timeout:
   187 0000140B B480                <1>     mov     ah, ST_TIMEOUT
   188 0000140D 30C0                <1>     xor     al, al
   189 0000140F EB0D                <1>     jmp     .done
   190                              <1> 
   191                              <1> .error:
   192 00001411 8B16[C931]          <1>     mov     dx, [current_base]
   193 00001415 83C201              <1>     add     dx, WD_ERROR
   194 00001418 EC                  <1>     in      al, dx
   195 00001419 E80FF8              <1>     call    translate_error
   196 0000141C 30C0                <1>     xor     al, al
   197                              <1> 
   198                              <1> .done:
   199 0000141E 5F                  <1>     pop     di
   200 0000141F 5A                  <1>     pop     dx
   201 00001420 59                  <1>     pop     cx
   202 00001421 5B                  <1>     pop     bx
   203 00001422 C3                  <1>     ret
   204                              <1> 
   205 00001423 00                  <1> .count: db 0
   206                              <1> 
   207                              <1> ;==============================================================================
   208                              <1> ; Function 0Bh: Write Long (Sector + ECC)
   209                              <1> ;==============================================================================
   210                              <1> ; Writes sector data plus ECC bytes.
   211                              <1> ;
   212                              <1> ; Input:  Same as Read Long
   213                              <1> ; Output: Same as Read Long
   214                              <1> ;==============================================================================
   215                              <1> int13h_write_long:
   216 00001424 53                  <1>     push    bx
   217 00001425 51                  <1>     push    cx
   218 00001426 52                  <1>     push    dx
   219 00001427 56                  <1>     push    si
   220                              <1> 
   221 00001428 A2[9714]            <1>     mov     [.count], al
   222                              <1> 
   223 0000142B E8F6F4              <1>     call    select_drive
   224 0000142E E80BF5              <1>     call    wait_drive_ready
   225 00001431 724A                <1>     jc      .timeout
   226                              <1> 
   227                              <1>     ; Set up task file
   228 00001433 A0[9714]            <1>     mov     al, [.count]
   229 00001436 8B16[C931]          <1>     mov     dx, [current_base]
   230 0000143A 83C202              <1>     add     dx, WD_SECCNT
   231 0000143D EE                  <1>     out     dx, al
   232                              <1> 
   233 0000143E 88C8                <1>     mov     al, cl
   234 00001440 243F                <1>     and     al, 0x3F
   235 00001442 42                  <1>     inc     dx
   236 00001443 EE                  <1>     out     dx, al
   237                              <1> 
   238 00001444 88E8                <1>     mov     al, ch
   239 00001446 42                  <1>     inc     dx
   240 00001447 EE                  <1>     out     dx, al
   241                              <1> 
   242 00001448 88C8                <1>     mov     al, cl
   243 0000144A C0E806              <1>     shr     al, 6
   244 0000144D 42                  <1>     inc     dx
   245 0000144E EE                  <1>     out     dx, al
   246                              <1> 
   247                              <1>     ; Issue WRITE LONG command
   248 0000144F 8B16[C931]          <1>     mov     dx, [current_base]
   249 00001453 83C207              <1>     add     dx, WD_COMMAND
   250 00001456 B032                <1>     mov     al, CMD_WRITE_LONG
   251 00001458 EE                  <1>     out     dx, al
   252                              <1> 
   253                              <1>     ; Wait for DRQ
   254 00001459 E89FF8              <1>     call    wd_wait_drq
   255 0000145C 7225                <1>     jc      .error
   256                              <1> 
   257                              <1>     ; Write 516 bytes
   258 0000145E 89DE                <1>     mov     si, bx
   259 00001460 06                  <1>     push    es
   260 00001461 1F                  <1>     pop     ds
   261 00001462 B90201              <1>     mov     cx, 258
   262 00001465 2E8B16[C931]        <1>     mov     dx, [cs:current_base]
   263 0000146A 83C200              <1>     add     dx, WD_DATA
   264 0000146D F36F                <1>     rep outsw
   265 0000146F 0E                  <1>     push    cs
   266 00001470 1F                  <1>     pop     ds
   267                              <1> 
   268                              <1>     ; Wait for completion
   269 00001471 E8A2F8              <1>     call    wd_wait_not_busy
   270 00001474 7207                <1>     jc      .timeout
   271                              <1> 
   272 00001476 A0[9714]            <1>     mov     al, [.count]
   273 00001479 B400                <1>     mov     ah, ST_SUCCESS
   274 0000147B EB15                <1>     jmp     .done
   275                              <1> 
   276                              <1> .timeout:
   277 0000147D B480                <1>     mov     ah, ST_TIMEOUT
   278 0000147F 30C0                <1>     xor     al, al
   279 00001481 EB0F                <1>     jmp     .done
   280                              <1> 
   281                              <1> .error:
   282 00001483 0E                  <1>     push    cs
   283 00001484 1F                  <1>     pop     ds
   284 00001485 8B16[C931]          <1>     mov     dx, [current_base]
   285 00001489 83C201              <1>     add     dx, WD_ERROR
   286 0000148C EC                  <1>     in      al, dx
   287 0000148D E89BF7              <1>     call    translate_error
   288 00001490 30C0                <1>     xor     al, al
   289                              <1> 
   290                              <1> .done:
   291 00001492 5E                  <1>     pop     si
   292 00001493 5A                  <1>     pop     dx
   293 00001494 59                  <1>     pop     cx
   294 00001495 5B                  <1>     pop     bx
   295 00001496 C3                  <1>     ret
   296                              <1> 
   297 00001497 00                  <1> .count: db 0
   298                              <1> 
   299                              <1> ;==============================================================================
   300                              <1> ; Function 0Ch: Seek to Cylinder
   301                              <1> ;==============================================================================
   302                              <1> ; Moves the head to the specified cylinder.
   303                              <1> ;
   304                              <1> ; Input:  CH = cylinder low
   305                              <1> ;         CL = cylinder high (bits 6-7)
   306                              <1> ;         DH = head
   307                              <1> ;         DL = drive
   308                              <1> ; Output: AH = status
   309                              <1> ;         CF = 0 if success
   310                              <1> ;==============================================================================
   311                              <1> int13h_seek:
   312 00001498 53                  <1>     push    bx
   313 00001499 51                  <1>     push    cx
   314 0000149A 52                  <1>     push    dx
   315                              <1> 
   316                              <1>     ; Select drive and head
   317 0000149B E886F4              <1>     call    select_drive
   318                              <1> 
   319                              <1>     ; Wait ready
   320 0000149E E89BF4              <1>     call    wait_drive_ready
   321 000014A1 723A                <1>     jc      .timeout
   322                              <1> 
   323                              <1>     ; Set cylinder
   324 000014A3 88E8                <1>     mov     al, ch
   325 000014A5 8B16[C931]          <1>     mov     dx, [current_base]
   326 000014A9 83C204              <1>     add     dx, WD_CYL_LO
   327 000014AC EE                  <1>     out     dx, al
   328                              <1> 
   329 000014AD 88C8                <1>     mov     al, cl
   330 000014AF C0E806              <1>     shr     al, 6
   331 000014B2 42                  <1>     inc     dx
   332 000014B3 EE                  <1>     out     dx, al
   333                              <1> 
   334                              <1>     ; Issue SEEK command
   335 000014B4 8B16[C931]          <1>     mov     dx, [current_base]
   336 000014B8 83C207              <1>     add     dx, WD_COMMAND
   337 000014BB B070                <1>     mov     al, CMD_SEEK
   338 000014BD EE                  <1>     out     dx, al
   339                              <1> 
   340                              <1>     ; Wait for seek complete
   341 000014BE 8B16[C931]          <1>     mov     dx, [current_base]
   342 000014C2 83C207              <1>     add     dx, WD_STATUS
   343 000014C5 B9FFFF              <1>     mov     cx, TIMEOUT_SEEK
   344                              <1> 
   345                              <1> .wait_seek:
   346 000014C8 EC                  <1>     in      al, dx
   347 000014C9 A880                <1>     test    al, STS_BSY
   348 000014CB 7504                <1>     jnz     .continue
   349 000014CD A810                <1>     test    al, STS_DSC             ; Seek complete?
   350 000014CF 7504                <1>     jnz     .seek_done
   351                              <1> .continue:
   352 000014D1 E2F5                <1>     loop    .wait_seek
   353 000014D3 EB08                <1>     jmp     .timeout
   354                              <1> 
   355                              <1> .seek_done:
   356 000014D5 A801                <1>     test    al, STS_ERR
   357 000014D7 7508                <1>     jnz     .error
   358                              <1> 
   359 000014D9 B400                <1>     mov     ah, ST_SUCCESS
   360 000014DB EB06                <1>     jmp     .done
   361                              <1> 
   362                              <1> .timeout:
   363 000014DD B480                <1>     mov     ah, ST_TIMEOUT
   364 000014DF EB02                <1>     jmp     .done
   365                              <1> 
   366                              <1> .error:
   367 000014E1 B440                <1>     mov     ah, ST_SEEK_ERROR
   368                              <1> 
   369                              <1> .done:
   370 000014E3 5A                  <1>     pop     dx
   371 000014E4 59                  <1>     pop     cx
   372 000014E5 5B                  <1>     pop     bx
   373 000014E6 C3                  <1>     ret
   374                              <1> 
   375                              <1> ;==============================================================================
   376                              <1> ; Function 10h: Test Drive Ready
   377                              <1> ;==============================================================================
   378                              <1> ; Checks if the drive is ready.
   379                              <1> ;
   380                              <1> ; Input:  DL = drive
   381                              <1> ; Output: AH = status (0 if ready)
   382                              <1> ;         CF = 0 if ready
   383                              <1> ;==============================================================================
   384                              <1> int13h_test_ready:
   385 000014E7 52                  <1>     push    dx
   386                              <1> 
   387                              <1>     ; Select drive
   388 000014E8 E839F4              <1>     call    select_drive
   389                              <1> 
   390                              <1>     ; Check status
   391 000014EB 8B16[C931]          <1>     mov     dx, [current_base]
   392 000014EF 83C207              <1>     add     dx, WD_STATUS
   393 000014F2 EC                  <1>     in      al, dx
   394                              <1> 
   395                              <1>     ; Check BSY
   396 000014F3 A880                <1>     test    al, STS_BSY
   397 000014F5 7508                <1>     jnz     .not_ready
   398                              <1> 
   399                              <1>     ; Check DRDY
   400 000014F7 A840                <1>     test    al, STS_DRDY
   401 000014F9 7404                <1>     jz      .not_ready
   402                              <1> 
   403 000014FB B400                <1>     mov     ah, ST_SUCCESS
   404 000014FD EB02                <1>     jmp     .done
   405                              <1> 
   406                              <1> .not_ready:
   407 000014FF B4AA                <1>     mov     ah, ST_NOT_READY
   408                              <1> 
   409                              <1> .done:
   410 00001501 5A                  <1>     pop     dx
   411 00001502 C3                  <1>     ret
   412                              <1> 
   413                              <1> ;==============================================================================
   414                              <1> ; Function 11h: Recalibrate Drive
   415                              <1> ;==============================================================================
   416                              <1> ; Moves the head to track 0.
   417                              <1> ;
   418                              <1> ; Input:  DL = drive
   419                              <1> ; Output: AH = status
   420                              <1> ;         CF = 0 if success
   421                              <1> ;==============================================================================
   422                              <1> int13h_recalibrate:
   423 00001503 53                  <1>     push    bx
   424 00001504 51                  <1>     push    cx
   425 00001505 52                  <1>     push    dx
   426                              <1> 
   427                              <1>     ; Select drive
   428 00001506 E81BF4              <1>     call    select_drive
   429                              <1> 
   430                              <1>     ; Wait ready
   431 00001509 E830F4              <1>     call    wait_drive_ready
   432 0000150C 7229                <1>     jc      .timeout
   433                              <1> 
   434                              <1>     ; Issue RECALIBRATE command
   435 0000150E 8B16[C931]          <1>     mov     dx, [current_base]
   436 00001512 83C207              <1>     add     dx, WD_COMMAND
   437 00001515 B010                <1>     mov     al, CMD_RECALIBRATE
   438 00001517 EE                  <1>     out     dx, al
   439                              <1> 
   440                              <1>     ; Wait for completion (recalibrate can take a while)
   441 00001518 8B16[C931]          <1>     mov     dx, [current_base]
   442 0000151C 83C207              <1>     add     dx, WD_STATUS
   443 0000151F B90000              <1>     mov     cx, 0                   ; Long timeout (65536 iterations)
   444                              <1> 
   445                              <1> .wait_loop:
   446 00001522 EC                  <1>     in      al, dx
   447 00001523 A880                <1>     test    al, STS_BSY
   448 00001525 7404                <1>     jz      .check_done
   449 00001527 E2F9                <1>     loop    .wait_loop
   450 00001529 EB0C                <1>     jmp     .timeout
   451                              <1> 
   452                              <1> .check_done:
   453                              <1>     ; Check for error
   454 0000152B A801                <1>     test    al, STS_ERR
   455 0000152D 750C                <1>     jnz     .error
   456                              <1> 
   457                              <1>     ; Check Track 0 found (seek complete)
   458 0000152F A810                <1>     test    al, STS_DSC
   459 00001531 7408                <1>     jz      .error
   460                              <1> 
   461 00001533 B400                <1>     mov     ah, ST_SUCCESS
   462 00001535 EB16                <1>     jmp     .done
   463                              <1> 
   464                              <1> .timeout:
   465 00001537 B480                <1>     mov     ah, ST_TIMEOUT
   466 00001539 EB12                <1>     jmp     .done
   467                              <1> 
   468                              <1> .error:
   469 0000153B 8B16[C931]          <1>     mov     dx, [current_base]
   470 0000153F 83C201              <1>     add     dx, WD_ERROR
   471 00001542 EC                  <1>     in      al, dx
   472 00001543 A802                <1>     test    al, ERR_TK0NF
   473 00001545 7504                <1>     jnz     .track0_error
   474 00001547 B440                <1>     mov     ah, ST_SEEK_ERROR
   475 00001549 EB02                <1>     jmp     .done
   476                              <1> 
   477                              <1> .track0_error:
   478 0000154B B440                <1>     mov     ah, ST_SEEK_ERROR
   479                              <1> 
   480                              <1> .done:
   481 0000154D 5A                  <1>     pop     dx
   482 0000154E 59                  <1>     pop     cx
   483 0000154F 5B                  <1>     pop     bx
   484 00001550 C3                  <1>     ret
   485                              <1> 
   486                              <1> ;==============================================================================
   487                              <1> ; Function 14h: Controller Internal Diagnostic
   488                              <1> ;==============================================================================
   489                              <1> ; Runs controller self-test.
   490                              <1> ;
   491                              <1> ; Input:  DL = drive
   492                              <1> ; Output: AH = status (0 = passed)
   493                              <1> ;         CF = 0 if passed
   494                              <1> ;==============================================================================
   495                              <1> int13h_diagnostic:
   496 00001551 53                  <1>     push    bx
   497 00001552 51                  <1>     push    cx
   498 00001553 52                  <1>     push    dx
   499                              <1> 
   500                              <1>     ; Issue EXECUTE DRIVE DIAGNOSTICS command
   501 00001554 8B16[C931]          <1>     mov     dx, [current_base]
   502 00001558 83C207              <1>     add     dx, WD_COMMAND
   503 0000155B B090                <1>     mov     al, CMD_DIAG
   504 0000155D EE                  <1>     out     dx, al
   505                              <1> 
   506                              <1>     ; Wait for completion
   507 0000155E 8B16[C931]          <1>     mov     dx, [current_base]
   508 00001562 83C207              <1>     add     dx, WD_STATUS
   509 00001565 B9FFFF              <1>     mov     cx, TIMEOUT_DRDY
   510                              <1> 
   511                              <1> .wait_loop:
   512 00001568 EC                  <1>     in      al, dx
   513 00001569 A880                <1>     test    al, STS_BSY
   514 0000156B 7404                <1>     jz      .check_result
   515 0000156D E2F9                <1>     loop    .wait_loop
   516 0000156F EB14                <1>     jmp     .timeout
   517                              <1> 
   518                              <1> .check_result:
   519                              <1>     ; Read diagnostic code from error register
   520 00001571 8B16[C931]          <1>     mov     dx, [current_base]
   521 00001575 83C201              <1>     add     dx, WD_ERROR
   522 00001578 EC                  <1>     in      al, dx
   523                              <1> 
   524                              <1>     ; Code 01h = passed (no error)
   525 00001579 3C01                <1>     cmp     al, 0x01
   526 0000157B 7404                <1>     je      .passed
   527                              <1> 
   528                              <1>     ; Convert diagnostic code to status
   529 0000157D B420                <1>     mov     ah, ST_CONTROLLER
   530 0000157F EB06                <1>     jmp     .done
   531                              <1> 
   532                              <1> .passed:
   533 00001581 B400                <1>     mov     ah, ST_SUCCESS
   534 00001583 EB02                <1>     jmp     .done
   535                              <1> 
   536                              <1> .timeout:
   537 00001585 B480                <1>     mov     ah, ST_TIMEOUT
   538                              <1> 
   539                              <1> .done:
   540 00001587 5A                  <1>     pop     dx
   541 00001588 59                  <1>     pop     cx
   542 00001589 5B                  <1>     pop     bx
   543 0000158A C3                  <1>     ret
   544                              <1> 
   545                              <1> ;==============================================================================
   546                              <1> ; Function 15h: Get Disk Type
   547                              <1> ;==============================================================================
   548                              <1> ; Returns disk type and size.
   549                              <1> ;
   550                              <1> ; Input:  DL = drive
   551                              <1> ; Output: AH = disk type (0=not present, 1=floppy no change, 2=floppy change, 3=hard disk)
   552                              <1> ;         CX:DX = number of 512-byte sectors (if AH=3)
   553                              <1> ;         CF = 0 if success
   554                              <1> ;==============================================================================
   555                              <1> int13h_get_disk_type:
   556 0000158B 53                  <1>     push    bx
   557 0000158C 56                  <1>     push    si
   558                              <1> 
   559                              <1>     ; Validate drive
   560 0000158D E860F3              <1>     call    get_drive_params
   561 00001590 7223                <1>     jc      .not_present
   562                              <1> 
   563                              <1>     ; It's a hard disk
   564 00001592 B403                <1>     mov     ah, 3                   ; Type 3 = hard disk
   565                              <1> 
   566                              <1>     ; Calculate total sectors
   567                              <1>     ; Total = cylinders * heads * sectors
   568 00001594 8B04                <1>     mov     ax, [si + 0]            ; Cylinders
   569 00001596 30FF                <1>     xor     bh, bh
   570 00001598 8A5C02              <1>     mov     bl, [si + 2]            ; Heads
   571 0000159B F7E3                <1>     mul     bx                      ; DX:AX = cyl * heads
   572                              <1> 
   573 0000159D 30FF                <1>     xor     bh, bh
   574 0000159F 8A5C03              <1>     mov     bl, [si + 3]            ; Sectors
   575                              <1>     ; 32-bit multiply
   576 000015A2 52                  <1>     push    dx
   577 000015A3 F7E3                <1>     mul     bx                      ; Low result
   578 000015A5 89C1                <1>     mov     cx, ax                  ; Save low word
   579 000015A7 58                  <1>     pop     ax
   580 000015A8 52                  <1>     push    dx
   581 000015A9 F7E3                <1>     mul     bx                      ; High result
   582 000015AB 5B                  <1>     pop     bx
   583 000015AC 01D8                <1>     add     ax, bx
   584                              <1> 
   585                              <1>     ; Result: CX = low word, DX = high word (swapped for return)
   586 000015AE 87CA                <1>     xchg    cx, dx                  ; CX:DX = sector count
   587                              <1> 
   588 000015B0 B403                <1>     mov     ah, 3                   ; Disk type
   589 000015B2 F8                  <1>     clc
   590 000015B3 EB06                <1>     jmp     .done
   591                              <1> 
   592                              <1> .not_present:
   593 000015B5 B400                <1>     mov     ah, 0                   ; Not present
   594 000015B7 31C9                <1>     xor     cx, cx
   595 000015B9 31D2                <1>     xor     dx, dx
   596                              <1>     ; CF already set from get_drive_params
   597                              <1> 
   598                              <1> .done:
   599 000015BB 5E                  <1>     pop     si
   600 000015BC 5B                  <1>     pop     bx
   601 000015BD C3                  <1>     ret
   602                              <1> 
   603                              <1> %endif ; ENABLE_EXTENDED
   225                                  %include "func_lba.asm"
     1                              <1> ;==============================================================================
     2                              <1> ; FluxRipper HDD BIOS - LBA Extension Functions (41h-48h)
     3                              <1> ;==============================================================================
     4                              <1> ; Implements IBM/Microsoft INT 13h extensions for LBA addressing.
     5                              <1> ; These extensions allow access to drives larger than 8.4GB (CHS limit).
     6                              <1> ;
     7                              <1> ; Functions:
     8                              <1> ;   41h - Installation check
     9                              <1> ;   42h - Extended read
    10                              <1> ;   43h - Extended write
    11                              <1> ;   44h - Extended verify
    12                              <1> ;   47h - Extended seek
    13                              <1> ;   48h - Get extended drive parameters
    14                              <1> ;
    15                              <1> ; SPDX-License-Identifier: BSD-3-Clause
    16                              <1> ; Copyright (c) 2025 FluxRipper Project
    17                              <1> ;==============================================================================
    18                              <1> 
    19                              <1> %if ENABLE_LBA
    20                              <1> 
    21                              <1> ;==============================================================================
    22                              <1> ; Function 41h: Check Extensions Present
    23                              <1> ;==============================================================================
    24                              <1> ; Checks if INT 13h extensions are supported.
    25                              <1> ;
    26                              <1> ; Input:  AH = 41h
    27                              <1> ;         BX = 55AAh
    28                              <1> ;         DL = drive number
    29                              <1> ; Output: CF = 0 if extensions supported
    30                              <1> ;         AH = version (21h = 1.1, 30h = EDD-1.1)
    31                              <1> ;         BX = AA55h (signature)
    32                              <1> ;         CX = interface support bitmap
    33                              <1> ;==============================================================================
    34                              <1> int13h_check_extensions:
    35                              <1>     ; Verify signature
    36 000015BE 81FBAA55            <1>     cmp     bx, 0x55AA
    37 000015C2 7511                <1>     jne     .not_supported
    38                              <1> 
    39                              <1>     ; Verify drive exists
    40 000015C4 52                  <1>     push    dx
    41 000015C5 E828F3              <1>     call    get_drive_params
    42 000015C8 5A                  <1>     pop     dx
    43 000015C9 720A                <1>     jc      .not_supported
    44                              <1> 
    45                              <1>     ; Return success
    46 000015CB B421                <1>     mov     ah, EXT_VER_21          ; Version 2.1
    47 000015CD BB55AA              <1>     mov     bx, 0xAA55              ; Inverted signature
    48 000015D0 B90100              <1>     mov     cx, EXT_DAP             ; Support DAP (read/write/verify)
    49 000015D3 F8                  <1>     clc
    50 000015D4 C3                  <1>     ret
    51                              <1> 
    52                              <1> .not_supported:
    53 000015D5 B401                <1>     mov     ah, ST_BAD_COMMAND
    54 000015D7 F9                  <1>     stc
    55 000015D8 C3                  <1>     ret
    56                              <1> 
    57                              <1> ;==============================================================================
    58                              <1> ; Function 42h: Extended Read
    59                              <1> ;==============================================================================
    60                              <1> ; Reads sectors using LBA addressing via Device Address Packet.
    61                              <1> ;
    62                              <1> ; Input:  AH = 42h
    63                              <1> ;         DL = drive number
    64                              <1> ;         DS:SI = pointer to Device Address Packet (DAP)
    65                              <1> ;
    66                              <1> ; DAP Structure:
    67                              <1> ;   +00 byte  = packet size (10h)
    68                              <1> ;   +01 byte  = reserved (0)
    69                              <1> ;   +02 word  = sector count
    70                              <1> ;   +04 dword = buffer address (segment:offset)
    71                              <1> ;   +08 qword = starting LBA
    72                              <1> ;
    73                              <1> ; Output: AH = status
    74                              <1> ;         CF = 0 if success
    75                              <1> ;==============================================================================
    76                              <1> int13h_ext_read:
    77 000015D9 53                  <1>     push    bx
    78 000015DA 51                  <1>     push    cx
    79 000015DB 52                  <1>     push    dx
    80 000015DC 56                  <1>     push    si
    81 000015DD 57                  <1>     push    di
    82 000015DE 55                  <1>     push    bp
    83 000015DF 06                  <1>     push    es
    84                              <1> 
    85                              <1>     ; Validate DAP
    86 000015E0 89F5                <1>     mov     bp, si                  ; BP = DAP pointer
    87 000015E2 803C10              <1>     cmp     byte [si], DAP_SIZE_BASIC
    88 000015E5 0F829C00            <1>     jb      .invalid_dap
    89                              <1> 
    90                              <1>     ; Get sector count
    91 000015E9 8B4C02              <1>     mov     cx, [si + DAP.count]
    92 000015EC 85C9                <1>     test    cx, cx
    93 000015EE 0F848900            <1>     jz      .success                ; Zero sectors = success
    94                              <1> 
    95                              <1>     ; Get buffer address
    96 000015F2 C47C04              <1>     les     di, [si + DAP.buffer]   ; ES:DI = buffer
    97                              <1> 
    98                              <1>     ; Get LBA (we only support 32-bit LBA for now)
    99 000015F5 8B4408              <1>     mov     ax, [si + DAP.lba]      ; Low word
   100 000015F8 8B5C0A              <1>     mov     bx, [si + DAP.lba + 2]  ; High word (of low dword)
   101                              <1>     ; Ignore upper 32 bits for drives < 2TB
   102                              <1> 
   103                              <1>     ; Save LBA
   104 000015FB A3[AC16]            <1>     mov     [.lba_lo], ax
   105 000015FE 891E[AE16]          <1>     mov     [.lba_hi], bx
   106 00001602 890E[B016]          <1>     mov     [.count], cx
   107 00001606 C706[B216]0000      <1>     mov     word [.sectors_done], 0
   108                              <1> 
   109                              <1>     ; Select drive
   110 0000160C 8A56FE              <1>     mov     dl, [bp - 2]            ; Get drive from stack
   111 0000160F E812F3              <1>     call    select_drive
   112                              <1> 
   113                              <1> .read_loop:
   114                              <1>     ; Wait ready
   115 00001612 E827F3              <1>     call    wait_drive_ready
   116 00001615 7272                <1>     jc      .timeout
   117                              <1> 
   118                              <1>     ; Convert current LBA to task file
   119                              <1>     ; For LBA mode: sector = LBA[7:0], cyl_lo = LBA[15:8], cyl_hi = LBA[23:16]
   120                              <1>     ;               SDH[3:0] = LBA[27:24], SDH[6] = 1 (LBA mode)
   121                              <1> 
   122 00001617 A1[AC16]            <1>     mov     ax, [.lba_lo]
   123 0000161A 8B1E[AE16]          <1>     mov     bx, [.lba_hi]
   124                              <1> 
   125                              <1>     ; Sector count = 1 (one sector at a time for simplicity)
   126 0000161E 8B16[C931]          <1>     mov     dx, [current_base]
   127 00001622 83C202              <1>     add     dx, WD_SECCNT
   128 00001625 B001                <1>     mov     al, 1
   129 00001627 EE                  <1>     out     dx, al
   130                              <1> 
   131                              <1>     ; LBA[7:0] -> sector number
   132 00001628 A1[AC16]            <1>     mov     ax, [.lba_lo]
   133 0000162B 42                  <1>     inc     dx                      ; WD_SECNUM
   134 0000162C EE                  <1>     out     dx, al
   135                              <1> 
   136                              <1>     ; LBA[15:8] -> cylinder low
   137 0000162D 88E0                <1>     mov     al, ah
   138 0000162F 42                  <1>     inc     dx                      ; WD_CYL_LO
   139 00001630 EE                  <1>     out     dx, al
   140                              <1> 
   141                              <1>     ; LBA[23:16] -> cylinder high
   142 00001631 A0[AE16]            <1>     mov     al, [.lba_hi]
   143 00001634 42                  <1>     inc     dx                      ; WD_CYL_HI
   144 00001635 EE                  <1>     out     dx, al
   145                              <1> 
   146                              <1>     ; LBA[27:24] + LBA mode -> SDH
   147 00001636 A0[AF16]            <1>     mov     al, [.lba_hi + 1]
   148 00001639 240F                <1>     and     al, 0x0F                ; LBA[27:24]
   149 0000163B 0CE0                <1>     or      al, SDH_SIZE_512 | SDH_LBA  ; Add LBA mode bit
   150                              <1>     ; Add drive select if needed
   151 0000163D 8A5EFE              <1>     mov     bl, [bp - 2]
   152 00001640 80FB81              <1>     cmp     bl, 0x81
   153 00001643 7502                <1>     jne     .not_drive1
   154 00001645 0C10                <1>     or      al, SDH_DRV1
   155                              <1> .not_drive1:
   156 00001647 42                  <1>     inc     dx                      ; WD_SDH
   157 00001648 EE                  <1>     out     dx, al
   158                              <1> 
   159                              <1>     ; Issue READ command
   160 00001649 8B16[C931]          <1>     mov     dx, [current_base]
   161 0000164D 83C207              <1>     add     dx, WD_COMMAND
   162 00001650 B020                <1>     mov     al, CMD_READ
   163 00001652 EE                  <1>     out     dx, al
   164                              <1> 
   165                              <1>     ; Wait for DRQ
   166 00001653 E8A5F6              <1>     call    wd_wait_drq
   167 00001656 723B                <1>     jc      .read_error
   168                              <1> 
   169                              <1>     ; Read 256 words
   170 00001658 8B16[C931]          <1>     mov     dx, [current_base]
   171 0000165C 83C200              <1>     add     dx, WD_DATA
   172 0000165F B90001              <1>     mov     cx, 256
   173 00001662 F36D                <1>     rep insw
   174                              <1> 
   175                              <1>     ; Increment done count
   176 00001664 FF06[A416]          <1>     inc     word [.done]
   177                              <1> 
   178                              <1>     ; Increment LBA
   179 00001668 8306[AC16]01        <1>     add     word [.lba_lo], 1
   180 0000166D 8316[AE16]00        <1>     adc     word [.lba_hi], 0
   181                              <1> 
   182                              <1>     ; Check if more sectors
   183 00001672 A1[A416]            <1>     mov     ax, [.done]
   184 00001675 3B06[B016]          <1>     cmp     ax, [.count]
   185 00001679 7297                <1>     jb      .read_loop
   186                              <1> 
   187                              <1> .success:
   188                              <1>     ; Update DAP with actual count
   189 0000167B A1[A416]            <1>     mov     ax, [.done]
   190 0000167E 894602              <1>     mov     [bp + DAP.count], ax
   191 00001681 B400                <1>     mov     ah, ST_SUCCESS
   192 00001683 EB1F                <1>     jmp     .done
   193                              <1> 
   194                              <1> .invalid_dap:
   195 00001685 B401                <1>     mov     ah, ST_BAD_COMMAND
   196 00001687 EB1B                <1>     jmp     .done
   197                              <1> 
   198                              <1> .timeout:
   199 00001689 A1[B216]            <1>     mov     ax, [.sectors_done]
   200 0000168C 894602              <1>     mov     [bp + DAP.count], ax
   201 0000168F B480                <1>     mov     ah, ST_TIMEOUT
   202 00001691 EB11                <1>     jmp     .done
   203                              <1> 
   204                              <1> .read_error:
   205 00001693 A1[B216]            <1>     mov     ax, [.sectors_done]
   206 00001696 894602              <1>     mov     [bp + DAP.count], ax
   207 00001699 8B16[C931]          <1>     mov     dx, [current_base]
   208 0000169D 83C201              <1>     add     dx, WD_ERROR
   209 000016A0 EC                  <1>     in      al, dx
   210 000016A1 E887F5              <1>     call    translate_error
   211                              <1> 
   212                              <1> .done:
   213 000016A4 07                  <1>     pop     es
   214 000016A5 5D                  <1>     pop     bp
   215 000016A6 5F                  <1>     pop     di
   216 000016A7 5E                  <1>     pop     si
   217 000016A8 5A                  <1>     pop     dx
   218 000016A9 59                  <1>     pop     cx
   219 000016AA 5B                  <1>     pop     bx
   220 000016AB C3                  <1>     ret
   221                              <1> 
   222 000016AC 0000                <1> .lba_lo:        dw 0
   223 000016AE 0000                <1> .lba_hi:        dw 0
   224 000016B0 0000                <1> .count:         dw 0
   225 000016B2 0000                <1> .sectors_done:  dw 0
   226                              <1> 
   227                              <1> ;==============================================================================
   228                              <1> ; Function 43h: Extended Write
   229                              <1> ;==============================================================================
   230                              <1> ; Writes sectors using LBA addressing.
   231                              <1> ;
   232                              <1> ; Input:  Same as Extended Read
   233                              <1> ; Output: Same as Extended Read
   234                              <1> ;==============================================================================
   235                              <1> int13h_ext_write:
   236 000016B4 53                  <1>     push    bx
   237 000016B5 51                  <1>     push    cx
   238 000016B6 52                  <1>     push    dx
   239 000016B7 56                  <1>     push    si
   240 000016B8 57                  <1>     push    di
   241 000016B9 55                  <1>     push    bp
   242 000016BA 06                  <1>     push    es
   243 000016BB 1E                  <1>     push    ds
   244                              <1> 
   245                              <1>     ; Validate DAP
   246 000016BC 89F5                <1>     mov     bp, si
   247 000016BE 803C10              <1>     cmp     byte [si], DAP_SIZE_BASIC
   248 000016C1 0F82C900            <1>     jb      .invalid_dap
   249                              <1> 
   250                              <1>     ; Get sector count
   251 000016C5 8B4C02              <1>     mov     cx, [si + DAP.count]
   252 000016C8 85C9                <1>     test    cx, cx
   253 000016CA 0F84B400            <1>     jz      .success
   254                              <1> 
   255                              <1>     ; Get buffer address - need DS:SI for writing
   256 000016CE C57604              <1>     lds     si, [bp + DAP.buffer]   ; DS:SI = buffer
   257                              <1> 
   258                              <1>     ; Get LBA
   259 000016D1 8B4608              <1>     mov     ax, [bp + DAP.lba]
   260 000016D4 8B5E0A              <1>     mov     bx, [bp + DAP.lba + 2]
   261 000016D7 2EA3[BA17]          <1>     mov     [cs:.lba_lo], ax
   262 000016DB 2E891E[BC17]        <1>     mov     [cs:.lba_hi], bx
   263 000016E0 2E890E[BE17]        <1>     mov     [cs:.count], cx
   264 000016E5 2EC706[C017]0000    <1>     mov     word [cs:.sectors_done], 0
   265                              <1> 
   266                              <1>     ; Select drive
   267 000016EC 1E                  <1>     push    ds
   268 000016ED 0E                  <1>     push    cs
   269 000016EE 1F                  <1>     pop     ds
   270 000016EF 8A56FE              <1>     mov     dl, [bp - 2]
   271 000016F2 E82FF2              <1>     call    select_drive
   272 000016F5 1F                  <1>     pop     ds
   273                              <1> 
   274                              <1> .write_loop:
   275                              <1>     ; Wait ready
   276 000016F6 1E                  <1>     push    ds
   277 000016F7 0E                  <1>     push    cs
   278 000016F8 1F                  <1>     pop     ds
   279 000016F9 E840F2              <1>     call    wait_drive_ready
   280 000016FC 1F                  <1>     pop     ds
   281 000016FD 0F829100            <1>     jc      .timeout
   282                              <1> 
   283                              <1>     ; Set up task file for LBA write
   284 00001701 1E                  <1>     push    ds
   285 00001702 0E                  <1>     push    cs
   286 00001703 1F                  <1>     pop     ds
   287                              <1> 
   288 00001704 A1[BA17]            <1>     mov     ax, [.lba_lo]
   289 00001707 8B1E[BC17]          <1>     mov     bx, [.lba_hi]
   290                              <1> 
   291 0000170B 8B16[C931]          <1>     mov     dx, [current_base]
   292 0000170F 83C202              <1>     add     dx, WD_SECCNT
   293 00001712 B001                <1>     mov     al, 1
   294 00001714 EE                  <1>     out     dx, al
   295                              <1> 
   296 00001715 A1[BA17]            <1>     mov     ax, [.lba_lo]
   297 00001718 42                  <1>     inc     dx
   298 00001719 EE                  <1>     out     dx, al
   299                              <1> 
   300 0000171A 88E0                <1>     mov     al, ah
   301 0000171C 42                  <1>     inc     dx
   302 0000171D EE                  <1>     out     dx, al
   303                              <1> 
   304 0000171E A0[BC17]            <1>     mov     al, [.lba_hi]
   305 00001721 42                  <1>     inc     dx
   306 00001722 EE                  <1>     out     dx, al
   307                              <1> 
   308 00001723 A0[BD17]            <1>     mov     al, [.lba_hi + 1]
   309 00001726 240F                <1>     and     al, 0x0F
   310 00001728 0CE0                <1>     or      al, SDH_SIZE_512 | SDH_LBA
   311 0000172A 8A5EFE              <1>     mov     bl, [bp - 2]
   312 0000172D 80FB81              <1>     cmp     bl, 0x81
   313 00001730 7502                <1>     jne     .not_drv1
   314 00001732 0C10                <1>     or      al, SDH_DRV1
   315                              <1> .not_drv1:
   316 00001734 42                  <1>     inc     dx
   317 00001735 EE                  <1>     out     dx, al
   318                              <1> 
   319                              <1>     ; Issue WRITE command
   320 00001736 8B16[C931]          <1>     mov     dx, [current_base]
   321 0000173A 83C207              <1>     add     dx, WD_COMMAND
   322 0000173D B030                <1>     mov     al, CMD_WRITE
   323 0000173F EE                  <1>     out     dx, al
   324                              <1> 
   325                              <1>     ; Wait for DRQ
   326 00001740 E8B8F5              <1>     call    wd_wait_drq
   327 00001743 1F                  <1>     pop     ds                      ; Restore buffer DS
   328 00001744 7258                <1>     jc      .write_error
   329                              <1> 
   330                              <1>     ; Write 256 words
   331 00001746 0E                  <1>     push    cs
   332 00001747 2E8B16[C931]        <1>     mov     dx, [cs:current_base]
   333 0000174C 83C200              <1>     add     dx, WD_DATA
   334 0000174F B90001              <1>     mov     cx, 256
   335 00001752 F36F                <1>     rep outsw
   336 00001754 1F                  <1>     pop     ds                      ; Dummy pop to balance
   337                              <1> 
   338                              <1>     ; Wait for BSY clear
   339 00001755 0E                  <1>     push    cs
   340 00001756 1F                  <1>     pop     ds
   341 00001757 E8BCF5              <1>     call    wd_wait_not_busy
   342 0000175A 7236                <1>     jc      .timeout
   343                              <1> 
   344                              <1>     ; Increment done
   345 0000175C FF06[B117]          <1>     inc     word [.done]
   346                              <1> 
   347                              <1>     ; Increment LBA
   348 00001760 8306[BA17]01        <1>     add     word [.lba_lo], 1
   349 00001765 8316[BC17]00        <1>     adc     word [.lba_hi], 0
   350                              <1> 
   351                              <1>     ; Restore buffer DS for next iteration
   352 0000176A C57604              <1>     lds     si, [bp + DAP.buffer]
   353 0000176D 2E0336[B117]        <1>     add     si, [cs:.done]
   354 00001772 C1E609              <1>     shl     si, 9                   ; * 512
   355                              <1>     ; Actually need to recalculate properly...
   356                              <1> 
   357 00001775 2EA1[B117]          <1>     mov     ax, [cs:.done]
   358 00001779 2E3B06[BE17]        <1>     cmp     ax, [cs:.count]
   359 0000177E 0F8274FF            <1>     jb      .write_loop
   360                              <1> 
   361                              <1> .success:
   362 00001782 0E                  <1>     push    cs
   363 00001783 1F                  <1>     pop     ds
   364 00001784 A1[B117]            <1>     mov     ax, [.done]
   365 00001787 894602              <1>     mov     [bp + DAP.count], ax
   366 0000178A B400                <1>     mov     ah, ST_SUCCESS
   367 0000178C EB23                <1>     jmp     .done
   368                              <1> 
   369                              <1> .invalid_dap:
   370 0000178E B401                <1>     mov     ah, ST_BAD_COMMAND
   371 00001790 EB1F                <1>     jmp     .done
   372                              <1> 
   373                              <1> .timeout:
   374 00001792 0E                  <1>     push    cs
   375 00001793 1F                  <1>     pop     ds
   376 00001794 A1[C017]            <1>     mov     ax, [.sectors_done]
   377 00001797 894602              <1>     mov     [bp + DAP.count], ax
   378 0000179A B480                <1>     mov     ah, ST_TIMEOUT
   379 0000179C EB13                <1>     jmp     .done
   380                              <1> 
   381                              <1> .write_error:
   382 0000179E 0E                  <1>     push    cs
   383 0000179F 1F                  <1>     pop     ds
   384 000017A0 A1[C017]            <1>     mov     ax, [.sectors_done]
   385 000017A3 894602              <1>     mov     [bp + DAP.count], ax
   386 000017A6 8B16[C931]          <1>     mov     dx, [current_base]
   387 000017AA 83C201              <1>     add     dx, WD_ERROR
   388 000017AD EC                  <1>     in      al, dx
   389 000017AE E87AF4              <1>     call    translate_error
   390                              <1> 
   391                              <1> .done:
   392 000017B1 1F                  <1>     pop     ds
   393 000017B2 07                  <1>     pop     es
   394 000017B3 5D                  <1>     pop     bp
   395 000017B4 5F                  <1>     pop     di
   396 000017B5 5E                  <1>     pop     si
   397 000017B6 5A                  <1>     pop     dx
   398 000017B7 59                  <1>     pop     cx
   399 000017B8 5B                  <1>     pop     bx
   400 000017B9 C3                  <1>     ret
   401                              <1> 
   402 000017BA 0000                <1> .lba_lo:        dw 0
   403 000017BC 0000                <1> .lba_hi:        dw 0
   404 000017BE 0000                <1> .count:         dw 0
   405 000017C0 0000                <1> .sectors_done:  dw 0
   406                              <1> 
   407                              <1> ;==============================================================================
   408                              <1> ; Function 44h: Extended Verify
   409                              <1> ;==============================================================================
   410                              <1> ; Verifies sectors using LBA addressing.
   411                              <1> ;
   412                              <1> ; Input:  Same as Extended Read
   413                              <1> ; Output: AH = status
   414                              <1> ;==============================================================================
   415                              <1> int13h_ext_verify:
   416 000017C2 53                  <1>     push    bx
   417 000017C3 51                  <1>     push    cx
   418 000017C4 52                  <1>     push    dx
   419 000017C5 56                  <1>     push    si
   420 000017C6 55                  <1>     push    bp
   421                              <1> 
   422                              <1>     ; Validate DAP
   423 000017C7 89F5                <1>     mov     bp, si
   424 000017C9 803C10              <1>     cmp     byte [si], DAP_SIZE_BASIC
   425 000017CC 0F828A00            <1>     jb      .invalid_dap
   426                              <1> 
   427 000017D0 8B4C02              <1>     mov     cx, [si + DAP.count]
   428 000017D3 85C9                <1>     test    cx, cx
   429 000017D5 7479                <1>     jz      .success
   430                              <1> 
   431                              <1>     ; Get LBA
   432 000017D7 8B4408              <1>     mov     ax, [si + DAP.lba]
   433 000017DA 8B5C0A              <1>     mov     bx, [si + DAP.lba + 2]
   434 000017DD A3[7F18]            <1>     mov     [.lba_lo], ax
   435 000017E0 891E[8118]          <1>     mov     [.lba_hi], bx
   436 000017E4 890E[8318]          <1>     mov     [.count], cx
   437 000017E8 C706[8518]0000      <1>     mov     word [.verify_sect_done], 0
   438                              <1> 
   439 000017EE E833F1              <1>     call    select_drive
   440                              <1> 
   441                              <1> .verify_loop:
   442 000017F1 E848F1              <1>     call    wait_drive_ready
   443 000017F4 7268                <1>     jc      .timeout
   444                              <1> 
   445                              <1>     ; Set up LBA
   446 000017F6 A1[7F18]            <1>     mov     ax, [.lba_lo]
   447 000017F9 8B1E[8118]          <1>     mov     bx, [.lba_hi]
   448                              <1> 
   449 000017FD 8B16[C931]          <1>     mov     dx, [current_base]
   450 00001801 83C202              <1>     add     dx, WD_SECCNT
   451 00001804 B001                <1>     mov     al, 1
   452 00001806 EE                  <1>     out     dx, al
   453                              <1> 
   454 00001807 A1[7F18]            <1>     mov     ax, [.lba_lo]
   455 0000180A 42                  <1>     inc     dx
   456 0000180B EE                  <1>     out     dx, al
   457 0000180C 88E0                <1>     mov     al, ah
   458 0000180E 42                  <1>     inc     dx
   459 0000180F EE                  <1>     out     dx, al
   460 00001810 A0[8118]            <1>     mov     al, [.lba_hi]
   461 00001813 42                  <1>     inc     dx
   462 00001814 EE                  <1>     out     dx, al
   463                              <1> 
   464 00001815 A0[8218]            <1>     mov     al, [.lba_hi + 1]
   465 00001818 240F                <1>     and     al, 0x0F
   466 0000181A 0CE0                <1>     or      al, SDH_SIZE_512 | SDH_LBA
   467 0000181C 42                  <1>     inc     dx
   468 0000181D EE                  <1>     out     dx, al
   469                              <1> 
   470                              <1>     ; Issue VERIFY command
   471 0000181E 8B16[C931]          <1>     mov     dx, [current_base]
   472 00001822 83C207              <1>     add     dx, WD_COMMAND
   473 00001825 B040                <1>     mov     al, CMD_VERIFY
   474 00001827 EE                  <1>     out     dx, al
   475                              <1> 
   476 00001828 E8EBF4              <1>     call    wd_wait_not_busy
   477 0000182B 7231                <1>     jc      .timeout
   478                              <1> 
   479                              <1>     ; Check for error
   480 0000182D 8B16[C931]          <1>     mov     dx, [current_base]
   481 00001831 83C207              <1>     add     dx, WD_STATUS
   482 00001834 EC                  <1>     in      al, dx
   483 00001835 A801                <1>     test    al, STS_ERR
   484 00001837 752F                <1>     jnz     .verify_error
   485                              <1> 
   486 00001839 FF06[7918]          <1>     inc     word [.done]
   487 0000183D 8306[7F18]01        <1>     add     word [.lba_lo], 1
   488 00001842 8316[8118]00        <1>     adc     word [.lba_hi], 0
   489                              <1> 
   490 00001847 A1[7918]            <1>     mov     ax, [.done]
   491 0000184A 3B06[8318]          <1>     cmp     ax, [.count]
   492 0000184E 72A1                <1>     jb      .verify_loop
   493                              <1> 
   494                              <1> .success:
   495 00001850 A1[8518]            <1>     mov     ax, [.verify_sect_done]
   496 00001853 894602              <1>     mov     [bp + DAP.count], ax
   497 00001856 B400                <1>     mov     ah, ST_SUCCESS
   498 00001858 EB1F                <1>     jmp     .done
   499                              <1> 
   500                              <1> .invalid_dap:
   501 0000185A B401                <1>     mov     ah, ST_BAD_COMMAND
   502 0000185C EB1B                <1>     jmp     .done
   503                              <1> 
   504                              <1> .timeout:
   505 0000185E A1[8518]            <1>     mov     ax, [.verify_sect_done]
   506 00001861 894602              <1>     mov     [bp + DAP.count], ax
   507 00001864 B480                <1>     mov     ah, ST_TIMEOUT
   508 00001866 EB11                <1>     jmp     .done
   509                              <1> 
   510                              <1> .verify_error:
   511 00001868 A1[8518]            <1>     mov     ax, [.verify_sect_done]
   512 0000186B 894602              <1>     mov     [bp + DAP.count], ax
   513 0000186E 8B16[C931]          <1>     mov     dx, [current_base]
   514 00001872 83C201              <1>     add     dx, WD_ERROR
   515 00001875 EC                  <1>     in      al, dx
   516 00001876 E8B2F3              <1>     call    translate_error
   517                              <1> 
   518                              <1> .done:
   519 00001879 5D                  <1>     pop     bp
   520 0000187A 5E                  <1>     pop     si
   521 0000187B 5A                  <1>     pop     dx
   522 0000187C 59                  <1>     pop     cx
   523 0000187D 5B                  <1>     pop     bx
   524 0000187E C3                  <1>     ret
   525                              <1> 
   526 0000187F 0000                <1> .lba_lo:            dw 0
   527 00001881 0000                <1> .lba_hi:            dw 0
   528 00001883 0000                <1> .count:             dw 0
   529 00001885 0000                <1> .verify_sect_done:  dw 0
   530                              <1> 
   531                              <1> ;==============================================================================
   532                              <1> ; Function 47h: Extended Seek
   533                              <1> ;==============================================================================
   534                              <1> ; Seeks to LBA position.
   535                              <1> ;
   536                              <1> ; Input:  DS:SI = DAP with target LBA
   537                              <1> ; Output: AH = status
   538                              <1> ;==============================================================================
   539                              <1> int13h_ext_seek:
   540 00001887 53                  <1>     push    bx
   541 00001888 51                  <1>     push    cx
   542 00001889 52                  <1>     push    dx
   543                              <1> 
   544                              <1>     ; Validate DAP
   545 0000188A 803C10              <1>     cmp     byte [si], DAP_SIZE_BASIC
   546 0000188D 724F                <1>     jb      .invalid_dap
   547                              <1> 
   548                              <1>     ; Get LBA
   549 0000188F 8B4408              <1>     mov     ax, [si + DAP.lba]
   550 00001892 8B5C0A              <1>     mov     bx, [si + DAP.lba + 2]
   551                              <1> 
   552 00001895 E88CF0              <1>     call    select_drive
   553 00001898 E8A1F0              <1>     call    wait_drive_ready
   554 0000189B 7245                <1>     jc      .timeout
   555                              <1> 
   556                              <1>     ; Set up LBA in task file
   557 0000189D 8B16[C931]          <1>     mov     dx, [current_base]
   558 000018A1 83C203              <1>     add     dx, WD_SECNUM
   559 000018A4 EE                  <1>     out     dx, al
   560                              <1> 
   561 000018A5 88E0                <1>     mov     al, ah
   562 000018A7 42                  <1>     inc     dx
   563 000018A8 EE                  <1>     out     dx, al
   564                              <1> 
   565 000018A9 88D8                <1>     mov     al, bl
   566 000018AB 42                  <1>     inc     dx
   567 000018AC EE                  <1>     out     dx, al
   568                              <1> 
   569 000018AD 88F8                <1>     mov     al, bh
   570 000018AF 240F                <1>     and     al, 0x0F
   571 000018B1 0CE0                <1>     or      al, SDH_SIZE_512 | SDH_LBA
   572 000018B3 42                  <1>     inc     dx
   573 000018B4 EE                  <1>     out     dx, al
   574                              <1> 
   575                              <1>     ; Issue SEEK command
   576 000018B5 8B16[C931]          <1>     mov     dx, [current_base]
   577 000018B9 83C207              <1>     add     dx, WD_COMMAND
   578 000018BC B070                <1>     mov     al, CMD_SEEK
   579 000018BE EE                  <1>     out     dx, al
   580                              <1> 
   581                              <1>     ; Wait for seek complete
   582 000018BF 8B16[C931]          <1>     mov     dx, [current_base]
   583 000018C3 83C207              <1>     add     dx, WD_STATUS
   584 000018C6 B9FFFF              <1>     mov     cx, TIMEOUT_SEEK
   585                              <1> 
   586                              <1> .wait_seek:
   587 000018C9 EC                  <1>     in      al, dx
   588 000018CA A880                <1>     test    al, STS_BSY
   589 000018CC 7504                <1>     jnz     .cont
   590 000018CE A810                <1>     test    al, STS_DSC
   591 000018D0 7504                <1>     jnz     .seek_done
   592                              <1> .cont:
   593 000018D2 E2F5                <1>     loop    .wait_seek
   594 000018D4 EB0C                <1>     jmp     .timeout
   595                              <1> 
   596                              <1> .seek_done:
   597 000018D6 A801                <1>     test    al, STS_ERR
   598 000018D8 750C                <1>     jnz     .error
   599                              <1> 
   600 000018DA B400                <1>     mov     ah, ST_SUCCESS
   601 000018DC EB0A                <1>     jmp     .done
   602                              <1> 
   603                              <1> .invalid_dap:
   604 000018DE B401                <1>     mov     ah, ST_BAD_COMMAND
   605 000018E0 EB06                <1>     jmp     .done
   606                              <1> 
   607                              <1> .timeout:
   608 000018E2 B480                <1>     mov     ah, ST_TIMEOUT
   609 000018E4 EB02                <1>     jmp     .done
   610                              <1> 
   611                              <1> .error:
   612 000018E6 B440                <1>     mov     ah, ST_SEEK_ERROR
   613                              <1> 
   614                              <1> .done:
   615 000018E8 5A                  <1>     pop     dx
   616 000018E9 59                  <1>     pop     cx
   617 000018EA 5B                  <1>     pop     bx
   618 000018EB C3                  <1>     ret
   619                              <1> 
   620                              <1> ;==============================================================================
   621                              <1> ; Function 48h: Get Extended Drive Parameters
   622                              <1> ;==============================================================================
   623                              <1> ; Returns extended drive geometry and size.
   624                              <1> ;
   625                              <1> ; Input:  DL = drive
   626                              <1> ;         DS:SI = buffer for result
   627                              <1> ; Output: Buffer filled with EXT_PARAMS structure
   628                              <1> ;         AH = status
   629                              <1> ;==============================================================================
   630                              <1> int13h_get_ext_params:
   631 000018EC 53                  <1>     push    bx
   632 000018ED 51                  <1>     push    cx
   633 000018EE 52                  <1>     push    dx
   634 000018EF 57                  <1>     push    di
   635 000018F0 06                  <1>     push    es
   636                              <1> 
   637                              <1>     ; Get drive parameters
   638 000018F1 E8FCEF              <1>     call    get_drive_params
   639 000018F4 726E                <1>     jc      .invalid_drive
   640                              <1> 
   641                              <1>     ; Set up ES:DI for output
   642 000018F6 1E                  <1>     push    ds
   643 000018F7 07                  <1>     pop     es
   644 000018F8 89F7                <1>     mov     di, si
   645                              <1> 
   646                              <1>     ; Check buffer size
   647 000018FA 8B04                <1>     mov     ax, [si]
   648 000018FC 83F81A              <1>     cmp     ax, 1Ah                 ; Minimum size
   649 000018FF 7267                <1>     jb      .buffer_too_small
   650                              <1> 
   651                              <1>     ; Fill structure
   652 00001901 C7051A00            <1>     mov     word [di + EXT_PARAMS.size], 1Ah
   653 00001905 C745020000          <1>     mov     word [di + EXT_PARAMS.flags], 0
   654                              <1> 
   655                              <1>     ; Cylinders (32-bit)
   656 0000190A 8B04                <1>     mov     ax, [si + 0]            ; From drive params (note: SI still points there)
   657 0000190C 56                  <1>     push    si
   658 0000190D E8E0EF              <1>     call    get_drive_params        ; Get fresh pointer
   659 00001910 8B04                <1>     mov     ax, [si]                ; Cylinders
   660 00001912 894504              <1>     mov     [di + EXT_PARAMS.cylinders], ax
   661 00001915 C745060000          <1>     mov     word [di + EXT_PARAMS.cylinders + 2], 0
   662                              <1> 
   663                              <1>     ; Heads (32-bit)
   664 0000191A 30E4                <1>     xor     ah, ah
   665 0000191C 8A4402              <1>     mov     al, [si + 2]
   666 0000191F 894508              <1>     mov     [di + EXT_PARAMS.heads], ax
   667 00001922 C7450A0000          <1>     mov     word [di + EXT_PARAMS.heads + 2], 0
   668                              <1> 
   669                              <1>     ; Sectors per track (32-bit)
   670 00001927 8A4403              <1>     mov     al, [si + 3]
   671 0000192A 89450C              <1>     mov     [di + EXT_PARAMS.sectors], ax
   672 0000192D C7450E0000          <1>     mov     word [di + EXT_PARAMS.sectors + 2], 0
   673                              <1> 
   674                              <1>     ; Total sectors (64-bit) - calculate C*H*S
   675 00001932 8B04                <1>     mov     ax, [si]                ; Cylinders
   676 00001934 30FF                <1>     xor     bh, bh
   677 00001936 8A5C02              <1>     mov     bl, [si + 2]            ; Heads
   678 00001939 F7E3                <1>     mul     bx                      ; DX:AX = C*H
   679                              <1> 
   680 0000193B 30FF                <1>     xor     bh, bh
   681 0000193D 8A5C03              <1>     mov     bl, [si + 3]            ; Sectors
   682                              <1>     ; 32-bit * 8-bit
   683 00001940 52                  <1>     push    dx
   684 00001941 F7E3                <1>     mul     bx                      ; AX = low * sectors
   685 00001943 89C1                <1>     mov     cx, ax
   686 00001945 58                  <1>     pop     ax
   687 00001946 52                  <1>     push    dx
   688 00001947 F7E3                <1>     mul     bx
   689 00001949 5B                  <1>     pop     bx
   690 0000194A 01D8                <1>     add     ax, bx
   691                              <1> 
   692 0000194C 894D10              <1>     mov     [di + EXT_PARAMS.total_sectors], cx
   693 0000194F 894512              <1>     mov     [di + EXT_PARAMS.total_sectors + 2], ax
   694 00001952 66C7451400000000    <1>     mov     dword [di + EXT_PARAMS.total_sectors + 4], 0
   695                              <1> 
   696                              <1>     ; Bytes per sector
   697 0000195A C745180002          <1>     mov     word [di + EXT_PARAMS.bytes_sector], 512
   698                              <1> 
   699 0000195F 5E                  <1>     pop     si
   700 00001960 B400                <1>     mov     ah, ST_SUCCESS
   701 00001962 EB06                <1>     jmp     .done
   702                              <1> 
   703                              <1> .invalid_drive:
   704 00001964 B401                <1>     mov     ah, ST_BAD_COMMAND
   705 00001966 EB02                <1>     jmp     .done
   706                              <1> 
   707                              <1> .buffer_too_small:
   708 00001968 B401                <1>     mov     ah, ST_BAD_COMMAND
   709                              <1> 
   710                              <1> .done:
   711 0000196A 07                  <1>     pop     es
   712 0000196B 5F                  <1>     pop     di
   713 0000196C 5A                  <1>     pop     dx
   714 0000196D 59                  <1>     pop     cx
   715 0000196E 5B                  <1>     pop     bx
   716 0000196F C3                  <1>     ret
   717                              <1> 
   718                              <1> %endif ; ENABLE_LBA
   226                                  %include "video.asm"
     1                              <1> ;==============================================================================
     2                              <1> ; FluxRipper HDD BIOS - Video Output Routines
     3                              <1> ;==============================================================================
     4                              <1> ; Enhanced video routines for diagnostics display.
     5                              <1> ;
     6                              <1> ; Features:
     7                              <1> ;   - Direct video memory access (faster than BIOS)
     8                              <1> ;   - Box drawing with single/double lines
     9                              <1> ;   - Progress bars
    10                              <1> ;   - Color attributes
    11                              <1> ;   - Cursor positioning
    12                              <1> ;
    13                              <1> ; SPDX-License-Identifier: BSD-3-Clause
    14                              <1> ; Copyright (c) 2025 FluxRipper Project
    15                              <1> ;==============================================================================
    16                              <1> 
    17                              <1> %if BUILD_16KB
    18                              <1> 
    19                              <1> ;==============================================================================
    20                              <1> ; Video Constants
    21                              <1> ;==============================================================================
    22                              <1> %define VIDEO_SEG       0xB800      ; Color text mode segment
    23                              <1> %define VIDEO_MONO_SEG  0xB000      ; Monochrome segment
    24                              <1> %define SCREEN_WIDTH    80
    25                              <1> %define SCREEN_HEIGHT   25
    26                              <1> 
    27                              <1> ; Color attributes
    28                              <1> %define ATTR_NORMAL     0x07        ; Light gray on black
    29                              <1> %define ATTR_BRIGHT     0x0F        ; White on black
    30                              <1> %define ATTR_INVERSE    0x70        ; Black on light gray
    31                              <1> %define ATTR_TITLE      0x1F        ; White on blue
    32                              <1> %define ATTR_ERROR      0x4F        ; White on red
    33                              <1> %define ATTR_SUCCESS    0x2F        ; White on green
    34                              <1> %define ATTR_HIGHLIGHT  0x0E        ; Yellow on black
    35                              <1> %define ATTR_DIM        0x08        ; Dark gray on black
    36                              <1> 
    37                              <1> ; Box drawing characters (code page 437)
    38                              <1> %define BOX_TL          0xC9        ; Top-left double
    39                              <1> %define BOX_TR          0xBB        ; Top-right double
    40                              <1> %define BOX_BL          0xC8        ; Bottom-left double
    41                              <1> %define BOX_BR          0xBC        ; Bottom-right double
    42                              <1> %define BOX_H           0xCD        ; Horizontal double
    43                              <1> %define BOX_V           0xBA        ; Vertical double
    44                              <1> %define BOX_TL_S        0xDA        ; Top-left single
    45                              <1> %define BOX_TR_S        0xBF        ; Top-right single
    46                              <1> %define BOX_BL_S        0xC0        ; Bottom-left single
    47                              <1> %define BOX_BR_S        0xD9        ; Bottom-right single
    48                              <1> %define BOX_H_S         0xC4        ; Horizontal single
    49                              <1> %define BOX_V_S         0xB3        ; Vertical single
    50                              <1> 
    51                              <1> ; Progress bar characters
    52                              <1> %define PROG_FULL       0xDB        ; Full block
    53                              <1> %define PROG_HALF       0xDD        ; Right half block
    54                              <1> %define PROG_EMPTY      0xB0        ; Light shade
    55                              <1> 
    56                              <1> ;==============================================================================
    57                              <1> ; Video State
    58                              <1> ;==============================================================================
    59 00001970 00B8                <1> video_seg:      dw VIDEO_SEG        ; Current video segment
    60 00001972 00                  <1> cursor_row:     db 0                ; Saved cursor row
    61 00001973 00                  <1> cursor_col:     db 0                ; Saved cursor column
    62 00001974 07                  <1> current_attr:   db ATTR_NORMAL      ; Current attribute
    63                              <1> 
    64                              <1> ;==============================================================================
    65                              <1> ; Initialize Video
    66                              <1> ;==============================================================================
    67                              <1> ; Detects video type and sets up segment.
    68                              <1> ;
    69                              <1> ; Output: video_seg set to appropriate segment
    70                              <1> ; Destroys: AX
    71                              <1> ;==============================================================================
    72                              <1> video_init:
    73 00001975 06                  <1>     push    es
    74 00001976 57                  <1>     push    di
    75                              <1> 
    76                              <1>     ; Check for color or mono adapter
    77 00001977 B84000              <1>     mov     ax, 0x0040
    78 0000197A 8EC0                <1>     mov     es, ax
    79 0000197C 26A04900            <1>     mov     al, [es:0x0049]         ; Current video mode
    80                              <1> 
    81 00001980 3C07                <1>     cmp     al, 7                   ; Mode 7 = mono
    82 00001982 7408                <1>     je      .mono
    83                              <1> 
    84 00001984 C706[7019]00B8      <1>     mov     word [video_seg], VIDEO_SEG
    85 0000198A EB06                <1>     jmp     .done
    86                              <1> 
    87                              <1> .mono:
    88 0000198C C706[7019]00B0      <1>     mov     word [video_seg], VIDEO_MONO_SEG
    89                              <1> 
    90                              <1> .done:
    91 00001992 5F                  <1>     pop     di
    92 00001993 07                  <1>     pop     es
    93 00001994 C3                  <1>     ret
    94                              <1> 
    95                              <1> ;==============================================================================
    96                              <1> ; Set Cursor Position
    97                              <1> ;==============================================================================
    98                              <1> ; Input:  DH = row (0-24)
    99                              <1> ;         DL = column (0-79)
   100                              <1> ; Destroys: AX, BX
   101                              <1> ;==============================================================================
   102                              <1> video_set_cursor:
   103 00001995 50                  <1>     push    ax
   104 00001996 53                  <1>     push    bx
   105                              <1> 
   106 00001997 B402                <1>     mov     ah, 0x02                ; Set cursor position
   107 00001999 30FF                <1>     xor     bh, bh                  ; Page 0
   108 0000199B CD10                <1>     int     0x10
   109                              <1> 
   110 0000199D 5B                  <1>     pop     bx
   111 0000199E 58                  <1>     pop     ax
   112 0000199F C3                  <1>     ret
   113                              <1> 
   114                              <1> ;==============================================================================
   115                              <1> ; Get Cursor Position
   116                              <1> ;==============================================================================
   117                              <1> ; Output: DH = row, DL = column
   118                              <1> ; Destroys: AX, BX, CX
   119                              <1> ;==============================================================================
   120                              <1> video_get_cursor:
   121 000019A0 50                  <1>     push    ax
   122 000019A1 53                  <1>     push    bx
   123 000019A2 51                  <1>     push    cx
   124                              <1> 
   125 000019A3 B403                <1>     mov     ah, 0x03
   126 000019A5 30FF                <1>     xor     bh, bh
   127 000019A7 CD10                <1>     int     0x10
   128                              <1> 
   129 000019A9 59                  <1>     pop     cx
   130 000019AA 5B                  <1>     pop     bx
   131 000019AB 58                  <1>     pop     ax
   132 000019AC C3                  <1>     ret
   133                              <1> 
   134                              <1> ;==============================================================================
   135                              <1> ; Save Cursor
   136                              <1> ;==============================================================================
   137                              <1> video_save_cursor:
   138 000019AD 52                  <1>     push    dx
   139 000019AE E8EFFF              <1>     call    video_get_cursor
   140 000019B1 8836[7219]          <1>     mov     [cursor_row], dh
   141 000019B5 8816[7319]          <1>     mov     [cursor_col], dl
   142 000019B9 5A                  <1>     pop     dx
   143 000019BA C3                  <1>     ret
   144                              <1> 
   145                              <1> ;==============================================================================
   146                              <1> ; Restore Cursor
   147                              <1> ;==============================================================================
   148                              <1> video_restore_cursor:
   149 000019BB 52                  <1>     push    dx
   150 000019BC 8A36[7219]          <1>     mov     dh, [cursor_row]
   151 000019C0 8A16[7319]          <1>     mov     dl, [cursor_col]
   152 000019C4 E8CEFF              <1>     call    video_set_cursor
   153 000019C7 5A                  <1>     pop     dx
   154 000019C8 C3                  <1>     ret
   155                              <1> 
   156                              <1> ;==============================================================================
   157                              <1> ; Clear Screen
   158                              <1> ;==============================================================================
   159                              <1> ; Clears screen with current attribute.
   160                              <1> ;
   161                              <1> ; Destroys: AX, BX, CX, DX
   162                              <1> ;==============================================================================
   163                              <1> video_clear_screen:
   164 000019C9 B406                <1>     mov     ah, 0x06                ; Scroll up
   165 000019CB 30C0                <1>     xor     al, al                  ; Clear entire window
   166 000019CD 8A3E[7419]          <1>     mov     bh, [current_attr]      ; Attribute for blank
   167 000019D1 31C9                <1>     xor     cx, cx                  ; Upper left (0,0)
   168 000019D3 BA4F18              <1>     mov     dx, 0x184F              ; Lower right (24,79)
   169 000019D6 CD10                <1>     int     0x10
   170                              <1> 
   171                              <1>     ; Home cursor
   172 000019D8 31D2                <1>     xor     dx, dx
   173 000019DA E8B8FF              <1>     call    video_set_cursor
   174 000019DD C3                  <1>     ret
   175                              <1> 
   176                              <1> ;==============================================================================
   177                              <1> ; Clear Line
   178                              <1> ;==============================================================================
   179                              <1> ; Clears current line from cursor to end.
   180                              <1> ;
   181                              <1> ; Destroys: AX, BX, CX, DX
   182                              <1> ;==============================================================================
   183                              <1> video_clear_line:
   184 000019DE 52                  <1>     push    dx
   185 000019DF E8BEFF              <1>     call    video_get_cursor
   186 000019E2 52                  <1>     push    dx                      ; Save cursor
   187                              <1> 
   188                              <1>     ; Clear from cursor to end of line
   189 000019E3 B409                <1>     mov     ah, 0x09                ; Write char with attr
   190 000019E5 B020                <1>     mov     al, ' '
   191 000019E7 B700                <1>     mov     bh, 0                   ; Page 0
   192 000019E9 8A1E[7419]          <1>     mov     bl, [current_attr]
   193 000019ED B95000              <1>     mov     cx, SCREEN_WIDTH
   194 000019F0 28D1                <1>     sub     cl, dl                  ; Remaining columns
   195 000019F2 CD10                <1>     int     0x10
   196                              <1> 
   197 000019F4 5A                  <1>     pop     dx
   198 000019F5 E89DFF              <1>     call    video_set_cursor
   199 000019F8 5A                  <1>     pop     dx
   200 000019F9 C3                  <1>     ret
   201                              <1> 
   202                              <1> ;==============================================================================
   203                              <1> ; Print Character at Position
   204                              <1> ;==============================================================================
   205                              <1> ; Input:  AL = character
   206                              <1> ;         DH = row
   207                              <1> ;         DL = column
   208                              <1> ;         AH = attribute (or 0 to use current)
   209                              <1> ; Destroys: BX, ES
   210                              <1> ;==============================================================================
   211                              <1> video_putc_at:
   212 000019FA 50                  <1>     push    ax
   213 000019FB 57                  <1>     push    di
   214 000019FC 06                  <1>     push    es
   215                              <1> 
   216                              <1>     ; Calculate offset: (row * 80 + col) * 2
   217 000019FD 50                  <1>     push    ax
   218 000019FE 88F0                <1>     mov     al, dh
   219 00001A00 B350                <1>     mov     bl, SCREEN_WIDTH
   220 00001A02 F6E3                <1>     mul     bl                      ; AX = row * 80
   221 00001A04 30FF                <1>     xor     bh, bh
   222 00001A06 88D3                <1>     mov     bl, dl
   223 00001A08 01D8                <1>     add     ax, bx                  ; AX = row * 80 + col
   224 00001A0A D1E0                <1>     shl     ax, 1                   ; AX = offset in video memory
   225 00001A0C 89C7                <1>     mov     di, ax
   226 00001A0E 58                  <1>     pop     ax
   227                              <1> 
   228                              <1>     ; Get video segment
   229 00001A0F 8E06[7019]          <1>     mov     es, [video_seg]
   230                              <1> 
   231                              <1>     ; Write character
   232 00001A13 268805              <1>     mov     [es:di], al
   233                              <1> 
   234                              <1>     ; Write attribute
   235 00001A16 84E4                <1>     test    ah, ah
   236 00001A18 7406                <1>     jz      .use_current
   237 00001A1A 26886501            <1>     mov     [es:di + 1], ah
   238 00001A1E EB07                <1>     jmp     .done
   239                              <1> 
   240                              <1> .use_current:
   241 00001A20 A0[7419]            <1>     mov     al, [current_attr]
   242 00001A23 26884501            <1>     mov     [es:di + 1], al
   243                              <1> 
   244                              <1> .done:
   245 00001A27 07                  <1>     pop     es
   246 00001A28 5F                  <1>     pop     di
   247 00001A29 58                  <1>     pop     ax
   248 00001A2A C3                  <1>     ret
   249                              <1> 
   250                              <1> ;==============================================================================
   251                              <1> ; Print String at Position
   252                              <1> ;==============================================================================
   253                              <1> ; Input:  DS:SI = null-terminated string
   254                              <1> ;         DH = starting row
   255                              <1> ;         DL = starting column
   256                              <1> ;         AH = attribute (or 0 for current)
   257                              <1> ; Destroys: AL, SI
   258                              <1> ;==============================================================================
   259                              <1> video_puts_at:
   260 00001A2B 50                  <1>     push    ax
   261 00001A2C 52                  <1>     push    dx
   262                              <1> 
   263 00001A2D 88E3                <1>     mov     bl, ah                  ; Save attribute
   264                              <1> 
   265                              <1> .loop:
   266 00001A2F AC                  <1>     lodsb
   267 00001A30 84C0                <1>     test    al, al
   268 00001A32 7412                <1>     jz      .done
   269                              <1> 
   270 00001A34 88DC                <1>     mov     ah, bl
   271 00001A36 E8C1FF              <1>     call    video_putc_at
   272 00001A39 FEC2                <1>     inc     dl                      ; Next column
   273 00001A3B 80FA50              <1>     cmp     dl, SCREEN_WIDTH
   274 00001A3E 72EF                <1>     jb      .loop
   275                              <1>     ; Wrap to next line
   276 00001A40 30D2                <1>     xor     dl, dl
   277 00001A42 FEC6                <1>     inc     dh
   278 00001A44 EBE9                <1>     jmp     .loop
   279                              <1> 
   280                              <1> .done:
   281 00001A46 5A                  <1>     pop     dx
   282 00001A47 58                  <1>     pop     ax
   283 00001A48 C3                  <1>     ret
   284                              <1> 
   285                              <1> ;==============================================================================
   286                              <1> ; Draw Box
   287                              <1> ;==============================================================================
   288                              <1> ; Draws a box with double-line border.
   289                              <1> ;
   290                              <1> ; Input:  DH = top row
   291                              <1> ;         DL = left column
   292                              <1> ;         CH = bottom row
   293                              <1> ;         CL = right column
   294                              <1> ;         AH = attribute
   295                              <1> ; Destroys: AL, BX
   296                              <1> ;==============================================================================
   297                              <1> video_draw_box:
   298 00001A49 51                  <1>     push    cx
   299 00001A4A 52                  <1>     push    dx
   300 00001A4B 56                  <1>     push    si
   301                              <1> 
   302 00001A4C 88E3                <1>     mov     bl, ah                  ; Save attribute
   303                              <1> 
   304                              <1>     ; Draw top-left corner
   305 00001A4E B0C9                <1>     mov     al, BOX_TL
   306 00001A50 88DC                <1>     mov     ah, bl
   307 00001A52 E8A5FF              <1>     call    video_putc_at
   308                              <1> 
   309                              <1>     ; Draw top line
   310 00001A55 52                  <1>     push    dx
   311 00001A56 FEC2                <1>     inc     dl
   312                              <1> .top_loop:
   313 00001A58 38CA                <1>     cmp     dl, cl
   314 00001A5A 7D0B                <1>     jge     .top_done
   315 00001A5C B0CD                <1>     mov     al, BOX_H
   316 00001A5E 88DC                <1>     mov     ah, bl
   317 00001A60 E897FF              <1>     call    video_putc_at
   318 00001A63 FEC2                <1>     inc     dl
   319 00001A65 EBF1                <1>     jmp     .top_loop
   320                              <1> .top_done:
   321 00001A67 5A                  <1>     pop     dx
   322                              <1> 
   323                              <1>     ; Draw top-right corner
   324 00001A68 52                  <1>     push    dx
   325 00001A69 88CA                <1>     mov     dl, cl
   326 00001A6B B0BB                <1>     mov     al, BOX_TR
   327 00001A6D 88DC                <1>     mov     ah, bl
   328 00001A6F E888FF              <1>     call    video_putc_at
   329 00001A72 5A                  <1>     pop     dx
   330                              <1> 
   331                              <1>     ; Draw sides
   332 00001A73 52                  <1>     push    dx
   333 00001A74 FEC6                <1>     inc     dh
   334                              <1> .side_loop:
   335 00001A76 38EE                <1>     cmp     dh, ch
   336 00001A78 7D12                <1>     jge     .side_done
   337                              <1> 
   338                              <1>     ; Left side
   339 00001A7A B0BA                <1>     mov     al, BOX_V
   340 00001A7C 88DC                <1>     mov     ah, bl
   341 00001A7E E879FF              <1>     call    video_putc_at
   342                              <1> 
   343                              <1>     ; Right side
   344 00001A81 52                  <1>     push    dx
   345 00001A82 88CA                <1>     mov     dl, cl
   346 00001A84 E873FF              <1>     call    video_putc_at
   347 00001A87 5A                  <1>     pop     dx
   348                              <1> 
   349 00001A88 FEC6                <1>     inc     dh
   350 00001A8A EBEA                <1>     jmp     .side_loop
   351                              <1> .side_done:
   352 00001A8C 5A                  <1>     pop     dx
   353                              <1> 
   354                              <1>     ; Draw bottom-left corner
   355 00001A8D 88EE                <1>     mov     dh, ch
   356 00001A8F B0C8                <1>     mov     al, BOX_BL
   357 00001A91 88DC                <1>     mov     ah, bl
   358 00001A93 E864FF              <1>     call    video_putc_at
   359                              <1> 
   360                              <1>     ; Draw bottom line
   361 00001A96 52                  <1>     push    dx
   362 00001A97 FEC2                <1>     inc     dl
   363                              <1> .bottom_loop:
   364 00001A99 38CA                <1>     cmp     dl, cl
   365 00001A9B 7D0B                <1>     jge     .bottom_done
   366 00001A9D B0CD                <1>     mov     al, BOX_H
   367 00001A9F 88DC                <1>     mov     ah, bl
   368 00001AA1 E856FF              <1>     call    video_putc_at
   369 00001AA4 FEC2                <1>     inc     dl
   370 00001AA6 EBF1                <1>     jmp     .bottom_loop
   371                              <1> .bottom_done:
   372 00001AA8 5A                  <1>     pop     dx
   373                              <1> 
   374                              <1>     ; Draw bottom-right corner
   375 00001AA9 88CA                <1>     mov     dl, cl
   376 00001AAB 88EE                <1>     mov     dh, ch
   377 00001AAD B0BC                <1>     mov     al, BOX_BR
   378 00001AAF 88DC                <1>     mov     ah, bl
   379 00001AB1 E846FF              <1>     call    video_putc_at
   380                              <1> 
   381 00001AB4 5E                  <1>     pop     si
   382 00001AB5 5A                  <1>     pop     dx
   383 00001AB6 59                  <1>     pop     cx
   384 00001AB7 C3                  <1>     ret
   385                              <1> 
   386                              <1> ;==============================================================================
   387                              <1> ; Draw Progress Bar
   388                              <1> ;==============================================================================
   389                              <1> ; Draws a progress bar.
   390                              <1> ;
   391                              <1> ; Input:  DH = row
   392                              <1> ;         DL = column
   393                              <1> ;         CL = width (in characters)
   394                              <1> ;         AL = percentage (0-100)
   395                              <1> ;         AH = attribute
   396                              <1> ; Destroys: BX
   397                              <1> ;==============================================================================
   398                              <1> video_progress_bar:
   399 00001AB8 50                  <1>     push    ax
   400 00001AB9 51                  <1>     push    cx
   401 00001ABA 52                  <1>     push    dx
   402                              <1> 
   403 00001ABB 88E3                <1>     mov     bl, ah                  ; Save attribute
   404 00001ABD 88C7                <1>     mov     bh, al                  ; Save percentage
   405                              <1> 
   406                              <1>     ; Calculate filled width: (percentage * width) / 100
   407 00001ABF 30E4                <1>     xor     ah, ah
   408 00001AC1 88F8                <1>     mov     al, bh                  ; Percentage
   409 00001AC3 F6E1                <1>     mul     cl                      ; AX = percentage * width
   410 00001AC5 B564                <1>     mov     ch, 100
   411 00001AC7 F6F5                <1>     div     ch                      ; AL = filled chars
   412                              <1> 
   413 00001AC9 88C5                <1>     mov     ch, al                  ; CH = filled count
   414                              <1> 
   415                              <1>     ; Draw filled portion
   416 00001ACB 30C9                <1>     xor     cl, cl                  ; Position counter
   417                              <1> 
   418                              <1> .fill_loop:
   419 00001ACD 38E9                <1>     cmp     cl, ch
   420 00001ACF 7D0D                <1>     jge     .empty_part
   421 00001AD1 B0DB                <1>     mov     al, PROG_FULL
   422 00001AD3 88DC                <1>     mov     ah, bl
   423 00001AD5 E822FF              <1>     call    video_putc_at
   424 00001AD8 FEC2                <1>     inc     dl
   425 00001ADA FEC1                <1>     inc     cl
   426 00001ADC EBEF                <1>     jmp     .fill_loop
   427                              <1> 
   428                              <1> .empty_part:
   429                              <1>     ; Draw empty portion
   430 00001ADE 5A                  <1>     pop     dx
   431 00001ADF 52                  <1>     push    dx
   432 00001AE0 00CA                <1>     add     dl, cl                  ; Current position
   433                              <1> 
   434                              <1>     ; Get remaining width
   435 00001AE2 8A46FA              <1>     mov     al, [bp - 6]            ; Original CL (width)
   436 00001AE5 28C8                <1>     sub     al, cl                  ; Remaining
   437                              <1> 
   438                              <1> .empty_loop:
   439 00001AE7 84C0                <1>     test    al, al
   440 00001AE9 740F                <1>     jz      .done
   441 00001AEB 50                  <1>     push    ax
   442 00001AEC B0B0                <1>     mov     al, PROG_EMPTY
   443 00001AEE 88DC                <1>     mov     ah, bl
   444 00001AF0 E807FF              <1>     call    video_putc_at
   445 00001AF3 58                  <1>     pop     ax
   446 00001AF4 FEC2                <1>     inc     dl
   447 00001AF6 FEC8                <1>     dec     al
   448 00001AF8 EBED                <1>     jmp     .empty_loop
   449                              <1> 
   450                              <1> .done:
   451 00001AFA 5A                  <1>     pop     dx
   452 00001AFB 59                  <1>     pop     cx
   453 00001AFC 58                  <1>     pop     ax
   454 00001AFD C3                  <1>     ret
   455                              <1> 
   456                              <1> ;==============================================================================
   457                              <1> ; Print Centered String
   458                              <1> ;==============================================================================
   459                              <1> ; Input:  DS:SI = string
   460                              <1> ;         DH = row
   461                              <1> ;         AH = attribute
   462                              <1> ; Destroys: AL, CX, DL, SI
   463                              <1> ;==============================================================================
   464                              <1> video_puts_centered:
   465 00001AFE 50                  <1>     push    ax
   466 00001AFF 53                  <1>     push    bx
   467 00001B00 56                  <1>     push    si
   468                              <1> 
   469 00001B01 88E3                <1>     mov     bl, ah                  ; Save attribute
   470                              <1> 
   471                              <1>     ; Calculate string length
   472 00001B03 56                  <1>     push    si
   473 00001B04 31C9                <1>     xor     cx, cx
   474                              <1> .len_loop:
   475 00001B06 AC                  <1>     lodsb
   476 00001B07 84C0                <1>     test    al, al
   477 00001B09 7403                <1>     jz      .len_done
   478 00001B0B 41                  <1>     inc     cx
   479 00001B0C EBF8                <1>     jmp     .len_loop
   480                              <1> .len_done:
   481 00001B0E 5E                  <1>     pop     si
   482                              <1> 
   483                              <1>     ; Calculate starting column
   484 00001B0F B85000              <1>     mov     ax, SCREEN_WIDTH
   485 00001B12 29C8                <1>     sub     ax, cx
   486 00001B14 D1E8                <1>     shr     ax, 1                   ; (80 - len) / 2
   487 00001B16 88C2                <1>     mov     dl, al
   488                              <1> 
   489                              <1>     ; Print string
   490 00001B18 88DC                <1>     mov     ah, bl
   491 00001B1A E80EFF              <1>     call    video_puts_at
   492                              <1> 
   493 00001B1D 5E                  <1>     pop     si
   494 00001B1E 5B                  <1>     pop     bx
   495 00001B1F 58                  <1>     pop     ax
   496 00001B20 C3                  <1>     ret
   497                              <1> 
   498                              <1> ;==============================================================================
   499                              <1> ; Set Attribute
   500                              <1> ;==============================================================================
   501                              <1> ; Input: AL = new attribute
   502                              <1> ;==============================================================================
   503                              <1> video_set_attr:
   504 00001B21 A2[7419]            <1>     mov     [current_attr], al
   505 00001B24 C3                  <1>     ret
   506                              <1> 
   507                              <1> %endif ; BUILD_16KB
   227                                  %include "keyboard.asm"
     1                              <1> ;==============================================================================
     2                              <1> ; FluxRipper HDD BIOS - Keyboard Input Routines
     3                              <1> ;==============================================================================
     4                              <1> ; Enhanced keyboard handling for menus and diagnostics.
     5                              <1> ;
     6                              <1> ; SPDX-License-Identifier: BSD-3-Clause
     7                              <1> ; Copyright (c) 2025 FluxRipper Project
     8                              <1> ;==============================================================================
     9                              <1> 
    10                              <1> %if BUILD_16KB
    11                              <1> 
    12                              <1> ;==============================================================================
    13                              <1> ; Keyboard Scan Codes
    14                              <1> ;==============================================================================
    15                              <1> %define KEY_ESC         0x01
    16                              <1> %define KEY_ENTER       0x1C
    17                              <1> %define KEY_SPACE       0x39
    18                              <1> %define KEY_UP          0x48
    19                              <1> %define KEY_DOWN        0x50
    20                              <1> %define KEY_LEFT        0x4B
    21                              <1> %define KEY_RIGHT       0x4D
    22                              <1> %define KEY_HOME        0x47
    23                              <1> %define KEY_END         0x4F
    24                              <1> %define KEY_PGUP        0x49
    25                              <1> %define KEY_PGDN        0x51
    26                              <1> 
    27                              <1> %define KEY_F1          0x3B
    28                              <1> %define KEY_F2          0x3C
    29                              <1> %define KEY_F3          0x3D
    30                              <1> %define KEY_F4          0x3E
    31                              <1> %define KEY_F5          0x3F
    32                              <1> %define KEY_F6          0x40
    33                              <1> %define KEY_F7          0x41
    34                              <1> %define KEY_F8          0x42
    35                              <1> %define KEY_F9          0x43
    36                              <1> %define KEY_F10         0x44
    37                              <1> 
    38                              <1> ;==============================================================================
    39                              <1> ; Check for Keypress
    40                              <1> ;==============================================================================
    41                              <1> ; Returns immediately whether a key is available.
    42                              <1> ;
    43                              <1> ; Output: ZF = 1 if no key, ZF = 0 if key available
    44                              <1> ;         If key available: AH = scan code, AL = ASCII
    45                              <1> ; Destroys: AX
    46                              <1> ;==============================================================================
    47                              <1> kbd_check:
    48 00001B25 B401                <1>     mov     ah, 0x01
    49 00001B27 CD16                <1>     int     0x16
    50 00001B29 C3                  <1>     ret
    51                              <1> 
    52                              <1> ;==============================================================================
    53                              <1> ; Get Key (Blocking)
    54                              <1> ;==============================================================================
    55                              <1> ; Waits for and returns a keypress.
    56                              <1> ;
    57                              <1> ; Output: AH = scan code
    58                              <1> ;         AL = ASCII code (0 if extended key)
    59                              <1> ; Destroys: Nothing else
    60                              <1> ;==============================================================================
    61                              <1> kbd_get:
    62 00001B2A B400                <1>     mov     ah, 0x00
    63 00001B2C CD16                <1>     int     0x16
    64 00001B2E C3                  <1>     ret
    65                              <1> 
    66                              <1> ;==============================================================================
    67                              <1> ; Get Key with Timeout
    68                              <1> ;==============================================================================
    69                              <1> ; Waits for key up to specified time.
    70                              <1> ;
    71                              <1> ; Input:  CX = timeout in ~55ms ticks (18.2 ticks/sec)
    72                              <1> ; Output: CF = 0 if key pressed, AH/AL = key
    73                              <1> ;         CF = 1 if timeout
    74                              <1> ; Destroys: AX, BX
    75                              <1> ;==============================================================================
    76                              <1> kbd_get_timeout:
    77 00001B2F 52                  <1>     push    dx
    78 00001B30 06                  <1>     push    es
    79                              <1> 
    80                              <1>     ; Get starting tick count
    81 00001B31 31C0                <1>     xor     ax, ax
    82 00001B33 8EC0                <1>     mov     es, ax
    83 00001B35 268B1E6C04          <1>     mov     bx, [es:0x046C]         ; BIOS tick counter
    84                              <1> 
    85                              <1> .wait_loop:
    86                              <1>     ; Check for key
    87 00001B3A B401                <1>     mov     ah, 0x01
    88 00001B3C CD16                <1>     int     0x16
    89 00001B3E 750E                <1>     jnz     .got_key
    90                              <1> 
    91                              <1>     ; Check timeout
    92 00001B40 268B166C04          <1>     mov     dx, [es:0x046C]
    93 00001B45 29DA                <1>     sub     dx, bx
    94 00001B47 39CA                <1>     cmp     dx, cx
    95 00001B49 72EF                <1>     jb      .wait_loop
    96                              <1> 
    97                              <1>     ; Timeout
    98 00001B4B F9                  <1>     stc
    99 00001B4C EB05                <1>     jmp     .done
   100                              <1> 
   101                              <1> .got_key:
   102                              <1>     ; Get the key
   103 00001B4E B400                <1>     mov     ah, 0x00
   104 00001B50 CD16                <1>     int     0x16
   105 00001B52 F8                  <1>     clc
   106                              <1> 
   107                              <1> .done:
   108 00001B53 07                  <1>     pop     es
   109 00001B54 5A                  <1>     pop     dx
   110 00001B55 C3                  <1>     ret
   111                              <1> 
   112                              <1> ;==============================================================================
   113                              <1> ; Flush Keyboard Buffer
   114                              <1> ;==============================================================================
   115                              <1> ; Removes all pending keystrokes.
   116                              <1> ;
   117                              <1> ; Destroys: AX
   118                              <1> ;==============================================================================
   119                              <1> kbd_flush:
   120                              <1> .flush_loop:
   121 00001B56 B401                <1>     mov     ah, 0x01
   122 00001B58 CD16                <1>     int     0x16
   123 00001B5A 7406                <1>     jz      .done
   124 00001B5C B400                <1>     mov     ah, 0x00
   125 00001B5E CD16                <1>     int     0x16
   126 00001B60 EBF4                <1>     jmp     .flush_loop
   127                              <1> .done:
   128 00001B62 C3                  <1>     ret
   129                              <1> 
   130                              <1> ;==============================================================================
   131                              <1> ; Get Yes/No Response
   132                              <1> ;==============================================================================
   133                              <1> ; Waits for Y or N keypress.
   134                              <1> ;
   135                              <1> ; Output: CF = 0 if Yes, CF = 1 if No
   136                              <1> ; Destroys: AX
   137                              <1> ;==============================================================================
   138                              <1> kbd_yes_no:
   139                              <1> .loop:
   140 00001B63 E8C4FF              <1>     call    kbd_get
   141 00001B66 0C20                <1>     or      al, 0x20                ; Convert to lowercase
   142                              <1> 
   143 00001B68 3C79                <1>     cmp     al, 'y'
   144 00001B6A 740B                <1>     je      .yes
   145 00001B6C 3C6E                <1>     cmp     al, 'n'
   146 00001B6E 7409                <1>     je      .no
   147                              <1> 
   148                              <1>     ; Invalid key - beep and retry
   149 00001B70 B8070E              <1>     mov     ax, 0x0E07              ; Beep
   150 00001B73 CD10                <1>     int     0x10
   151 00001B75 EBEC                <1>     jmp     .loop
   152                              <1> 
   153                              <1> .yes:
   154 00001B77 F8                  <1>     clc
   155 00001B78 C3                  <1>     ret
   156                              <1> 
   157                              <1> .no:
   158 00001B79 F9                  <1>     stc
   159 00001B7A C3                  <1>     ret
   160                              <1> 
   161                              <1> ;==============================================================================
   162                              <1> ; Get Number Input (1 digit)
   163                              <1> ;==============================================================================
   164                              <1> ; Waits for a digit key (0-9).
   165                              <1> ;
   166                              <1> ; Output: AL = digit value (0-9)
   167                              <1> ;         CF = 0 if valid, CF = 1 if ESC pressed
   168                              <1> ; Destroys: AH
   169                              <1> ;==============================================================================
   170                              <1> kbd_get_digit:
   171                              <1> .loop:
   172 00001B7B E8ACFF              <1>     call    kbd_get
   173                              <1> 
   174                              <1>     ; Check for ESC
   175 00001B7E 80FC01              <1>     cmp     ah, KEY_ESC
   176 00001B81 7413                <1>     je      .escape
   177                              <1> 
   178                              <1>     ; Check for digit
   179 00001B83 3C30                <1>     cmp     al, '0'
   180 00001B85 7208                <1>     jb      .invalid
   181 00001B87 3C39                <1>     cmp     al, '9'
   182 00001B89 7704                <1>     ja      .invalid
   183                              <1> 
   184                              <1>     ; Valid digit
   185 00001B8B 2C30                <1>     sub     al, '0'
   186 00001B8D F8                  <1>     clc
   187 00001B8E C3                  <1>     ret
   188                              <1> 
   189                              <1> .invalid:
   190 00001B8F B8070E              <1>     mov     ax, 0x0E07              ; Beep
   191 00001B92 CD10                <1>     int     0x10
   192 00001B94 EBE5                <1>     jmp     .loop
   193                              <1> 
   194                              <1> .escape:
   195 00001B96 F9                  <1>     stc
   196 00001B97 C3                  <1>     ret
   197                              <1> 
   198                              <1> ;==============================================================================
   199                              <1> ; Get Menu Selection
   200                              <1> ;==============================================================================
   201                              <1> ; Handles menu navigation with arrow keys.
   202                              <1> ;
   203                              <1> ; Input:  AL = current selection (0-based)
   204                              <1> ;         AH = max selection
   205                              <1> ; Output: AL = new selection
   206                              <1> ;         CF = 1 if ESC pressed
   207                              <1> ;         If ENTER: ZF = 1
   208                              <1> ; Destroys: AH
   209                              <1> ;==============================================================================
   210                              <1> kbd_menu_select:
   211 00001B98 53                  <1>     push    bx
   212                              <1> 
   213 00001B99 88C3                <1>     mov     bl, al                  ; Current selection
   214 00001B9B 88E7                <1>     mov     bh, ah                  ; Max selection
   215                              <1> 
   216                              <1> .loop:
   217 00001B9D E88AFF              <1>     call    kbd_get
   218                              <1> 
   219                              <1>     ; Check ESC
   220 00001BA0 80FC01              <1>     cmp     ah, KEY_ESC
   221 00001BA3 7447                <1>     je      .escape
   222                              <1> 
   223                              <1>     ; Check ENTER
   224 00001BA5 80FC1C              <1>     cmp     ah, KEY_ENTER
   225 00001BA8 743B                <1>     je      .enter
   226                              <1> 
   227                              <1>     ; Check UP
   228 00001BAA 80FC48              <1>     cmp     ah, KEY_UP
   229 00001BAD 7417                <1>     je      .up
   230                              <1> 
   231                              <1>     ; Check DOWN
   232 00001BAF 80FC50              <1>     cmp     ah, KEY_DOWN
   233 00001BB2 741E                <1>     je      .down
   234                              <1> 
   235                              <1>     ; Check digit keys
   236 00001BB4 3C30                <1>     cmp     al, '0'
   237 00001BB6 72E5                <1>     jb      .loop
   238 00001BB8 3C39                <1>     cmp     al, '9'
   239 00001BBA 77E1                <1>     ja      .loop
   240                              <1> 
   241                              <1>     ; Direct selection by number
   242 00001BBC 2C30                <1>     sub     al, '0'
   243 00001BBE 38F8                <1>     cmp     al, bh
   244 00001BC0 77DB                <1>     ja      .loop
   245 00001BC2 88C3                <1>     mov     bl, al
   246 00001BC4 EB1F                <1>     jmp     .enter
   247                              <1> 
   248                              <1> .up:
   249 00001BC6 84DB                <1>     test    bl, bl
   250 00001BC8 7404                <1>     jz      .wrap_up
   251 00001BCA FECB                <1>     dec     bl
   252 00001BCC EB10                <1>     jmp     .update
   253                              <1> 
   254                              <1> .wrap_up:
   255 00001BCE 88FB                <1>     mov     bl, bh                  ; Wrap to max
   256 00001BD0 EB0C                <1>     jmp     .update
   257                              <1> 
   258                              <1> .down:
   259 00001BD2 38FB                <1>     cmp     bl, bh
   260 00001BD4 7D04                <1>     jge     .wrap_down
   261 00001BD6 FEC3                <1>     inc     bl
   262 00001BD8 EB04                <1>     jmp     .update
   263                              <1> 
   264                              <1> .wrap_down:
   265 00001BDA 30DB                <1>     xor     bl, bl                  ; Wrap to 0
   266 00001BDC EB00                <1>     jmp     .update
   267                              <1> 
   268                              <1> .update:
   269 00001BDE 88D8                <1>     mov     al, bl
   270 00001BE0 F8                  <1>     clc
   271 00001BE1 0C01                <1>     or      al, 1                   ; Clear ZF
   272 00001BE3 EB0A                <1>     jmp     .done
   273                              <1> 
   274                              <1> .enter:
   275 00001BE5 88D8                <1>     mov     al, bl
   276 00001BE7 F8                  <1>     clc
   277 00001BE8 30E4                <1>     xor     ah, ah                  ; Set ZF
   278 00001BEA EB03                <1>     jmp     .done
   279                              <1> 
   280                              <1> .escape:
   281 00001BEC 88D8                <1>     mov     al, bl
   282 00001BEE F9                  <1>     stc
   283                              <1> 
   284                              <1> .done:
   285 00001BEF 5B                  <1>     pop     bx
   286 00001BF0 C3                  <1>     ret
   287                              <1> 
   288                              <1> ;==============================================================================
   289                              <1> ; Wait for Any Key
   290                              <1> ;==============================================================================
   291                              <1> ; Displays prompt and waits for keypress.
   292                              <1> ;
   293                              <1> ; Destroys: AX, SI
   294                              <1> ;==============================================================================
   295                              <1> kbd_wait_any:
   296 00001BF1 BE[FE1B]            <1>     mov     si, msg_press_any_key
   297 00001BF4 E8C9E4              <1>     call    print_string
   298 00001BF7 E85CFF              <1>     call    kbd_flush
   299 00001BFA E82DFF              <1>     call    kbd_get
   300 00001BFD C3                  <1>     ret
   301                              <1> 
   302                              <1> msg_press_any_key:
   303 00001BFE 507265737320616E79- <1>     db      "Press any key...", 0
   303 00001C07 206B65792E2E2E00    <1>
   304                              <1> 
   305                              <1> ;==============================================================================
   306                              <1> ; Check for F3 (Diagnostics Hotkey)
   307                              <1> ;==============================================================================
   308                              <1> ; Checks if F3 was pressed during POST.
   309                              <1> ;
   310                              <1> ; Output: CF = 1 if F3 pressed
   311                              <1> ; Destroys: AX
   312                              <1> ;==============================================================================
   313                              <1> kbd_check_f3:
   314                              <1>     ; Check keyboard buffer
   315 00001C0F B401                <1>     mov     ah, 0x01
   316 00001C11 CD16                <1>     int     0x16
   317 00001C13 740D                <1>     jz      .not_pressed
   318                              <1> 
   319                              <1>     ; Key available - check if F3
   320 00001C15 80FC3D              <1>     cmp     ah, KEY_F3
   321 00001C18 7506                <1>     jne     .not_f3
   322                              <1> 
   323                              <1>     ; Consume the key
   324 00001C1A B400                <1>     mov     ah, 0x00
   325 00001C1C CD16                <1>     int     0x16
   326 00001C1E F9                  <1>     stc
   327 00001C1F C3                  <1>     ret
   328                              <1> 
   329                              <1> .not_f3:
   330 00001C20 F8                  <1>     clc
   331 00001C21 C3                  <1>     ret
   332                              <1> 
   333                              <1> .not_pressed:
   334 00001C22 F8                  <1>     clc
   335 00001C23 C3                  <1>     ret
   336                              <1> 
   337                              <1> %endif ; BUILD_16KB
   228                                  %include "instr.inc"
     1                              <1> ;==============================================================================
     2                              <1> ; FluxRipper HDD BIOS - FPGA Instrumentation Register Definitions
     3                              <1> ;==============================================================================
     4                              <1> ; Defines the register map for accessing FPGA instrumentation data.
     5                              <1> ;
     6                              <1> ; The FPGA provides real-time diagnostic information through these registers:
     7                              <1> ;   - Performance counters
     8                              <1> ;   - Error statistics
     9                              <1> ;   - Flux analysis
    10                              <1> ;   - Health monitoring
    11                              <1> ;   - Signal quality metrics
    12                              <1> ;
    13                              <1> ; Access Method:
    14                              <1> ;   1. Write address to INSTR_ADDR_LO/HI registers
    15                              <1> ;   2. Read 32-bit data from INSTR_DATA_0..3 registers
    16                              <1> ;
    17                              <1> ; Register Base: WD_BASE + 0xC0 (e.g., 0x1F0 + 0xC0 = 0x2B0)
    18                              <1> ;
    19                              <1> ; SPDX-License-Identifier: BSD-3-Clause
    20                              <1> ; Copyright (c) 2025 FluxRipper Project
    21                              <1> ;==============================================================================
    22                              <1> 
    23                              <1> %ifndef INSTR_INC
    24                              <1> %define INSTR_INC
    25                              <1> 
    26                              <1> ;------------------------------------------------------------------------------
    27                              <1> ; Instrumentation I/O Port Offsets (from WD_BASE + 0xC0)
    28                              <1> ;------------------------------------------------------------------------------
    29                              <1> %define INSTR_ADDR_LO       0x00    ; W: Address [7:0]
    30                              <1> %define INSTR_ADDR_HI       0x01    ; W: Address [9:8]
    31                              <1> %define INSTR_DATA_0        0x02    ; R: Data [7:0]
    32                              <1> %define INSTR_DATA_1        0x03    ; R: Data [15:8]
    33                              <1> %define INSTR_DATA_2        0x04    ; R: Data [23:16]
    34                              <1> %define INSTR_DATA_3        0x05    ; R: Data [31:24]
    35                              <1> %define INSTR_CTRL          0x06    ; W: Control register
    36                              <1> 
    37                              <1> ;------------------------------------------------------------------------------
    38                              <1> ; Instrumentation Control Register Bits
    39                              <1> ;------------------------------------------------------------------------------
    40                              <1> %define INSTR_CTRL_RESET    0x01    ; Reset all counters
    41                              <1> %define INSTR_CTRL_FREEZE   0x02    ; Freeze counters (snapshot)
    42                              <1> %define INSTR_CTRL_ENABLE   0x80    ; Enable instrumentation
    43                              <1> 
    44                              <1> ;------------------------------------------------------------------------------
    45                              <1> ; Instrumentation Address Map
    46                              <1> ;------------------------------------------------------------------------------
    47                              <1> ; System Information (0x000-0x00F)
    48                              <1> %define INSTR_MAGIC         0x000   ; Magic number (0xFB010001)
    49                              <1> %define INSTR_VERSION       0x004   ; Instrumentation version
    50                              <1> %define INSTR_CAPS          0x008   ; Capabilities bitmap
    51                              <1> %define INSTR_STATUS        0x00C   ; Global status
    52                              <1> 
    53                              <1> ; Timing Information (0x010-0x02F)
    54                              <1> %define INSTR_UPTIME        0x010   ; System uptime (seconds)
    55                              <1> %define INSTR_LAST_CMD_TIME 0x014   ; Last command duration (us)
    56                              <1> %define INSTR_TOTAL_CMD_TIME 0x018  ; Total command time (ms)
    57                              <1> %define INSTR_INDEX_PERIOD  0x01C   ; Index pulse period (ns)
    58                              <1> %define INSTR_DATA_RATE     0x020   ; Measured data rate (bits/sec)
    59                              <1> %define INSTR_RPM           0x024   ; Spindle RPM * 10
    60                              <1> 
    61                              <1> ; Command Statistics (0x030-0x04F)
    62                              <1> %define INSTR_CMD_COUNT     0x030   ; Total commands executed
    63                              <1> %define INSTR_READ_COUNT    0x034   ; Read commands
    64                              <1> %define INSTR_WRITE_COUNT   0x038   ; Write commands
    65                              <1> %define INSTR_SEEK_COUNT    0x03C   ; Seek commands
    66                              <1> %define INSTR_FORMAT_COUNT  0x040   ; Format commands
    67                              <1> 
    68                              <1> ; Error Counters (0x050-0x07F)
    69                              <1> %define INSTR_ERR_TOTAL     0x050   ; Total errors
    70                              <1> %define INSTR_ERR_CRC       0x054   ; CRC/ECC errors
    71                              <1> %define INSTR_ERR_SEEK      0x058   ; Seek errors
    72                              <1> %define INSTR_ERR_TIMEOUT   0x05C   ; Timeout errors
    73                              <1> %define INSTR_ERR_OVERRUN   0x060   ; Data overrun errors
    74                              <1> %define INSTR_ERR_ID_NF     0x064   ; ID not found errors
    75                              <1> %define INSTR_ERR_ADDR_MARK 0x068   ; Address mark not found
    76                              <1> %define INSTR_ERR_WRITE_FLT 0x06C   ; Write fault errors
    77                              <1> %define INSTR_ERR_RECOVERED 0x070   ; Recovered errors (ECC)
    78                              <1> 
    79                              <1> ; Sector Statistics (0x080-0x09F)
    80                              <1> %define INSTR_SECTORS_READ  0x080   ; Sectors read (32-bit)
    81                              <1> %define INSTR_SECTORS_WRITE 0x084   ; Sectors written
    82                              <1> %define INSTR_SECTORS_VERIFY 0x088  ; Sectors verified
    83                              <1> %define INSTR_BYTES_READ_LO 0x08C   ; Bytes read [31:0]
    84                              <1> %define INSTR_BYTES_READ_HI 0x090   ; Bytes read [63:32]
    85                              <1> %define INSTR_BYTES_WRITE_LO 0x094  ; Bytes written [31:0]
    86                              <1> %define INSTR_BYTES_WRITE_HI 0x098  ; Bytes written [63:32]
    87                              <1> 
    88                              <1> ; Seek Statistics (0x0A0-0x0BF)
    89                              <1> %define INSTR_SEEK_TOTAL    0x0A0   ; Total seeks
    90                              <1> %define INSTR_SEEK_AVG_TIME 0x0A4   ; Average seek time (us)
    91                              <1> %define INSTR_SEEK_MIN_TIME 0x0A8   ; Minimum seek time
    92                              <1> %define INSTR_SEEK_MAX_TIME 0x0AC   ; Maximum seek time
    93                              <1> %define INSTR_SEEK_1TRK     0x0B0   ; 1-track seeks count
    94                              <1> %define INSTR_SEEK_SHORT    0x0B4   ; Short seeks (<16 tracks)
    95                              <1> %define INSTR_SEEK_MEDIUM   0x0B8   ; Medium seeks (16-256)
    96                              <1> %define INSTR_SEEK_LONG     0x0BC   ; Long seeks (>256)
    97                              <1> 
    98                              <1> ; Signal Quality (0x0C0-0x0DF)
    99                              <1> %define INSTR_SIG_AMPLITUDE 0x0C0   ; Signal amplitude (mV)
   100                              <1> %define INSTR_SIG_SNR       0x0C4   ; Signal-to-noise ratio (dB*10)
   101                              <1> %define INSTR_SIG_JITTER    0x0C8   ; Timing jitter (ns)
   102                              <1> %define INSTR_SIG_ASYM      0x0CC   ; Pulse asymmetry (%)
   103                              <1> %define INSTR_PLL_LOCK      0x0D0   ; PLL lock status
   104                              <1> %define INSTR_PLL_FREQ_ERR  0x0D4   ; PLL frequency error (ppm)
   105                              <1> 
   106                              <1> ; Flux Analysis (0x0E0-0x0FF)
   107                              <1> %define INSTR_FLUX_DENSITY  0x0E0   ; Flux transitions/inch
   108                              <1> %define INSTR_FLUX_PERIOD_AVG 0x0E4 ; Average flux period (ns)
   109                              <1> %define INSTR_FLUX_PERIOD_MIN 0x0E8 ; Minimum flux period
   110                              <1> %define INSTR_FLUX_PERIOD_MAX 0x0EC ; Maximum flux period
   111                              <1> %define INSTR_FLUX_VARIANCE 0x0F0   ; Period variance
   112                              <1> 
   113                              <1> ; Health Monitor (0x100-0x11F)
   114                              <1> %define INSTR_HEALTH_SCORE  0x100   ; Overall health (0-100)
   115                              <1> %define INSTR_MEDIA_SCORE   0x104   ; Media quality score
   116                              <1> %define INSTR_HEAD_SCORE    0x108   ; Head condition score
   117                              <1> %define INSTR_SPINDLE_SCORE 0x10C   ; Spindle health score
   118                              <1> %define INSTR_TEMP_DRIVE    0x110   ; Drive temperature (C*10)
   119                              <1> %define INSTR_TEMP_FPGA     0x114   ; FPGA temperature
   120                              <1> 
   121                              <1> ; Flux Histogram (0x200-0x2FF) - 64 x 32-bit bins
   122                              <1> %define INSTR_HIST_BASE     0x200   ; Histogram base address
   123                              <1> %define INSTR_HIST_COUNT    64      ; Number of histogram bins
   124                              <1> %define INSTR_HIST_BIN_SIZE 4       ; Bytes per bin
   125                              <1> 
   126                              <1> ; Error Log (0x300-0x3FF) - 16 x 16-byte entries
   127                              <1> %define INSTR_LOG_BASE      0x300   ; Error log base
   128                              <1> %define INSTR_LOG_ENTRIES   16      ; Number of log entries
   129                              <1> %define INSTR_LOG_ENTRY_SIZE 16     ; Bytes per entry
   130                              <1> 
   131                              <1> ;------------------------------------------------------------------------------
   132                              <1> ; Error Log Entry Format
   133                              <1> ;------------------------------------------------------------------------------
   134                              <1> ; Offset  Size  Description
   135                              <1> ; 0x00    4     Timestamp (seconds since power-on)
   136                              <1> ; 0x04    2     Cylinder
   137                              <1> ; 0x06    1     Head
   138                              <1> ; 0x07    1     Sector
   139                              <1> ; 0x08    1     Error type
   140                              <1> ; 0x09    1     Command that failed
   141                              <1> ; 0x0A    2     Additional info
   142                              <1> ; 0x0C    4     Raw error data
   143                              <1> 
   144                              <1> %define LOG_TIMESTAMP       0
   145                              <1> %define LOG_CYLINDER        4
   146                              <1> %define LOG_HEAD            6
   147                              <1> %define LOG_SECTOR          7
   148                              <1> %define LOG_ERROR_TYPE      8
   149                              <1> %define LOG_COMMAND         9
   150                              <1> %define LOG_INFO            10
   151                              <1> %define LOG_RAW_DATA        12
   152                              <1> 
   153                              <1> ;------------------------------------------------------------------------------
   154                              <1> ; Histogram Bin Definitions
   155                              <1> ;------------------------------------------------------------------------------
   156                              <1> ; Each bin represents a flux period range
   157                              <1> ; Bin width = 50ns, starting at 0ns
   158                              <1> ; Bin 0:  0-49ns
   159                              <1> ; Bin 1:  50-99ns
   160                              <1> ; ...
   161                              <1> ; Bin 63: 3150-3199ns
   162                              <1> 
   163                              <1> %define HIST_BIN_WIDTH      50      ; ns per bin
   164                              <1> %define HIST_MIN_PERIOD     0       ; ns
   165                              <1> %define HIST_MAX_PERIOD     3200    ; ns
   166                              <1> 
   167                              <1> ;------------------------------------------------------------------------------
   168                              <1> ; Macros for Instrumentation Access
   169                              <1> ;------------------------------------------------------------------------------
   170                              <1> 
   171                              <1> ; Set instrumentation address
   172                              <1> ; Input: AX = 10-bit address
   173                              <1> ; Destroys: DX
   174                              <1> %macro INSTR_SET_ADDR 0
   175                              <1>     push    dx
   176                              <1>     mov     dx, [current_base]
   177                              <1>     add     dx, INSTR_REG_BASE + INSTR_ADDR_LO
   178                              <1>     out     dx, al                  ; Low byte
   179                              <1>     inc     dx
   180                              <1>     mov     al, ah
   181                              <1>     out     dx, al                  ; High byte
   182                              <1>     pop     dx
   183                              <1> %endmacro
   184                              <1> 
   185                              <1> ; Read 32-bit instrumentation data
   186                              <1> ; Output: EAX = 32-bit value (or DX:AX if no 32-bit support)
   187                              <1> ; Destroys: DX
   188                              <1> %macro INSTR_READ_DATA 0
   189                              <1>     push    bx
   190                              <1>     mov     dx, [current_base]
   191                              <1>     add     dx, INSTR_REG_BASE + INSTR_DATA_0
   192                              <1>     in      al, dx                  ; Byte 0
   193                              <1>     mov     bl, al
   194                              <1>     inc     dx
   195                              <1>     in      al, dx                  ; Byte 1
   196                              <1>     mov     bh, al
   197                              <1>     inc     dx
   198                              <1>     in      al, dx                  ; Byte 2
   199                              <1>     mov     cl, al
   200                              <1>     inc     dx
   201                              <1>     in      al, dx                  ; Byte 3
   202                              <1>     mov     ch, al
   203                              <1>     ; Result: CX:BX = 32-bit value
   204                              <1>     mov     ax, bx
   205                              <1>     mov     dx, cx
   206                              <1>     pop     bx
   207                              <1> %endmacro
   208                              <1> 
   209                              <1> ; Read instrumentation register (combined)
   210                              <1> ; Input: register address constant
   211                              <1> ; Output: DX:AX = 32-bit value
   212                              <1> %macro INSTR_READ_REG 1
   213                              <1>     mov     ax, %1
   214                              <1>     INSTR_SET_ADDR
   215                              <1>     INSTR_READ_DATA
   216                              <1> %endmacro
   217                              <1> 
   218                              <1> %endif ; INSTR_INC
   229                                  %if ENABLE_DIAG
   230                                  ; Diagnostics module (includes surface scan, seek test, flux histogram, etc.)
   231                                  %include "diag.asm"
     1                              <1> ;==============================================================================
     2                              <1> ; FluxRipper HDD BIOS - Diagnostics Menu
     3                              <1> ;==============================================================================
     4                              <1> ; Main diagnostics interface accessible via F3 during POST.
     5                              <1> ;
     6                              <1> ; Features:
     7                              <1> ;   - Drive status display
     8                              <1> ;   - Surface scan
     9                              <1> ;   - Seek test
    10                              <1> ;   - Flux histogram
    11                              <1> ;   - Error log viewer
    12                              <1> ;   - ESDI query (if applicable)
    13                              <1> ;   - Real-time monitor
    14                              <1> ;
    15                              <1> ; SPDX-License-Identifier: BSD-3-Clause
    16                              <1> ; Copyright (c) 2025 FluxRipper Project
    17                              <1> ;==============================================================================
    18                              <1> 
    19                              <1> %if BUILD_16KB
    20                              <1> 
    21                              <1> ;==============================================================================
    22                              <1> ; Diagnostics Entry Point
    23                              <1> ;==============================================================================
    24                              <1> ; Called when F3 is detected during POST.
    25                              <1> ;
    26                              <1> ; Preserves: All registers
    27                              <1> ;==============================================================================
    28                              <1> diag_enter:
    29 00001C24 6660                <1>     pushad
    30 00001C26 1E                  <1>     push    ds
    31 00001C27 06                  <1>     push    es
    32                              <1> 
    33                              <1>     ; Set up segments
    34 00001C28 0E                  <1>     push    cs
    35 00001C29 1F                  <1>     pop     ds
    36                              <1> 
    37                              <1>     ; Initialize video
    38 00001C2A E848FD              <1>     call    video_init
    39 00001C2D E899FD              <1>     call    video_clear_screen
    40                              <1> 
    41                              <1>     ; Draw main screen
    42 00001C30 E80B00              <1>     call    diag_draw_main
    43                              <1> 
    44                              <1>     ; Main menu loop
    45 00001C33 E87B01              <1>     call    diag_main_menu
    46                              <1> 
    47                              <1>     ; Restore screen and return
    48 00001C36 E890FD              <1>     call    video_clear_screen
    49                              <1> 
    50 00001C39 07                  <1>     pop     es
    51 00001C3A 1F                  <1>     pop     ds
    52 00001C3B 6661                <1>     popad
    53 00001C3D C3                  <1>     ret
    54                              <1> 
    55                              <1> ;==============================================================================
    56                              <1> ; Draw Main Diagnostics Screen
    57                              <1> ;==============================================================================
    58                              <1> diag_draw_main:
    59 00001C3E 50                  <1>     push    ax
    60 00001C3F 52                  <1>     push    dx
    61 00001C40 56                  <1>     push    si
    62                              <1> 
    63                              <1>     ; Draw title bar
    64 00001C41 B41F                <1>     mov     ah, ATTR_TITLE
    65 00001C43 B600                <1>     mov     dh, 0
    66 00001C45 BE[4C25]            <1>     mov     si, diag_title
    67 00001C48 E8B3FE              <1>     call    video_puts_centered
    68                              <1> 
    69                              <1>     ; Draw box around menu area
    70 00001C4B B602                <1>     mov     dh, 2                   ; Top row
    71 00001C4D B205                <1>     mov     dl, 5                   ; Left column
    72 00001C4F B516                <1>     mov     ch, 22                  ; Bottom row
    73 00001C51 B14A                <1>     mov     cl, 74                  ; Right column
    74 00001C53 B407                <1>     mov     ah, ATTR_NORMAL
    75 00001C55 E8F1FD              <1>     call    video_draw_box
    76                              <1> 
    77                              <1>     ; Draw drive info header
    78 00001C58 B603                <1>     mov     dh, 3
    79 00001C5A B207                <1>     mov     dl, 7
    80 00001C5C B40E                <1>     mov     ah, ATTR_HIGHLIGHT
    81 00001C5E BE[8525]            <1>     mov     si, diag_drive_hdr
    82 00001C61 E8C7FD              <1>     call    video_puts_at
    83                              <1> 
    84                              <1>     ; Display drive 0 info
    85 00001C64 B280                <1>     mov     dl, 0x80
    86 00001C66 E81600              <1>     call    diag_show_drive_info
    87                              <1> 
    88                              <1>     ; Display drive 1 info if present
    89 00001C69 B281                <1>     mov     dl, 0x81
    90 00001C6B E81100              <1>     call    diag_show_drive_info
    91                              <1> 
    92                              <1>     ; Draw menu options
    93 00001C6E E8A300              <1>     call    diag_draw_menu_options
    94                              <1> 
    95                              <1>     ; Draw status bar
    96 00001C71 B618                <1>     mov     dh, 24
    97 00001C73 B470                <1>     mov     ah, ATTR_INVERSE
    98 00001C75 BE[6925]            <1>     mov     si, diag_status_bar
    99 00001C78 E883FE              <1>     call    video_puts_centered
   100                              <1> 
   101 00001C7B 5E                  <1>     pop     si
   102 00001C7C 5A                  <1>     pop     dx
   103 00001C7D 58                  <1>     pop     ax
   104 00001C7E C3                  <1>     ret
   105                              <1> 
   106                              <1> ;==============================================================================
   107                              <1> ; Show Drive Information
   108                              <1> ;==============================================================================
   109                              <1> ; Input: DL = drive number (0x80 or 0x81)
   110                              <1> ;==============================================================================
   111                              <1> diag_show_drive_info:
   112 00001C7F 50                  <1>     push    ax
   113 00001C80 53                  <1>     push    bx
   114 00001C81 51                  <1>     push    cx
   115 00001C82 52                  <1>     push    dx
   116 00001C83 56                  <1>     push    si
   117 00001C84 57                  <1>     push    di
   118                              <1> 
   119                              <1>     ; Calculate row (drive 0 = row 5, drive 1 = row 7)
   120 00001C85 B605                <1>     mov     dh, 5
   121 00001C87 80FA81              <1>     cmp     dl, 0x81
   122 00001C8A 7502                <1>     jne     .got_row
   123 00001C8C B607                <1>     mov     dh, 7
   124                              <1> .got_row:
   125 00001C8E 8836[121D]          <1>     mov     [.drive_row], dh
   126 00001C92 8816[131D]          <1>     mov     [.drive_num], dl
   127                              <1> 
   128                              <1>     ; Check if drive present
   129 00001C96 52                  <1>     push    dx
   130 00001C97 E856EC              <1>     call    get_drive_params
   131 00001C9A 5A                  <1>     pop     dx
   132 00001C9B 724A                <1>     jc      .not_present
   133                              <1> 
   134                              <1>     ; Drive number
   135 00001C9D B207                <1>     mov     dl, 7
   136 00001C9F 8A36[121D]          <1>     mov     dh, [.drive_row]
   137 00001CA3 B407                <1>     mov     ah, ATTR_NORMAL
   138 00001CA5 BE[A425]            <1>     mov     si, diag_drive_prefix
   139 00001CA8 E880FD              <1>     call    video_puts_at
   140                              <1> 
   141                              <1>     ; Drive number digit
   142 00001CAB A0[131D]            <1>     mov     al, [.drive_num]
   143 00001CAE 2C80                <1>     sub     al, 0x80
   144 00001CB0 0430                <1>     add     al, '0'
   145 00001CB2 80C206              <1>     add     dl, 6
   146 00001CB5 E842FD              <1>     call    video_putc_at
   147                              <1> 
   148                              <1>     ; Cylinders
   149 00001CB8 80C204              <1>     add     dl, 4
   150 00001CBB 8B04                <1>     mov     ax, [si + 0]            ; Cylinders from FDPT
   151 00001CBD E84A08              <1>     call    diag_print_dec16
   152                              <1> 
   153                              <1>     ; Heads
   154 00001CC0 80C208              <1>     add     dl, 8
   155 00001CC3 30E4                <1>     xor     ah, ah
   156 00001CC5 8A4402              <1>     mov     al, [si + 2]
   157 00001CC8 E83F08              <1>     call    diag_print_dec16
   158                              <1> 
   159                              <1>     ; Sectors
   160 00001CCB 80C206              <1>     add     dl, 6
   161 00001CCE 30E4                <1>     xor     ah, ah
   162 00001CD0 8A4403              <1>     mov     al, [si + 3]
   163 00001CD3 E83408              <1>     call    diag_print_dec16
   164                              <1> 
   165                              <1>     ; Calculate and show capacity in MB
   166 00001CD6 80C206              <1>     add     dl, 6
   167 00001CD9 E80A08              <1>     call    diag_calc_capacity
   168 00001CDC E82B08              <1>     call    diag_print_dec16
   169 00001CDF BE[B725]            <1>     mov     si, diag_mb_suffix
   170 00001CE2 E846FD              <1>     call    video_puts_at
   171                              <1> 
   172 00001CE5 EB24                <1>     jmp     .done
   173                              <1> 
   174                              <1> .not_present:
   175 00001CE7 B207                <1>     mov     dl, 7
   176 00001CE9 8A36[121D]          <1>     mov     dh, [.drive_row]
   177 00001CED B408                <1>     mov     ah, ATTR_DIM
   178 00001CEF BE[A425]            <1>     mov     si, diag_drive_prefix
   179 00001CF2 E836FD              <1>     call    video_puts_at
   180 00001CF5 A0[131D]            <1>     mov     al, [.drive_num]
   181 00001CF8 2C80                <1>     sub     al, 0x80
   182 00001CFA 0430                <1>     add     al, '0'
   183 00001CFC 80C206              <1>     add     dl, 6
   184 00001CFF E8F8FC              <1>     call    video_putc_at
   185 00001D02 80C204              <1>     add     dl, 4
   186 00001D05 BE[AB25]            <1>     mov     si, diag_not_present
   187 00001D08 E820FD              <1>     call    video_puts_at
   188                              <1> 
   189                              <1> .done:
   190 00001D0B 5F                  <1>     pop     di
   191 00001D0C 5E                  <1>     pop     si
   192 00001D0D 5A                  <1>     pop     dx
   193 00001D0E 59                  <1>     pop     cx
   194 00001D0F 5B                  <1>     pop     bx
   195 00001D10 58                  <1>     pop     ax
   196 00001D11 C3                  <1>     ret
   197                              <1> 
   198 00001D12 00                  <1> .drive_row: db 0
   199 00001D13 00                  <1> .drive_num: db 0
   200                              <1> 
   201                              <1> ;==============================================================================
   202                              <1> ; Draw Menu Options
   203                              <1> ;==============================================================================
   204                              <1> diag_draw_menu_options:
   205 00001D14 50                  <1>     push    ax
   206 00001D15 52                  <1>     push    dx
   207 00001D16 56                  <1>     push    si
   208                              <1> 
   209 00001D17 B60A                <1>     mov     dh, 10                  ; Starting row
   210 00001D19 B20A                <1>     mov     dl, 10                  ; Column
   211                              <1> 
   212                              <1>     ; Option 1: Surface Scan
   213 00001D1B B40E                <1>     mov     ah, ATTR_HIGHLIGHT
   214 00001D1D B031                <1>     mov     al, '1'
   215 00001D1F E8D8FC              <1>     call    video_putc_at
   216 00001D22 B407                <1>     mov     ah, ATTR_NORMAL
   217 00001D24 80C202              <1>     add     dl, 2
   218 00001D27 BE[BB25]            <1>     mov     si, diag_opt_surface
   219 00001D2A E8FEFC              <1>     call    video_puts_at
   220                              <1> 
   221                              <1>     ; Option 2: Seek Test
   222 00001D2D 80C602              <1>     add     dh, 2
   223 00001D30 B20A                <1>     mov     dl, 10
   224 00001D32 B40E                <1>     mov     ah, ATTR_HIGHLIGHT
   225 00001D34 B032                <1>     mov     al, '2'
   226 00001D36 E8C1FC              <1>     call    video_putc_at
   227 00001D39 80C202              <1>     add     dl, 2
   228 00001D3C B407                <1>     mov     ah, ATTR_NORMAL
   229 00001D3E BE[DD25]            <1>     mov     si, diag_opt_seek
   230 00001D41 E8E7FC              <1>     call    video_puts_at
   231                              <1> 
   232                              <1>     ; Option 3: Flux Histogram
   233 00001D44 80C602              <1>     add     dh, 2
   234 00001D47 B20A                <1>     mov     dl, 10
   235 00001D49 B40E                <1>     mov     ah, ATTR_HIGHLIGHT
   236 00001D4B B033                <1>     mov     al, '3'
   237 00001D4D E8AAFC              <1>     call    video_putc_at
   238 00001D50 80C202              <1>     add     dl, 2
   239 00001D53 B407                <1>     mov     ah, ATTR_NORMAL
   240 00001D55 BE[0526]            <1>     mov     si, diag_opt_flux
   241 00001D58 E8D0FC              <1>     call    video_puts_at
   242                              <1> 
   243                              <1>     ; Option 4: Error Log
   244 00001D5B 80C602              <1>     add     dh, 2
   245 00001D5E B20A                <1>     mov     dl, 10
   246 00001D60 B40E                <1>     mov     ah, ATTR_HIGHLIGHT
   247 00001D62 B034                <1>     mov     al, '4'
   248 00001D64 E893FC              <1>     call    video_putc_at
   249 00001D67 80C202              <1>     add     dl, 2
   250 00001D6A B407                <1>     mov     ah, ATTR_NORMAL
   251 00001D6C BE[2826]            <1>     mov     si, diag_opt_errors
   252 00001D6F E8B9FC              <1>     call    video_puts_at
   253                              <1> 
   254                              <1>     ; Option 5: Health Monitor
   255 00001D72 80C602              <1>     add     dh, 2
   256 00001D75 B20A                <1>     mov     dl, 10
   257 00001D77 B40E                <1>     mov     ah, ATTR_HIGHLIGHT
   258 00001D79 B035                <1>     mov     al, '5'
   259 00001D7B E87CFC              <1>     call    video_putc_at
   260 00001D7E 80C202              <1>     add     dl, 2
   261 00001D81 B407                <1>     mov     ah, ATTR_NORMAL
   262 00001D83 BE[4926]            <1>     mov     si, diag_opt_health
   263 00001D86 E8A2FC              <1>     call    video_puts_at
   264                              <1> 
   265                              <1>     ; Option 6: Signal Quality
   266 00001D89 80C602              <1>     add     dh, 2
   267 00001D8C B20A                <1>     mov     dl, 10
   268 00001D8E B40E                <1>     mov     ah, ATTR_HIGHLIGHT
   269 00001D90 B036                <1>     mov     al, '6'
   270 00001D92 E865FC              <1>     call    video_putc_at
   271 00001D95 80C202              <1>     add     dl, 2
   272 00001D98 B407                <1>     mov     ah, ATTR_NORMAL
   273 00001D9A BE[6C26]            <1>     mov     si, diag_opt_signal
   274 00001D9D E88BFC              <1>     call    video_puts_at
   275                              <1> 
   276                              <1>     ; ESC to exit
   277 00001DA0 80C603              <1>     add     dh, 3
   278 00001DA3 B20A                <1>     mov     dl, 10
   279 00001DA5 B408                <1>     mov     ah, ATTR_DIM
   280 00001DA7 BE[9226]            <1>     mov     si, diag_opt_exit
   281 00001DAA E87EFC              <1>     call    video_puts_at
   282                              <1> 
   283 00001DAD 5E                  <1>     pop     si
   284 00001DAE 5A                  <1>     pop     dx
   285 00001DAF 58                  <1>     pop     ax
   286 00001DB0 C3                  <1>     ret
   287                              <1> 
   288                              <1> ;==============================================================================
   289                              <1> ; Main Menu Handler
   290                              <1> ;==============================================================================
   291                              <1> diag_main_menu:
   292 00001DB1 50                  <1>     push    ax
   293 00001DB2 53                  <1>     push    bx
   294                              <1> 
   295                              <1> .menu_loop:
   296 00001DB3 E874FD              <1>     call    kbd_get
   297                              <1> 
   298                              <1>     ; Check for ESC
   299 00001DB6 80FC01              <1>     cmp     ah, KEY_ESC
   300 00001DB9 744A                <1>     je      .exit
   301                              <1> 
   302                              <1>     ; Check for digit keys
   303 00001DBB 3C31                <1>     cmp     al, '1'
   304 00001DBD 7416                <1>     je      .surface_scan
   305 00001DBF 3C32                <1>     cmp     al, '2'
   306 00001DC1 741A                <1>     je      .seek_test
   307 00001DC3 3C33                <1>     cmp     al, '3'
   308 00001DC5 741E                <1>     je      .flux_hist
   309 00001DC7 3C34                <1>     cmp     al, '4'
   310 00001DC9 7422                <1>     je      .error_log
   311 00001DCB 3C35                <1>     cmp     al, '5'
   312 00001DCD 7426                <1>     je      .health_mon
   313 00001DCF 3C36                <1>     cmp     al, '6'
   314 00001DD1 742A                <1>     je      .signal_qual
   315                              <1> 
   316                              <1>     ; Invalid key
   317 00001DD3 EBDE                <1>     jmp     .menu_loop
   318                              <1> 
   319                              <1> .surface_scan:
   320 00001DD5 E83000              <1>     call    diag_surface_scan
   321 00001DD8 E863FE              <1>     call    diag_draw_main
   322 00001DDB EBD6                <1>     jmp     .menu_loop
   323                              <1> 
   324                              <1> .seek_test:
   325 00001DDD E8A301              <1>     call    diag_seek_test
   326 00001DE0 E85BFE              <1>     call    diag_draw_main
   327 00001DE3 EBCE                <1>     jmp     .menu_loop
   328                              <1> 
   329                              <1> .flux_hist:
   330 00001DE5 E89302              <1>     call    diag_flux_histogram
   331 00001DE8 E853FE              <1>     call    diag_draw_main
   332 00001DEB EBC6                <1>     jmp     .menu_loop
   333                              <1> 
   334                              <1> .error_log:
   335 00001DED E84C03              <1>     call    diag_error_log
   336 00001DF0 E84BFE              <1>     call    diag_draw_main
   337 00001DF3 EBBE                <1>     jmp     .menu_loop
   338                              <1> 
   339                              <1> .health_mon:
   340 00001DF5 E8D303              <1>     call    diag_health_monitor
   341 00001DF8 E843FE              <1>     call    diag_draw_main
   342 00001DFB EBB6                <1>     jmp     .menu_loop
   343                              <1> 
   344                              <1> .signal_qual:
   345 00001DFD E87505              <1>     call    diag_signal_quality
   346 00001E00 E83BFE              <1>     call    diag_draw_main
   347 00001E03 EBAE                <1>     jmp     .menu_loop
   348                              <1> 
   349                              <1> .exit:
   350 00001E05 5B                  <1>     pop     bx
   351 00001E06 58                  <1>     pop     ax
   352 00001E07 C3                  <1>     ret
   353                              <1> 
   354                              <1> ;==============================================================================
   355                              <1> ; Surface Scan Test
   356                              <1> ;==============================================================================
   357                              <1> diag_surface_scan:
   358 00001E08 50                  <1>     push    ax
   359 00001E09 53                  <1>     push    bx
   360 00001E0A 51                  <1>     push    cx
   361 00001E0B 52                  <1>     push    dx
   362 00001E0C 56                  <1>     push    si
   363                              <1> 
   364 00001E0D E8B9FB              <1>     call    video_clear_screen
   365                              <1> 
   366                              <1>     ; Title
   367 00001E10 B41F                <1>     mov     ah, ATTR_TITLE
   368 00001E12 B600                <1>     mov     dh, 0
   369 00001E14 BE[D126]            <1>     mov     si, diag_surface_title
   370 00001E17 E8E4FC              <1>     call    video_puts_centered
   371                              <1> 
   372                              <1>     ; Select drive
   373 00001E1A B603                <1>     mov     dh, 3
   374 00001E1C B205                <1>     mov     dl, 5
   375 00001E1E B407                <1>     mov     ah, ATTR_NORMAL
   376 00001E20 BE[A626]            <1>     mov     si, diag_select_drive
   377 00001E23 E805FC              <1>     call    video_puts_at
   378                              <1> 
   379 00001E26 E852FD              <1>     call    kbd_get_digit
   380 00001E29 0F824201            <1>     jc      .cancelled
   381 00001E2D 3C01                <1>     cmp     al, 1
   382 00001E2F 0F873C01            <1>     ja      .cancelled
   383 00001E33 0480                <1>     add     al, 0x80
   384 00001E35 A2[781F]            <1>     mov     [.scan_drive], al
   385                              <1> 
   386                              <1>     ; Get drive parameters
   387 00001E38 8A16[781F]          <1>     mov     dl, [.scan_drive]
   388 00001E3C E8B1EA              <1>     call    get_drive_params
   389 00001E3F 0F821E01            <1>     jc      .no_drive
   390                              <1> 
   391                              <1>     ; Store geometry
   392 00001E43 8B04                <1>     mov     ax, [si + 0]
   393 00001E45 A3[791F]            <1>     mov     [.max_cyl], ax
   394 00001E48 8A4402              <1>     mov     al, [si + 2]
   395 00001E4B A2[7B1F]            <1>     mov     [.max_head], al
   396 00001E4E 8A4403              <1>     mov     al, [si + 3]
   397 00001E51 A2[7C1F]            <1>     mov     [.max_sect], al
   398                              <1> 
   399                              <1>     ; Show progress
   400 00001E54 B605                <1>     mov     dh, 5
   401 00001E56 B205                <1>     mov     dl, 5
   402 00001E58 BE[E026]            <1>     mov     si, diag_scanning
   403 00001E5B E8CDFB              <1>     call    video_puts_at
   404                              <1> 
   405                              <1>     ; Initialize counters
   406 00001E5E 3106[811F]          <1>     xor     word [.error_count], ax
   407 00001E62 C706[7D1F]0000      <1>     mov     word [.current_cyl], 0
   408                              <1> 
   409                              <1> .scan_loop:
   410                              <1>     ; Update progress bar
   411 00001E68 B607                <1>     mov     dh, 7
   412 00001E6A B205                <1>     mov     dl, 5
   413 00001E6C B13C                <1>     mov     cl, 60                  ; Width
   414 00001E6E A1[7D1F]            <1>     mov     ax, [.current_cyl]
   415 00001E71 8B1E[791F]          <1>     mov     bx, [.max_cyl]
   416 00001E75 31D2                <1>     xor     dx, dx
   417 00001E77 52                  <1>     push    dx
   418 00001E78 BA6400              <1>     mov     dx, 100
   419 00001E7B F7E2                <1>     mul     dx                      ; AX = cyl * 100
   420 00001E7D F7F3                <1>     div     bx                      ; AL = percentage
   421 00001E7F 5A                  <1>     pop     dx
   422 00001E80 B407                <1>     mov     ah, ATTR_NORMAL
   423 00001E82 E833FC              <1>     call    video_progress_bar
   424                              <1> 
   425                              <1>     ; Display cylinder number
   426 00001E85 B609                <1>     mov     dh, 9
   427 00001E87 B205                <1>     mov     dl, 5
   428 00001E89 B407                <1>     mov     ah, ATTR_NORMAL
   429 00001E8B BE[EC26]            <1>     mov     si, diag_cylinder
   430 00001E8E E89AFB              <1>     call    video_puts_at
   431 00001E91 80C20A              <1>     add     dl, 10
   432 00001E94 A1[7D1F]            <1>     mov     ax, [.current_cyl]
   433 00001E97 E87006              <1>     call    diag_print_dec16
   434                              <1> 
   435                              <1>     ; Read each head/sector on this cylinder
   436 00001E9A 8036[7F1F]00        <1>     xor     byte [.current_head], 0
   437                              <1> .head_loop:
   438 00001E9F C606[801F]01        <1>     mov     byte [.current_sect], 1
   439                              <1> .sect_loop:
   440                              <1>     ; Set up read parameters
   441 00001EA4 B402                <1>     mov     ah, 0x02                ; Read sectors
   442 00001EA6 B001                <1>     mov     al, 1                   ; One sector
   443 00001EA8 8A2E[7D1F]          <1>     mov     ch, [.current_cyl]      ; Cylinder low
   444 00001EAC 8A0E[801F]          <1>     mov     cl, [.current_sect]     ; Sector
   445 00001EB0 A0[7E1F]            <1>     mov     al, [.current_cyl + 1]
   446 00001EB3 C0E006              <1>     shl     al, 6
   447 00001EB6 08C1                <1>     or      cl, al                  ; Cylinder high bits
   448 00001EB8 8A36[7F1F]          <1>     mov     dh, [.current_head]
   449 00001EBC 8A16[781F]          <1>     mov     dl, [.scan_drive]
   450 00001EC0 BB[2929]            <1>     mov     bx, scratch_buffer
   451 00001EC3 06                  <1>     push    es
   452 00001EC4 0E                  <1>     push    cs
   453 00001EC5 07                  <1>     pop     es
   454 00001EC6 CD13                <1>     int     0x13
   455 00001EC8 07                  <1>     pop     es
   456                              <1> 
   457 00001EC9 7339                <1>     jnc     .read_ok
   458                              <1> 
   459                              <1>     ; Error - increment counter
   460 00001ECB FF06[811F]          <1>     inc     word [.error_count]
   461                              <1> 
   462                              <1>     ; Display error location
   463 00001ECF 52                  <1>     push    dx
   464 00001ED0 B60B                <1>     mov     dh, 11
   465 00001ED2 B205                <1>     mov     dl, 5
   466 00001ED4 B44F                <1>     mov     ah, ATTR_ERROR
   467 00001ED6 BE[F726]            <1>     mov     si, diag_error_at
   468 00001ED9 E84FFB              <1>     call    video_puts_at
   469 00001EDC 80C20A              <1>     add     dl, 10
   470 00001EDF A1[7D1F]            <1>     mov     ax, [.current_cyl]
   471 00001EE2 E82506              <1>     call    diag_print_dec16
   472 00001EE5 B02F                <1>     mov     al, '/'
   473 00001EE7 E810FB              <1>     call    video_putc_at
   474 00001EEA FEC2                <1>     inc     dl
   475 00001EEC 30E4                <1>     xor     ah, ah
   476 00001EEE A0[7F1F]            <1>     mov     al, [.current_head]
   477 00001EF1 E81606              <1>     call    diag_print_dec16
   478 00001EF4 B02F                <1>     mov     al, '/'
   479 00001EF6 E801FB              <1>     call    video_putc_at
   480 00001EF9 FEC2                <1>     inc     dl
   481 00001EFB 30E4                <1>     xor     ah, ah
   482 00001EFD A0[801F]            <1>     mov     al, [.current_sect]
   483 00001F00 E80706              <1>     call    diag_print_dec16
   484 00001F03 5A                  <1>     pop     dx
   485                              <1> 
   486                              <1> .read_ok:
   487                              <1>     ; Check for ESC
   488 00001F04 B401                <1>     mov     ah, 0x01
   489 00001F06 CD16                <1>     int     0x16
   490 00001F08 7409                <1>     jz      .no_key
   491 00001F0A B400                <1>     mov     ah, 0x00
   492 00001F0C CD16                <1>     int     0x16
   493 00001F0E 80FC01              <1>     cmp     ah, KEY_ESC
   494 00001F11 742B                <1>     je      .scan_done
   495                              <1> .no_key:
   496                              <1> 
   497                              <1>     ; Next sector
   498 00001F13 FE06[801F]          <1>     inc     byte [.current_sect]
   499 00001F17 A0[801F]            <1>     mov     al, [.current_sect]
   500 00001F1A 3A06[7C1F]          <1>     cmp     al, [.max_sect]
   501 00001F1E 7684                <1>     jbe     .sect_loop
   502                              <1> 
   503                              <1>     ; Next head
   504 00001F20 FE06[7F1F]          <1>     inc     byte [.current_head]
   505 00001F24 A0[7F1F]            <1>     mov     al, [.current_head]
   506 00001F27 3A06[7B1F]          <1>     cmp     al, [.max_head]
   507 00001F2B 0F8270FF            <1>     jb      .head_loop
   508                              <1> 
   509                              <1>     ; Next cylinder
   510 00001F2F FF06[7D1F]          <1>     inc     word [.current_cyl]
   511 00001F33 A1[7D1F]            <1>     mov     ax, [.current_cyl]
   512 00001F36 3B06[791F]          <1>     cmp     ax, [.max_cyl]
   513 00001F3A 0F822AFF            <1>     jb      .scan_loop
   514                              <1> 
   515                              <1> .scan_done:
   516                              <1>     ; Show results
   517 00001F3E B60E                <1>     mov     dh, 14
   518 00001F40 B205                <1>     mov     dl, 5
   519 00001F42 B40F                <1>     mov     ah, ATTR_BRIGHT
   520 00001F44 BE[0227]            <1>     mov     si, diag_scan_complete
   521 00001F47 E8E1FA              <1>     call    video_puts_at
   522                              <1> 
   523 00001F4A B610                <1>     mov     dh, 16
   524 00001F4C B205                <1>     mov     dl, 5
   525 00001F4E B407                <1>     mov     ah, ATTR_NORMAL
   526 00001F50 BE[1027]            <1>     mov     si, diag_errors_found
   527 00001F53 E8D5FA              <1>     call    video_puts_at
   528 00001F56 80C20F              <1>     add     dl, 15
   529 00001F59 A1[811F]            <1>     mov     ax, [.error_count]
   530 00001F5C E8AB05              <1>     call    diag_print_dec16
   531                              <1> 
   532 00001F5F EB0E                <1>     jmp     .wait_key
   533                              <1> 
   534                              <1> .no_drive:
   535 00001F61 B605                <1>     mov     dh, 5
   536 00001F63 B205                <1>     mov     dl, 5
   537 00001F65 B44F                <1>     mov     ah, ATTR_ERROR
   538 00001F67 BE[BE26]            <1>     mov     si, diag_no_drive
   539 00001F6A E8BEFA              <1>     call    video_puts_at
   540 00001F6D EB00                <1>     jmp     .wait_key
   541                              <1> 
   542                              <1> .cancelled:
   543                              <1> .wait_key:
   544 00001F6F E87FFC              <1>     call    kbd_wait_any
   545                              <1> 
   546 00001F72 5E                  <1>     pop     si
   547 00001F73 5A                  <1>     pop     dx
   548 00001F74 59                  <1>     pop     cx
   549 00001F75 5B                  <1>     pop     bx
   550 00001F76 58                  <1>     pop     ax
   551 00001F77 C3                  <1>     ret
   552                              <1> 
   553 00001F78 00                  <1> .scan_drive:    db 0
   554 00001F79 0000                <1> .max_cyl:       dw 0
   555 00001F7B 00                  <1> .max_head:      db 0
   556 00001F7C 00                  <1> .max_sect:      db 0
   557 00001F7D 0000                <1> .current_cyl:   dw 0
   558 00001F7F 00                  <1> .current_head:  db 0
   559 00001F80 00                  <1> .current_sect:  db 0
   560 00001F81 0000                <1> .error_count:   dw 0
   561                              <1> 
   562                              <1> ;==============================================================================
   563                              <1> ; Seek Test
   564                              <1> ;==============================================================================
   565                              <1> diag_seek_test:
   566 00001F83 50                  <1>     push    ax
   567 00001F84 53                  <1>     push    bx
   568 00001F85 51                  <1>     push    cx
   569 00001F86 52                  <1>     push    dx
   570 00001F87 56                  <1>     push    si
   571                              <1> 
   572 00001F88 E83EFA              <1>     call    video_clear_screen
   573                              <1> 
   574 00001F8B B41F                <1>     mov     ah, ATTR_TITLE
   575 00001F8D B600                <1>     mov     dh, 0
   576 00001F8F BE[1F27]            <1>     mov     si, diag_seek_title
   577 00001F92 E869FB              <1>     call    video_puts_centered
   578                              <1> 
   579                              <1>     ; Select drive
   580 00001F95 B603                <1>     mov     dh, 3
   581 00001F97 B205                <1>     mov     dl, 5
   582 00001F99 B407                <1>     mov     ah, ATTR_NORMAL
   583 00001F9B BE[A626]            <1>     mov     si, diag_select_drive
   584 00001F9E E88AFA              <1>     call    video_puts_at
   585                              <1> 
   586 00001FA1 E8D7FB              <1>     call    kbd_get_digit
   587 00001FA4 0F82C300            <1>     jc      .done
   588 00001FA8 3C01                <1>     cmp     al, 1
   589 00001FAA 0F87BD00            <1>     ja      .done
   590 00001FAE 0480                <1>     add     al, 0x80
   591 00001FB0 A2[7420]            <1>     mov     [.test_drive], al
   592                              <1> 
   593                              <1>     ; Get drive parameters
   594 00001FB3 8A16[7420]          <1>     mov     dl, [.test_drive]
   595 00001FB7 E836E9              <1>     call    get_drive_params
   596 00001FBA 0F82AD00            <1>     jc      .done
   597                              <1> 
   598 00001FBE 8B04                <1>     mov     ax, [si + 0]
   599 00001FC0 A3[7520]            <1>     mov     [.max_cyl], ax
   600                              <1> 
   601                              <1>     ; Perform seeks
   602 00001FC3 B605                <1>     mov     dh, 5
   603 00001FC5 B205                <1>     mov     dl, 5
   604 00001FC7 BE[2B27]            <1>     mov     si, diag_seek_running
   605 00001FCA E85EFA              <1>     call    video_puts_at
   606                              <1> 
   607 00001FCD C706[7720]0000      <1>     mov     word [.seek_count], 0
   608 00001FD3 C706[7920]0000      <1>     mov     word [.error_count], 0
   609                              <1> 
   610                              <1>     ; Test pattern: 0, max, 0, max/2, max, 0...
   611 00001FD9 B96400              <1>     mov     cx, 100                 ; Number of seeks
   612                              <1> 
   613                              <1> .seek_loop:
   614 00001FDC 51                  <1>     push    cx
   615                              <1> 
   616                              <1>     ; Alternate seek targets
   617 00001FDD A1[7720]            <1>     mov     ax, [.seek_count]
   618 00001FE0 83E003              <1>     and     ax, 3
   619 00001FE3 83F800              <1>     cmp     ax, 0
   620 00001FE6 740C                <1>     je      .seek_0
   621 00001FE8 83F801              <1>     cmp     ax, 1
   622 00001FEB 740B                <1>     je      .seek_max
   623 00001FED 83F802              <1>     cmp     ax, 2
   624 00001FF0 740D                <1>     je      .seek_mid
   625 00001FF2 EB00                <1>     jmp     .seek_0
   626                              <1> 
   627                              <1> .seek_0:
   628 00001FF4 31C9                <1>     xor     cx, cx
   629 00001FF6 EB0D                <1>     jmp     .do_seek
   630                              <1> 
   631                              <1> .seek_max:
   632 00001FF8 8B0E[7520]          <1>     mov     cx, [.max_cyl]
   633 00001FFC 49                  <1>     dec     cx
   634 00001FFD EB06                <1>     jmp     .do_seek
   635                              <1> 
   636                              <1> .seek_mid:
   637 00001FFF 8B0E[7520]          <1>     mov     cx, [.max_cyl]
   638 00002003 D1E9                <1>     shr     cx, 1
   639                              <1> 
   640                              <1> .do_seek:
   641                              <1>     ; Issue seek (INT 13h function 0Ch)
   642 00002005 B40C                <1>     mov     ah, 0x0C
   643 00002007 88CD                <1>     mov     ch, cl                  ; Cylinder low
   644 00002009 C1E902              <1>     shr     cx, 2
   645 0000200C 80E1C0              <1>     and     cl, 0xC0                ; Cylinder high
   646 0000200F B600                <1>     mov     dh, 0                   ; Head 0
   647 00002011 8A16[7420]          <1>     mov     dl, [.test_drive]
   648 00002015 CD13                <1>     int     0x13
   649 00002017 7304                <1>     jnc     .seek_ok
   650                              <1> 
   651 00002019 FF06[7920]          <1>     inc     word [.error_count]
   652                              <1> 
   653                              <1> .seek_ok:
   654 0000201D FF06[7720]          <1>     inc     word [.seek_count]
   655                              <1> 
   656                              <1>     ; Update display
   657 00002021 B607                <1>     mov     dh, 7
   658 00002023 B205                <1>     mov     dl, 5
   659 00002025 B407                <1>     mov     ah, ATTR_NORMAL
   660 00002027 BE[4027]            <1>     mov     si, diag_seeks_done
   661 0000202A E8FEF9              <1>     call    video_puts_at
   662 0000202D 80C20D              <1>     add     dl, 13
   663 00002030 A1[7720]            <1>     mov     ax, [.seek_count]
   664 00002033 E8D404              <1>     call    diag_print_dec16
   665                              <1> 
   666                              <1>     ; Check ESC
   667 00002036 B401                <1>     mov     ah, 0x01
   668 00002038 CD16                <1>     int     0x16
   669 0000203A 7409                <1>     jz      .no_esc
   670 0000203C B400                <1>     mov     ah, 0x00
   671 0000203E CD16                <1>     int     0x16
   672 00002040 80FC01              <1>     cmp     ah, KEY_ESC
   673 00002043 7404                <1>     je      .seek_done
   674                              <1> .no_esc:
   675                              <1> 
   676 00002045 59                  <1>     pop     cx
   677 00002046 E294                <1>     loop    .seek_loop
   678 00002048 51                  <1>     push    cx
   679                              <1> 
   680                              <1> .seek_done:
   681 00002049 59                  <1>     pop     cx
   682                              <1> 
   683                              <1>     ; Show results
   684 0000204A B60A                <1>     mov     dh, 10
   685 0000204C B205                <1>     mov     dl, 5
   686 0000204E B40F                <1>     mov     ah, ATTR_BRIGHT
   687 00002050 BE[4D27]            <1>     mov     si, diag_seek_complete
   688 00002053 E8D5F9              <1>     call    video_puts_at
   689                              <1> 
   690 00002056 B60C                <1>     mov     dh, 12
   691 00002058 B205                <1>     mov     dl, 5
   692 0000205A B407                <1>     mov     ah, ATTR_NORMAL
   693 0000205C BE[1027]            <1>     mov     si, diag_errors_found
   694 0000205F E8C9F9              <1>     call    video_puts_at
   695 00002062 80C20F              <1>     add     dl, 15
   696 00002065 A1[7920]            <1>     mov     ax, [.error_count]
   697 00002068 E89F04              <1>     call    diag_print_dec16
   698                              <1> 
   699                              <1> .done:
   700 0000206B E883FB              <1>     call    kbd_wait_any
   701                              <1> 
   702 0000206E 5E                  <1>     pop     si
   703 0000206F 5A                  <1>     pop     dx
   704 00002070 59                  <1>     pop     cx
   705 00002071 5B                  <1>     pop     bx
   706 00002072 58                  <1>     pop     ax
   707 00002073 C3                  <1>     ret
   708                              <1> 
   709 00002074 00                  <1> .test_drive:    db 0
   710 00002075 0000                <1> .max_cyl:       dw 0
   711 00002077 0000                <1> .seek_count:    dw 0
   712 00002079 0000                <1> .error_count:   dw 0
   713                              <1> 
   714                              <1> ;==============================================================================
   715                              <1> ; Flux Histogram Display
   716                              <1> ;==============================================================================
   717                              <1> diag_flux_histogram:
   718 0000207B 50                  <1>     push    ax
   719 0000207C 53                  <1>     push    bx
   720 0000207D 51                  <1>     push    cx
   721 0000207E 52                  <1>     push    dx
   722 0000207F 56                  <1>     push    si
   723 00002080 57                  <1>     push    di
   724                              <1> 
   725 00002081 E845F9              <1>     call    video_clear_screen
   726                              <1> 
   727 00002084 B41F                <1>     mov     ah, ATTR_TITLE
   728 00002086 B600                <1>     mov     dh, 0
   729 00002088 BE[6027]            <1>     mov     si, diag_flux_title
   730 0000208B E870FA              <1>     call    video_puts_centered
   731                              <1> 
   732                              <1>     ; Read histogram data from FPGA
   733 0000208E BF0000              <1>     mov     di, 0                   ; Bin index
   734 00002091 C706[3A21]0000      <1>     mov     word [.max_value], 0
   735                              <1> 
   736                              <1>     ; First pass: find maximum value for scaling
   737                              <1> .find_max:
   738 00002097 B80002              <1>     mov     ax, INSTR_HIST_BASE
   739 0000209A 01F8                <1>     add     ax, di
   740 0000209C 01F8                <1>     add     ax, di
   741 0000209E 01F8                <1>     add     ax, di
   742 000020A0 01F8                <1>     add     ax, di                  ; AX = base + bin*4
   743                              <1>     INSTR_SET_ADDR
   175 000020A2 52                  <2>  push dx
   176 000020A3 8B16[C931]          <2>  mov dx, [current_base]
   177 000020A7 81C2C000            <2>  add dx, INSTR_REG_BASE + INSTR_ADDR_LO
   178 000020AB EE                  <2>  out dx, al
   179 000020AC 42                  <2>  inc dx
   180 000020AD 88E0                <2>  mov al, ah
   181 000020AF EE                  <2>  out dx, al
   182 000020B0 5A                  <2>  pop dx
   744                              <1>     INSTR_READ_DATA                 ; DX:AX = 32-bit value
   189 000020B1 53                  <2>  push bx
   190 000020B2 8B16[C931]          <2>  mov dx, [current_base]
   191 000020B6 81C2C200            <2>  add dx, INSTR_REG_BASE + INSTR_DATA_0
   192 000020BA EC                  <2>  in al, dx
   193 000020BB 88C3                <2>  mov bl, al
   194 000020BD 42                  <2>  inc dx
   195 000020BE EC                  <2>  in al, dx
   196 000020BF 88C7                <2>  mov bh, al
   197 000020C1 42                  <2>  inc dx
   198 000020C2 EC                  <2>  in al, dx
   199 000020C3 88C1                <2>  mov cl, al
   200 000020C5 42                  <2>  inc dx
   201 000020C6 EC                  <2>  in al, dx
   202 000020C7 88C5                <2>  mov ch, al
   203                              <2> 
   204 000020C9 89D8                <2>  mov ax, bx
   205 000020CB 89CA                <2>  mov dx, cx
   206 000020CD 5B                  <2>  pop bx
   745                              <1> 
   746                              <1>     ; Store in buffer (just low 16 bits for display)
   747 000020CE 89FB                <1>     mov     bx, di
   748 000020D0 D1E3                <1>     shl     bx, 1
   749 000020D2 8987[A928]          <1>     mov     [histogram_buf + bx], ax
   750                              <1> 
   751                              <1>     ; Update max
   752 000020D6 3B06[3A21]          <1>     cmp     ax, [.max_value]
   753 000020DA 7603                <1>     jbe     .not_max
   754 000020DC A3[3A21]            <1>     mov     [.max_value], ax
   755                              <1> .not_max:
   756                              <1> 
   757 000020DF 47                  <1>     inc     di
   758 000020E0 83FF20              <1>     cmp     di, 32                  ; Only show 32 bins (fit on screen)
   759 000020E3 72B2                <1>     jb      .find_max
   760                              <1> 
   761                              <1>     ; Draw histogram bars
   762 000020E5 BF0000              <1>     mov     di, 0                   ; Bin index
   763 000020E8 B20A                <1>     mov     dl, 10                  ; Starting column
   764                              <1> 
   765                              <1> .draw_bar:
   766 000020EA 89FB                <1>     mov     bx, di
   767 000020EC D1E3                <1>     shl     bx, 1
   768 000020EE 8B87[A928]          <1>     mov     ax, [histogram_buf + bx]
   769                              <1> 
   770                              <1>     ; Scale to 0-16 (bar height)
   771 000020F2 8B1E[3A21]          <1>     mov     bx, [.max_value]
   772 000020F6 85DB                <1>     test    bx, bx
   773 000020F8 7409                <1>     jz      .zero_bar
   774                              <1> 
   775 000020FA B91000              <1>     mov     cx, 16
   776 000020FD F7E1                <1>     mul     cx
   777 000020FF F7F3                <1>     div     bx                      ; AL = scaled height (0-16)
   778 00002101 EB02                <1>     jmp     .got_height
   779                              <1> 
   780                              <1> .zero_bar:
   781 00002103 30C0                <1>     xor     al, al
   782                              <1> 
   783                              <1> .got_height:
   784                              <1>     ; Draw vertical bar from bottom up
   785 00002105 88C1                <1>     mov     cl, al                  ; Height
   786 00002107 B614                <1>     mov     dh, 20                  ; Bottom row
   787                              <1> 
   788                              <1> .bar_loop:
   789 00002109 84C9                <1>     test    cl, cl
   790 0000210B 740D                <1>     jz      .bar_done
   791                              <1> 
   792 0000210D B0DB                <1>     mov     al, PROG_FULL
   793 0000210F B42F                <1>     mov     ah, ATTR_SUCCESS
   794 00002111 E8E6F8              <1>     call    video_putc_at
   795 00002114 FECE                <1>     dec     dh
   796 00002116 FEC9                <1>     dec     cl
   797 00002118 EBEF                <1>     jmp     .bar_loop
   798                              <1> 
   799                              <1> .bar_done:
   800                              <1>     ; Next bin
   801 0000211A FEC2                <1>     inc     dl
   802 0000211C FEC2                <1>     inc     dl                      ; 2 columns per bar
   803 0000211E 47                  <1>     inc     di
   804 0000211F 83FF20              <1>     cmp     di, 32
   805 00002122 72C6                <1>     jb      .draw_bar
   806                              <1> 
   807                              <1>     ; Draw axis labels
   808 00002124 B616                <1>     mov     dh, 22
   809 00002126 B20A                <1>     mov     dl, 10
   810 00002128 B408                <1>     mov     ah, ATTR_DIM
   811 0000212A BE[7127]            <1>     mov     si, diag_flux_axis
   812 0000212D E8FBF8              <1>     call    video_puts_at
   813                              <1> 
   814 00002130 E8BEFA              <1>     call    kbd_wait_any
   815                              <1> 
   816 00002133 5F                  <1>     pop     di
   817 00002134 5E                  <1>     pop     si
   818 00002135 5A                  <1>     pop     dx
   819 00002136 59                  <1>     pop     cx
   820 00002137 5B                  <1>     pop     bx
   821 00002138 58                  <1>     pop     ax
   822 00002139 C3                  <1>     ret
   823                              <1> 
   824 0000213A 0000                <1> .max_value:     dw 0
   825                              <1> 
   826                              <1> ;==============================================================================
   827                              <1> ; Error Log Viewer
   828                              <1> ;==============================================================================
   829                              <1> diag_error_log:
   830 0000213C 50                  <1>     push    ax
   831 0000213D 53                  <1>     push    bx
   832 0000213E 51                  <1>     push    cx
   833 0000213F 52                  <1>     push    dx
   834 00002140 56                  <1>     push    si
   835                              <1> 
   836 00002141 E885F8              <1>     call    video_clear_screen
   837                              <1> 
   838 00002144 B41F                <1>     mov     ah, ATTR_TITLE
   839 00002146 B600                <1>     mov     dh, 0
   840 00002148 BE[9527]            <1>     mov     si, diag_errlog_title
   841 0000214B E8B0F9              <1>     call    video_puts_centered
   842                              <1> 
   843                              <1>     ; Header
   844 0000214E B602                <1>     mov     dh, 2
   845 00002150 B203                <1>     mov     dl, 3
   846 00002152 B40E                <1>     mov     ah, ATTR_HIGHLIGHT
   847 00002154 BE[A127]            <1>     mov     si, diag_errlog_hdr
   848 00002157 E8D1F8              <1>     call    video_puts_at
   849                              <1> 
   850                              <1>     ; Read and display error log entries
   851 0000215A B90000              <1>     mov     cx, 0                   ; Entry index
   852 0000215D B604                <1>     mov     dh, 4                   ; Starting row
   853                              <1> 
   854                              <1> .log_loop:
   855 0000215F 51                  <1>     push    cx
   856 00002160 52                  <1>     push    dx
   857                              <1> 
   858                              <1>     ; Calculate entry address
   859 00002161 B80003              <1>     mov     ax, INSTR_LOG_BASE
   860 00002164 89CB                <1>     mov     bx, cx
   861 00002166 C1E304              <1>     shl     bx, 4                   ; *16 bytes per entry
   862 00002169 01D8                <1>     add     ax, bx
   863                              <1> 
   864                              <1>     ; Read timestamp
   865                              <1>     INSTR_SET_ADDR
   175 0000216B 52                  <2>  push dx
   176 0000216C 8B16[C931]          <2>  mov dx, [current_base]
   177 00002170 81C2C000            <2>  add dx, INSTR_REG_BASE + INSTR_ADDR_LO
   178 00002174 EE                  <2>  out dx, al
   179 00002175 42                  <2>  inc dx
   180 00002176 88E0                <2>  mov al, ah
   181 00002178 EE                  <2>  out dx, al
   182 00002179 5A                  <2>  pop dx
   866                              <1>     INSTR_READ_DATA
   189 0000217A 53                  <2>  push bx
   190 0000217B 8B16[C931]          <2>  mov dx, [current_base]
   191 0000217F 81C2C200            <2>  add dx, INSTR_REG_BASE + INSTR_DATA_0
   192 00002183 EC                  <2>  in al, dx
   193 00002184 88C3                <2>  mov bl, al
   194 00002186 42                  <2>  inc dx
   195 00002187 EC                  <2>  in al, dx
   196 00002188 88C7                <2>  mov bh, al
   197 0000218A 42                  <2>  inc dx
   198 0000218B EC                  <2>  in al, dx
   199 0000218C 88C1                <2>  mov cl, al
   200 0000218E 42                  <2>  inc dx
   201 0000218F EC                  <2>  in al, dx
   202 00002190 88C5                <2>  mov ch, al
   203                              <2> 
   204 00002192 89D8                <2>  mov ax, bx
   205 00002194 89CA                <2>  mov dx, cx
   206 00002196 5B                  <2>  pop bx
   867 00002197 A3[C921]            <1>     mov     [.timestamp], ax
   868                              <1> 
   869                              <1>     ; Skip if timestamp is 0 (empty entry)
   870 0000219A 85C0                <1>     test    ax, ax
   871 0000219C 7418                <1>     jz      .skip_entry
   872                              <1> 
   873                              <1>     ; Read CHS
   874 0000219E 5A                  <1>     pop     dx
   875 0000219F 52                  <1>     push    dx
   876 000021A0 B203                <1>     mov     dl, 3
   877 000021A2 B407                <1>     mov     ah, ATTR_NORMAL
   878                              <1> 
   879                              <1>     ; Entry number
   880 000021A4 5B                  <1>     pop     bx
   881 000021A5 53                  <1>     push    bx
   882 000021A6 89D8                <1>     mov     ax, bx
   883 000021A8 E85F03              <1>     call    diag_print_dec16
   884                              <1> 
   885 000021AB 80C204              <1>     add     dl, 4
   886                              <1> 
   887                              <1>     ; Timestamp
   888 000021AE A1[C921]            <1>     mov     ax, [.timestamp]
   889 000021B1 E85603              <1>     call    diag_print_dec16
   890                              <1> 
   891                              <1>     ; (Would read more fields here - simplified for brevity)
   892 000021B4 EB00                <1>     jmp     .next_entry
   893                              <1> 
   894                              <1> .skip_entry:
   895                              <1> .next_entry:
   896 000021B6 5A                  <1>     pop     dx
   897 000021B7 59                  <1>     pop     cx
   898 000021B8 FEC6                <1>     inc     dh
   899 000021BA 41                  <1>     inc     cx
   900 000021BB 83F910              <1>     cmp     cx, INSTR_LOG_ENTRIES
   901 000021BE 729F                <1>     jb      .log_loop
   902                              <1> 
   903 000021C0 E82EFA              <1>     call    kbd_wait_any
   904                              <1> 
   905 000021C3 5E                  <1>     pop     si
   906 000021C4 5A                  <1>     pop     dx
   907 000021C5 59                  <1>     pop     cx
   908 000021C6 5B                  <1>     pop     bx
   909 000021C7 58                  <1>     pop     ax
   910 000021C8 C3                  <1>     ret
   911                              <1> 
   912 000021C9 0000                <1> .timestamp:     dw 0
   913                              <1> 
   914                              <1> ;==============================================================================
   915                              <1> ; Health Monitor
   916                              <1> ;==============================================================================
   917                              <1> diag_health_monitor:
   918 000021CB 50                  <1>     push    ax
   919 000021CC 53                  <1>     push    bx
   920 000021CD 51                  <1>     push    cx
   921 000021CE 52                  <1>     push    dx
   922 000021CF 56                  <1>     push    si
   923                              <1> 
   924 000021D0 E8F6F7              <1>     call    video_clear_screen
   925                              <1> 
   926 000021D3 B41F                <1>     mov     ah, ATTR_TITLE
   927 000021D5 B600                <1>     mov     dh, 0
   928 000021D7 BE[C527]            <1>     mov     si, diag_health_title
   929 000021DA E821F9              <1>     call    video_puts_centered
   930                              <1> 
   931                              <1>     ; Read health scores from FPGA
   932 000021DD B80001              <1>     mov     ax, INSTR_HEALTH_SCORE
   933                              <1>     INSTR_SET_ADDR
   175 000021E0 52                  <2>  push dx
   176 000021E1 8B16[C931]          <2>  mov dx, [current_base]
   177 000021E5 81C2C000            <2>  add dx, INSTR_REG_BASE + INSTR_ADDR_LO
   178 000021E9 EE                  <2>  out dx, al
   179 000021EA 42                  <2>  inc dx
   180 000021EB 88E0                <2>  mov al, ah
   181 000021ED EE                  <2>  out dx, al
   182 000021EE 5A                  <2>  pop dx
   934                              <1>     INSTR_READ_DATA
   189 000021EF 53                  <2>  push bx
   190 000021F0 8B16[C931]          <2>  mov dx, [current_base]
   191 000021F4 81C2C200            <2>  add dx, INSTR_REG_BASE + INSTR_DATA_0
   192 000021F8 EC                  <2>  in al, dx
   193 000021F9 88C3                <2>  mov bl, al
   194 000021FB 42                  <2>  inc dx
   195 000021FC EC                  <2>  in al, dx
   196 000021FD 88C7                <2>  mov bh, al
   197 000021FF 42                  <2>  inc dx
   198 00002200 EC                  <2>  in al, dx
   199 00002201 88C1                <2>  mov cl, al
   200 00002203 42                  <2>  inc dx
   201 00002204 EC                  <2>  in al, dx
   202 00002205 88C5                <2>  mov ch, al
   203                              <2> 
   204 00002207 89D8                <2>  mov ax, bx
   205 00002209 89CA                <2>  mov dx, cx
   206 0000220B 5B                  <2>  pop bx
   935 0000220C A3[6B23]            <1>     mov     [.overall], ax
   936                              <1> 
   937 0000220F B80401              <1>     mov     ax, INSTR_MEDIA_SCORE
   938                              <1>     INSTR_SET_ADDR
   175 00002212 52                  <2>  push dx
   176 00002213 8B16[C931]          <2>  mov dx, [current_base]
   177 00002217 81C2C000            <2>  add dx, INSTR_REG_BASE + INSTR_ADDR_LO
   178 0000221B EE                  <2>  out dx, al
   179 0000221C 42                  <2>  inc dx
   180 0000221D 88E0                <2>  mov al, ah
   181 0000221F EE                  <2>  out dx, al
   182 00002220 5A                  <2>  pop dx
   939                              <1>     INSTR_READ_DATA
   189 00002221 53                  <2>  push bx
   190 00002222 8B16[C931]          <2>  mov dx, [current_base]
   191 00002226 81C2C200            <2>  add dx, INSTR_REG_BASE + INSTR_DATA_0
   192 0000222A EC                  <2>  in al, dx
   193 0000222B 88C3                <2>  mov bl, al
   194 0000222D 42                  <2>  inc dx
   195 0000222E EC                  <2>  in al, dx
   196 0000222F 88C7                <2>  mov bh, al
   197 00002231 42                  <2>  inc dx
   198 00002232 EC                  <2>  in al, dx
   199 00002233 88C1                <2>  mov cl, al
   200 00002235 42                  <2>  inc dx
   201 00002236 EC                  <2>  in al, dx
   202 00002237 88C5                <2>  mov ch, al
   203                              <2> 
   204 00002239 89D8                <2>  mov ax, bx
   205 0000223B 89CA                <2>  mov dx, cx
   206 0000223D 5B                  <2>  pop bx
   940 0000223E A3[6D23]            <1>     mov     [.media], ax
   941                              <1> 
   942 00002241 B80801              <1>     mov     ax, INSTR_HEAD_SCORE
   943                              <1>     INSTR_SET_ADDR
   175 00002244 52                  <2>  push dx
   176 00002245 8B16[C931]          <2>  mov dx, [current_base]
   177 00002249 81C2C000            <2>  add dx, INSTR_REG_BASE + INSTR_ADDR_LO
   178 0000224D EE                  <2>  out dx, al
   179 0000224E 42                  <2>  inc dx
   180 0000224F 88E0                <2>  mov al, ah
   181 00002251 EE                  <2>  out dx, al
   182 00002252 5A                  <2>  pop dx
   944                              <1>     INSTR_READ_DATA
   189 00002253 53                  <2>  push bx
   190 00002254 8B16[C931]          <2>  mov dx, [current_base]
   191 00002258 81C2C200            <2>  add dx, INSTR_REG_BASE + INSTR_DATA_0
   192 0000225C EC                  <2>  in al, dx
   193 0000225D 88C3                <2>  mov bl, al
   194 0000225F 42                  <2>  inc dx
   195 00002260 EC                  <2>  in al, dx
   196 00002261 88C7                <2>  mov bh, al
   197 00002263 42                  <2>  inc dx
   198 00002264 EC                  <2>  in al, dx
   199 00002265 88C1                <2>  mov cl, al
   200 00002267 42                  <2>  inc dx
   201 00002268 EC                  <2>  in al, dx
   202 00002269 88C5                <2>  mov ch, al
   203                              <2> 
   204 0000226B 89D8                <2>  mov ax, bx
   205 0000226D 89CA                <2>  mov dx, cx
   206 0000226F 5B                  <2>  pop bx
   945 00002270 A3[6F23]            <1>     mov     [.head], ax
   946                              <1> 
   947 00002273 B80C01              <1>     mov     ax, INSTR_SPINDLE_SCORE
   948                              <1>     INSTR_SET_ADDR
   175 00002276 52                  <2>  push dx
   176 00002277 8B16[C931]          <2>  mov dx, [current_base]
   177 0000227B 81C2C000            <2>  add dx, INSTR_REG_BASE + INSTR_ADDR_LO
   178 0000227F EE                  <2>  out dx, al
   179 00002280 42                  <2>  inc dx
   180 00002281 88E0                <2>  mov al, ah
   181 00002283 EE                  <2>  out dx, al
   182 00002284 5A                  <2>  pop dx
   949                              <1>     INSTR_READ_DATA
   189 00002285 53                  <2>  push bx
   190 00002286 8B16[C931]          <2>  mov dx, [current_base]
   191 0000228A 81C2C200            <2>  add dx, INSTR_REG_BASE + INSTR_DATA_0
   192 0000228E EC                  <2>  in al, dx
   193 0000228F 88C3                <2>  mov bl, al
   194 00002291 42                  <2>  inc dx
   195 00002292 EC                  <2>  in al, dx
   196 00002293 88C7                <2>  mov bh, al
   197 00002295 42                  <2>  inc dx
   198 00002296 EC                  <2>  in al, dx
   199 00002297 88C1                <2>  mov cl, al
   200 00002299 42                  <2>  inc dx
   201 0000229A EC                  <2>  in al, dx
   202 0000229B 88C5                <2>  mov ch, al
   203                              <2> 
   204 0000229D 89D8                <2>  mov ax, bx
   205 0000229F 89CA                <2>  mov dx, cx
   206 000022A1 5B                  <2>  pop bx
   950 000022A2 A3[7123]            <1>     mov     [.spindle], ax
   951                              <1> 
   952                              <1>     ; Display scores with progress bars
   953 000022A5 B604                <1>     mov     dh, 4
   954 000022A7 B205                <1>     mov     dl, 5
   955 000022A9 BE[DC27]            <1>     mov     si, diag_health_overall
   956 000022AC E87CF7              <1>     call    video_puts_at
   957                              <1> 
   958 000022AF B604                <1>     mov     dh, 4
   959 000022B1 B219                <1>     mov     dl, 25
   960 000022B3 B128                <1>     mov     cl, 40                  ; Bar width
   961 000022B5 A0[6B23]            <1>     mov     al, [.overall]
   962 000022B8 B42F                <1>     mov     ah, ATTR_SUCCESS
   963 000022BA 3C32                <1>     cmp     al, 50
   964 000022BC 7302                <1>     jae     .overall_color_ok
   965 000022BE B44F                <1>     mov     ah, ATTR_ERROR
   966                              <1> .overall_color_ok:
   967 000022C0 E8F5F7              <1>     call    video_progress_bar
   968                              <1> 
   969                              <1>     ; Media score
   970 000022C3 B606                <1>     mov     dh, 6
   971 000022C5 B205                <1>     mov     dl, 5
   972 000022C7 BE[EC27]            <1>     mov     si, diag_health_media
   973 000022CA E85EF7              <1>     call    video_puts_at
   974 000022CD B606                <1>     mov     dh, 6
   975 000022CF B219                <1>     mov     dl, 25
   976 000022D1 A0[6D23]            <1>     mov     al, [.media]
   977 000022D4 B407                <1>     mov     ah, ATTR_NORMAL
   978 000022D6 E8DFF7              <1>     call    video_progress_bar
   979                              <1> 
   980                              <1>     ; Head score
   981 000022D9 B608                <1>     mov     dh, 8
   982 000022DB B205                <1>     mov     dl, 5
   983 000022DD BE[FC27]            <1>     mov     si, diag_health_head
   984 000022E0 E848F7              <1>     call    video_puts_at
   985 000022E3 B608                <1>     mov     dh, 8
   986 000022E5 B219                <1>     mov     dl, 25
   987 000022E7 A0[6F23]            <1>     mov     al, [.head]
   988 000022EA E8CBF7              <1>     call    video_progress_bar
   989                              <1> 
   990                              <1>     ; Spindle score
   991 000022ED B60A                <1>     mov     dh, 10
   992 000022EF B205                <1>     mov     dl, 5
   993 000022F1 BE[0C28]            <1>     mov     si, diag_health_spindle
   994 000022F4 E834F7              <1>     call    video_puts_at
   995 000022F7 B60A                <1>     mov     dh, 10
   996 000022F9 B219                <1>     mov     dl, 25
   997 000022FB A0[7123]            <1>     mov     al, [.spindle]
   998 000022FE E8B7F7              <1>     call    video_progress_bar
   999                              <1> 
  1000                              <1>     ; Temperature
  1001 00002301 B81001              <1>     mov     ax, INSTR_TEMP_DRIVE
  1002                              <1>     INSTR_SET_ADDR
   175 00002304 52                  <2>  push dx
   176 00002305 8B16[C931]          <2>  mov dx, [current_base]
   177 00002309 81C2C000            <2>  add dx, INSTR_REG_BASE + INSTR_ADDR_LO
   178 0000230D EE                  <2>  out dx, al
   179 0000230E 42                  <2>  inc dx
   180 0000230F 88E0                <2>  mov al, ah
   181 00002311 EE                  <2>  out dx, al
   182 00002312 5A                  <2>  pop dx
  1003                              <1>     INSTR_READ_DATA
   189 00002313 53                  <2>  push bx
   190 00002314 8B16[C931]          <2>  mov dx, [current_base]
   191 00002318 81C2C200            <2>  add dx, INSTR_REG_BASE + INSTR_DATA_0
   192 0000231C EC                  <2>  in al, dx
   193 0000231D 88C3                <2>  mov bl, al
   194 0000231F 42                  <2>  inc dx
   195 00002320 EC                  <2>  in al, dx
   196 00002321 88C7                <2>  mov bh, al
   197 00002323 42                  <2>  inc dx
   198 00002324 EC                  <2>  in al, dx
   199 00002325 88C1                <2>  mov cl, al
   200 00002327 42                  <2>  inc dx
   201 00002328 EC                  <2>  in al, dx
   202 00002329 88C5                <2>  mov ch, al
   203                              <2> 
   204 0000232B 89D8                <2>  mov ax, bx
   205 0000232D 89CA                <2>  mov dx, cx
   206 0000232F 5B                  <2>  pop bx
  1004 00002330 A3[7323]            <1>     mov     [.temp], ax
  1005                              <1> 
  1006 00002333 B60D                <1>     mov     dh, 13
  1007 00002335 B205                <1>     mov     dl, 5
  1008 00002337 BE[1C28]            <1>     mov     si, diag_health_temp
  1009 0000233A E8EEF6              <1>     call    video_puts_at
  1010 0000233D 80C212              <1>     add     dl, 18
  1011 00002340 A1[7323]            <1>     mov     ax, [.temp]
  1012 00002343 B30A                <1>     mov     bl, 10
  1013 00002345 F6F3                <1>     div     bl                      ; AL = degrees, AH = decimal
  1014 00002347 50                  <1>     push    ax
  1015 00002348 30E4                <1>     xor     ah, ah
  1016 0000234A E8BD01              <1>     call    diag_print_dec16
  1017 0000234D B02E                <1>     mov     al, '.'
  1018 0000234F E8A8F6              <1>     call    video_putc_at
  1019 00002352 FEC2                <1>     inc     dl
  1020 00002354 58                  <1>     pop     ax
  1021 00002355 88E0                <1>     mov     al, ah
  1022 00002357 30E4                <1>     xor     ah, ah
  1023 00002359 E8AE01              <1>     call    diag_print_dec16
  1024 0000235C BE[2F28]            <1>     mov     si, diag_celsius
  1025 0000235F E8C9F6              <1>     call    video_puts_at
  1026                              <1> 
  1027 00002362 E88CF8              <1>     call    kbd_wait_any
  1028                              <1> 
  1029 00002365 5E                  <1>     pop     si
  1030 00002366 5A                  <1>     pop     dx
  1031 00002367 59                  <1>     pop     cx
  1032 00002368 5B                  <1>     pop     bx
  1033 00002369 58                  <1>     pop     ax
  1034 0000236A C3                  <1>     ret
  1035                              <1> 
  1036 0000236B 0000                <1> .overall:   dw 0
  1037 0000236D 0000                <1> .media:     dw 0
  1038 0000236F 0000                <1> .head:      dw 0
  1039 00002371 0000                <1> .spindle:   dw 0
  1040 00002373 0000                <1> .temp:      dw 0
  1041                              <1> 
  1042                              <1> ;==============================================================================
  1043                              <1> ; Signal Quality Display
  1044                              <1> ;==============================================================================
  1045                              <1> diag_signal_quality:
  1046 00002375 50                  <1>     push    ax
  1047 00002376 53                  <1>     push    bx
  1048 00002377 51                  <1>     push    cx
  1049 00002378 52                  <1>     push    dx
  1050 00002379 56                  <1>     push    si
  1051                              <1> 
  1052 0000237A E84CF6              <1>     call    video_clear_screen
  1053                              <1> 
  1054 0000237D B41F                <1>     mov     ah, ATTR_TITLE
  1055 0000237F B600                <1>     mov     dh, 0
  1056 00002381 BE[3228]            <1>     mov     si, diag_signal_title
  1057 00002384 E877F7              <1>     call    video_puts_centered
  1058                              <1> 
  1059                              <1>     ; Read signal quality from FPGA
  1060 00002387 B8C000              <1>     mov     ax, INSTR_SIG_AMPLITUDE
  1061                              <1>     INSTR_SET_ADDR
   175 0000238A 52                  <2>  push dx
   176 0000238B 8B16[C931]          <2>  mov dx, [current_base]
   177 0000238F 81C2C000            <2>  add dx, INSTR_REG_BASE + INSTR_ADDR_LO
   178 00002393 EE                  <2>  out dx, al
   179 00002394 42                  <2>  inc dx
   180 00002395 88E0                <2>  mov al, ah
   181 00002397 EE                  <2>  out dx, al
   182 00002398 5A                  <2>  pop dx
  1062                              <1>     INSTR_READ_DATA
   189 00002399 53                  <2>  push bx
   190 0000239A 8B16[C931]          <2>  mov dx, [current_base]
   191 0000239E 81C2C200            <2>  add dx, INSTR_REG_BASE + INSTR_DATA_0
   192 000023A2 EC                  <2>  in al, dx
   193 000023A3 88C3                <2>  mov bl, al
   194 000023A5 42                  <2>  inc dx
   195 000023A6 EC                  <2>  in al, dx
   196 000023A7 88C7                <2>  mov bh, al
   197 000023A9 42                  <2>  inc dx
   198 000023AA EC                  <2>  in al, dx
   199 000023AB 88C1                <2>  mov cl, al
   200 000023AD 42                  <2>  inc dx
   201 000023AE EC                  <2>  in al, dx
   202 000023AF 88C5                <2>  mov ch, al
   203                              <2> 
   204 000023B1 89D8                <2>  mov ax, bx
   205 000023B3 89CA                <2>  mov dx, cx
   206 000023B5 5B                  <2>  pop bx
  1063 000023B6 A3[DE24]            <1>     mov     [.amplitude], ax
  1064                              <1> 
  1065 000023B9 B8C400              <1>     mov     ax, INSTR_SIG_SNR
  1066                              <1>     INSTR_SET_ADDR
   175 000023BC 52                  <2>  push dx
   176 000023BD 8B16[C931]          <2>  mov dx, [current_base]
   177 000023C1 81C2C000            <2>  add dx, INSTR_REG_BASE + INSTR_ADDR_LO
   178 000023C5 EE                  <2>  out dx, al
   179 000023C6 42                  <2>  inc dx
   180 000023C7 88E0                <2>  mov al, ah
   181 000023C9 EE                  <2>  out dx, al
   182 000023CA 5A                  <2>  pop dx
  1067                              <1>     INSTR_READ_DATA
   189 000023CB 53                  <2>  push bx
   190 000023CC 8B16[C931]          <2>  mov dx, [current_base]
   191 000023D0 81C2C200            <2>  add dx, INSTR_REG_BASE + INSTR_DATA_0
   192 000023D4 EC                  <2>  in al, dx
   193 000023D5 88C3                <2>  mov bl, al
   194 000023D7 42                  <2>  inc dx
   195 000023D8 EC                  <2>  in al, dx
   196 000023D9 88C7                <2>  mov bh, al
   197 000023DB 42                  <2>  inc dx
   198 000023DC EC                  <2>  in al, dx
   199 000023DD 88C1                <2>  mov cl, al
   200 000023DF 42                  <2>  inc dx
   201 000023E0 EC                  <2>  in al, dx
   202 000023E1 88C5                <2>  mov ch, al
   203                              <2> 
   204 000023E3 89D8                <2>  mov ax, bx
   205 000023E5 89CA                <2>  mov dx, cx
   206 000023E7 5B                  <2>  pop bx
  1068 000023E8 A3[E024]            <1>     mov     [.snr], ax
  1069                              <1> 
  1070 000023EB B8C800              <1>     mov     ax, INSTR_SIG_JITTER
  1071                              <1>     INSTR_SET_ADDR
   175 000023EE 52                  <2>  push dx
   176 000023EF 8B16[C931]          <2>  mov dx, [current_base]
   177 000023F3 81C2C000            <2>  add dx, INSTR_REG_BASE + INSTR_ADDR_LO
   178 000023F7 EE                  <2>  out dx, al
   179 000023F8 42                  <2>  inc dx
   180 000023F9 88E0                <2>  mov al, ah
   181 000023FB EE                  <2>  out dx, al
   182 000023FC 5A                  <2>  pop dx
  1072                              <1>     INSTR_READ_DATA
   189 000023FD 53                  <2>  push bx
   190 000023FE 8B16[C931]          <2>  mov dx, [current_base]
   191 00002402 81C2C200            <2>  add dx, INSTR_REG_BASE + INSTR_DATA_0
   192 00002406 EC                  <2>  in al, dx
   193 00002407 88C3                <2>  mov bl, al
   194 00002409 42                  <2>  inc dx
   195 0000240A EC                  <2>  in al, dx
   196 0000240B 88C7                <2>  mov bh, al
   197 0000240D 42                  <2>  inc dx
   198 0000240E EC                  <2>  in al, dx
   199 0000240F 88C1                <2>  mov cl, al
   200 00002411 42                  <2>  inc dx
   201 00002412 EC                  <2>  in al, dx
   202 00002413 88C5                <2>  mov ch, al
   203                              <2> 
   204 00002415 89D8                <2>  mov ax, bx
   205 00002417 89CA                <2>  mov dx, cx
   206 00002419 5B                  <2>  pop bx
  1073 0000241A A3[E224]            <1>     mov     [.jitter], ax
  1074                              <1> 
  1075 0000241D B8D000              <1>     mov     ax, INSTR_PLL_LOCK
  1076                              <1>     INSTR_SET_ADDR
   175 00002420 52                  <2>  push dx
   176 00002421 8B16[C931]          <2>  mov dx, [current_base]
   177 00002425 81C2C000            <2>  add dx, INSTR_REG_BASE + INSTR_ADDR_LO
   178 00002429 EE                  <2>  out dx, al
   179 0000242A 42                  <2>  inc dx
   180 0000242B 88E0                <2>  mov al, ah
   181 0000242D EE                  <2>  out dx, al
   182 0000242E 5A                  <2>  pop dx
  1077                              <1>     INSTR_READ_DATA
   189 0000242F 53                  <2>  push bx
   190 00002430 8B16[C931]          <2>  mov dx, [current_base]
   191 00002434 81C2C200            <2>  add dx, INSTR_REG_BASE + INSTR_DATA_0
   192 00002438 EC                  <2>  in al, dx
   193 00002439 88C3                <2>  mov bl, al
   194 0000243B 42                  <2>  inc dx
   195 0000243C EC                  <2>  in al, dx
   196 0000243D 88C7                <2>  mov bh, al
   197 0000243F 42                  <2>  inc dx
   198 00002440 EC                  <2>  in al, dx
   199 00002441 88C1                <2>  mov cl, al
   200 00002443 42                  <2>  inc dx
   201 00002444 EC                  <2>  in al, dx
   202 00002445 88C5                <2>  mov ch, al
   203                              <2> 
   204 00002447 89D8                <2>  mov ax, bx
   205 00002449 89CA                <2>  mov dx, cx
   206 0000244B 5B                  <2>  pop bx
  1078 0000244C A3[E424]            <1>     mov     [.pll_lock], ax
  1079                              <1> 
  1080                              <1>     ; Display values
  1081 0000244F B604                <1>     mov     dh, 4
  1082 00002451 B205                <1>     mov     dl, 5
  1083 00002453 B407                <1>     mov     ah, ATTR_NORMAL
  1084 00002455 BE[4328]            <1>     mov     si, diag_sig_amplitude
  1085 00002458 E8D0F5              <1>     call    video_puts_at
  1086 0000245B 80C214              <1>     add     dl, 20
  1087 0000245E A1[DE24]            <1>     mov     ax, [.amplitude]
  1088 00002461 E8A600              <1>     call    diag_print_dec16
  1089 00002464 BE[8D28]            <1>     mov     si, diag_mv_suffix
  1090 00002467 E8C1F5              <1>     call    video_puts_at
  1091                              <1> 
  1092 0000246A B606                <1>     mov     dh, 6
  1093 0000246C B205                <1>     mov     dl, 5
  1094 0000246E BE[5528]            <1>     mov     si, diag_sig_snr
  1095 00002471 E8B7F5              <1>     call    video_puts_at
  1096 00002474 80C214              <1>     add     dl, 20
  1097 00002477 A1[E024]            <1>     mov     ax, [.snr]
  1098 0000247A B30A                <1>     mov     bl, 10
  1099 0000247C F6F3                <1>     div     bl
  1100 0000247E 50                  <1>     push    ax
  1101 0000247F 30E4                <1>     xor     ah, ah
  1102 00002481 E88600              <1>     call    diag_print_dec16
  1103 00002484 B02E                <1>     mov     al, '.'
  1104 00002486 E871F5              <1>     call    video_putc_at
  1105 00002489 FEC2                <1>     inc     dl
  1106 0000248B 58                  <1>     pop     ax
  1107 0000248C 88E0                <1>     mov     al, ah
  1108 0000248E 30E4                <1>     xor     ah, ah
  1109 00002490 E87700              <1>     call    diag_print_dec16
  1110 00002493 BE[9128]            <1>     mov     si, diag_db_suffix
  1111 00002496 E892F5              <1>     call    video_puts_at
  1112                              <1> 
  1113 00002499 B608                <1>     mov     dh, 8
  1114 0000249B B205                <1>     mov     dl, 5
  1115 0000249D BE[6928]            <1>     mov     si, diag_sig_jitter
  1116 000024A0 E888F5              <1>     call    video_puts_at
  1117 000024A3 80C214              <1>     add     dl, 20
  1118 000024A6 A1[E224]            <1>     mov     ax, [.jitter]
  1119 000024A9 E85E00              <1>     call    diag_print_dec16
  1120 000024AC BE[9528]            <1>     mov     si, diag_ns_suffix
  1121 000024AF E879F5              <1>     call    video_puts_at
  1122                              <1> 
  1123 000024B2 B60A                <1>     mov     dh, 10
  1124 000024B4 B205                <1>     mov     dl, 5
  1125 000024B6 BE[7B28]            <1>     mov     si, diag_sig_pll
  1126 000024B9 E86FF5              <1>     call    video_puts_at
  1127 000024BC 80C214              <1>     add     dl, 20
  1128 000024BF A1[E424]            <1>     mov     ax, [.pll_lock]
  1129 000024C2 85C0                <1>     test    ax, ax
  1130 000024C4 7407                <1>     jz      .pll_unlocked
  1131 000024C6 BE[9928]            <1>     mov     si, diag_locked
  1132 000024C9 B42F                <1>     mov     ah, ATTR_SUCCESS
  1133 000024CB EB05                <1>     jmp     .show_pll
  1134                              <1> .pll_unlocked:
  1135 000024CD BE[A028]            <1>     mov     si, diag_unlocked
  1136 000024D0 B44F                <1>     mov     ah, ATTR_ERROR
  1137                              <1> .show_pll:
  1138 000024D2 E856F5              <1>     call    video_puts_at
  1139                              <1> 
  1140 000024D5 E819F7              <1>     call    kbd_wait_any
  1141                              <1> 
  1142 000024D8 5E                  <1>     pop     si
  1143 000024D9 5A                  <1>     pop     dx
  1144 000024DA 59                  <1>     pop     cx
  1145 000024DB 5B                  <1>     pop     bx
  1146 000024DC 58                  <1>     pop     ax
  1147 000024DD C3                  <1>     ret
  1148                              <1> 
  1149 000024DE 0000                <1> .amplitude: dw 0
  1150 000024E0 0000                <1> .snr:       dw 0
  1151 000024E2 0000                <1> .jitter:    dw 0
  1152 000024E4 0000                <1> .pll_lock:  dw 0
  1153                              <1> 
  1154                              <1> ;==============================================================================
  1155                              <1> ; Calculate Capacity in MB
  1156                              <1> ;==============================================================================
  1157                              <1> ; Input: SI = pointer to FDPT
  1158                              <1> ; Output: AX = capacity in MB
  1159                              <1> ;==============================================================================
  1160                              <1> diag_calc_capacity:
  1161 000024E6 53                  <1>     push    bx
  1162 000024E7 51                  <1>     push    cx
  1163 000024E8 52                  <1>     push    dx
  1164                              <1> 
  1165                              <1>     ; Total = cyl * heads * sectors * 512 / 1048576
  1166                              <1>     ; Simplified: (cyl * heads * sectors) / 2048
  1167                              <1> 
  1168 000024E9 8B04                <1>     mov     ax, [si + 0]            ; Cylinders
  1169 000024EB 30FF                <1>     xor     bh, bh
  1170 000024ED 8A5C02              <1>     mov     bl, [si + 2]            ; Heads
  1171 000024F0 F7E3                <1>     mul     bx
  1172 000024F2 89C1                <1>     mov     cx, ax                  ; CX = cyl * heads (low)
  1173 000024F4 89D3                <1>     mov     bx, dx                  ; BX = high word
  1174                              <1> 
  1175 000024F6 30E4                <1>     xor     ah, ah
  1176 000024F8 8A4403              <1>     mov     al, [si + 3]            ; Sectors
  1177 000024FB F7E1                <1>     mul     cx                      ; DX:AX = total sectors (approximate)
  1178                              <1> 
  1179                              <1>     ; Divide by 2048 (shift right 11)
  1180 000024FD B90B00              <1>     mov     cx, 11
  1181                              <1> .shift_loop:
  1182 00002500 D1EA                <1>     shr     dx, 1
  1183 00002502 D1D8                <1>     rcr     ax, 1
  1184 00002504 E2FA                <1>     loop    .shift_loop
  1185                              <1> 
  1186 00002506 5A                  <1>     pop     dx
  1187 00002507 59                  <1>     pop     cx
  1188 00002508 5B                  <1>     pop     bx
  1189 00002509 C3                  <1>     ret
  1190                              <1> 
  1191                              <1> ;==============================================================================
  1192                              <1> ; Print 16-bit Decimal Number
  1193                              <1> ;==============================================================================
  1194                              <1> ; Input: AX = number
  1195                              <1> ;        DH = row
  1196                              <1> ;        DL = column (updated)
  1197                              <1> ;        AH (current_attr) used
  1198                              <1> ;==============================================================================
  1199                              <1> diag_print_dec16:
  1200 0000250A 50                  <1>     push    ax
  1201 0000250B 53                  <1>     push    bx
  1202 0000250C 51                  <1>     push    cx
  1203 0000250D 52                  <1>     push    dx
  1204 0000250E 56                  <1>     push    si
  1205                              <1> 
  1206 0000250F 89C3                <1>     mov     bx, ax                  ; Save number
  1207 00002511 BE[4B25]            <1>     mov     si, .buffer + 5         ; End of buffer
  1208 00002514 C60400              <1>     mov     byte [si], 0            ; Null terminate
  1209                              <1> 
  1210                              <1>     ; Convert to decimal
  1211 00002517 89D8                <1>     mov     ax, bx
  1212 00002519 B90A00              <1>     mov     cx, 10
  1213                              <1> .convert:
  1214 0000251C 4E                  <1>     dec     si
  1215 0000251D 31D2                <1>     xor     dx, dx
  1216 0000251F F7F1                <1>     div     cx                      ; AX = quotient, DX = remainder
  1217 00002521 80C230              <1>     add     dl, '0'
  1218 00002524 8814                <1>     mov     [si], dl
  1219 00002526 85C0                <1>     test    ax, ax
  1220 00002528 75F2                <1>     jnz     .convert
  1221                              <1> 
  1222                              <1>     ; Print string
  1223 0000252A 5A                  <1>     pop     dx                      ; Restore position
  1224 0000252B 52                  <1>     push    dx
  1225 0000252C 8A26[7419]          <1>     mov     ah, [current_attr]
  1226                              <1> .print:
  1227 00002530 AC                  <1>     lodsb
  1228 00002531 84C0                <1>     test    al, al
  1229 00002533 7407                <1>     jz      .done
  1230 00002535 E8C2F4              <1>     call    video_putc_at
  1231 00002538 FEC2                <1>     inc     dl
  1232 0000253A EBF4                <1>     jmp     .print
  1233                              <1> 
  1234                              <1> .done:
  1235                              <1>     ; Update column in stack
  1236 0000253C 58                  <1>     pop     ax                      ; Original DX
  1237 0000253D 58                  <1>     pop     ax                      ; Original SI
  1238 0000253E 52                  <1>     push    dx                      ; New DL
  1239 0000253F 50                  <1>     push    ax
  1240                              <1> 
  1241 00002540 5E                  <1>     pop     si
  1242 00002541 5A                  <1>     pop     dx
  1243 00002542 59                  <1>     pop     cx
  1244 00002543 5B                  <1>     pop     bx
  1245 00002544 58                  <1>     pop     ax
  1246 00002545 C3                  <1>     ret
  1247                              <1> 
  1248 00002546 00<rep 6h>          <1> .buffer: times 6 db 0
  1249                              <1> 
  1250                              <1> ;==============================================================================
  1251                              <1> ; Diagnostics Strings
  1252                              <1> ;==============================================================================
  1253 0000254C 20466C757852697070- <1> diag_title:         db " FluxRipper HDD Diagnostics ", 0
  1253 00002555 657220484444204469- <1>
  1253 0000255E 61676E6F7374696373- <1>
  1253 00002567 2000                <1>
  1254 00002569 204553433D45786974- <1> diag_status_bar:    db " ESC=Exit  1-6=Select Test ", 0
  1254 00002572 2020312D363D53656C- <1>
  1254 0000257B 656374205465737420- <1>
  1254 00002584 00                  <1>
  1255 00002585 447269766520202043- <1> diag_drive_hdr:     db "Drive   Cyl    Hd   Sec   Size", 0
  1255 0000258E 796C20202020486420- <1>
  1255 00002597 202053656320202053- <1>
  1255 000025A0 697A6500            <1>
  1256 000025A4 44726976652000      <1> diag_drive_prefix:  db "Drive ", 0
  1257 000025AB 4E6F74205072657365- <1> diag_not_present:   db "Not Present", 0
  1257 000025B4 6E7400              <1>
  1258 000025B7 204D4200            <1> diag_mb_suffix:     db " MB", 0
  1259                              <1> 
  1260 000025BB 292053757266616365- <1> diag_opt_surface:   db ") Surface Scan - Read all sectors", 0
  1260 000025C4 205363616E202D2052- <1>
  1260 000025CD 65616420616C6C2073- <1>
  1260 000025D6 6563746F727300      <1>
  1261 000025DD 29205365656B205465- <1> diag_opt_seek:      db ") Seek Test - Exercise head positioning", 0
  1261 000025E6 7374202D2045786572- <1>
  1261 000025EF 636973652068656164- <1>
  1261 000025F8 20706F736974696F6E- <1>
  1261 00002601 696E6700            <1>
  1262 00002605 2920466C7578204869- <1> diag_opt_flux:      db ") Flux Histogram - Signal analysis", 0
  1262 0000260E 73746F6772616D202D- <1>
  1262 00002617 205369676E616C2061- <1>
  1262 00002620 6E616C7973697300    <1>
  1263 00002628 29204572726F72204C- <1> diag_opt_errors:    db ") Error Log - View logged errors", 0
  1263 00002631 6F67202D2056696577- <1>
  1263 0000263A 206C6F676765642065- <1>
  1263 00002643 72726F727300        <1>
  1264 00002649 29204865616C746820- <1> diag_opt_health:    db ") Health Monitor - Drive condition", 0
  1264 00002652 4D6F6E69746F72202D- <1>
  1264 0000265B 20447269766520636F- <1>
  1264 00002664 6E646974696F6E00    <1>
  1265 0000266C 29205369676E616C20- <1> diag_opt_signal:    db ") Signal Quality - Read channel stats", 0
  1265 00002675 5175616C697479202D- <1>
  1265 0000267E 205265616420636861- <1>
  1265 00002687 6E6E656C2073746174- <1>
  1265 00002690 7300                <1>
  1266 00002692 455343292052657475- <1> diag_opt_exit:      db "ESC) Return to boot", 0
  1266 0000269B 726E20746F20626F6F- <1>
  1266 000026A4 7400                <1>
  1267                              <1> 
  1268 000026A6 53656C656374206472- <1> diag_select_drive:  db "Select drive (0 or 1): ", 0
  1268 000026AF 697665202830206F72- <1>
  1268 000026B8 2031293A2000        <1>
  1269 000026BE 4472697665206E6F74- <1> diag_no_drive:      db "Drive not present!", 0
  1269 000026C7 2070726573656E7421- <1>
  1269 000026D0 00                  <1>
  1270                              <1> 
  1271 000026D1 205375726661636520- <1> diag_surface_title: db " Surface Scan ", 0
  1271 000026DA 5363616E2000        <1>
  1272 000026E0 5363616E6E696E672E- <1> diag_scanning:      db "Scanning...", 0
  1272 000026E9 2E2E00              <1>
  1273 000026EC 43796C696E6465723A- <1> diag_cylinder:      db "Cylinder: ", 0
  1273 000026F5 2000                <1>
  1274 000026F7 4572726F722061743A- <1> diag_error_at:      db "Error at: ", 0
  1274 00002700 2000                <1>
  1275 00002702 5363616E20436F6D70- <1> diag_scan_complete: db "Scan Complete", 0
  1275 0000270B 6C65746500          <1>
  1276 00002710 4572726F727320666F- <1> diag_errors_found:  db "Errors found: ", 0
  1276 00002719 756E643A2000        <1>
  1277                              <1> 
  1278 0000271F 205365656B20546573- <1> diag_seek_title:    db " Seek Test ", 0
  1278 00002728 742000              <1>
  1279 0000272B 52756E6E696E672073- <1> diag_seek_running:  db "Running seek test...", 0
  1279 00002734 65656B20746573742E- <1>
  1279 0000273D 2E2E00              <1>
  1280 00002740 5365656B7320646F6E- <1> diag_seeks_done:    db "Seeks done: ", 0
  1280 00002749 653A2000            <1>
  1281 0000274D 5365656B2054657374- <1> diag_seek_complete: db "Seek Test Complete", 0
  1281 00002756 20436F6D706C657465- <1>
  1281 0000275F 00                  <1>
  1282                              <1> 
  1283 00002760 20466C757820486973- <1> diag_flux_title:    db " Flux Histogram ", 0
  1283 00002769 746F6772616D2000    <1>
  1284 00002771 306E73202020202020- <1> diag_flux_axis:     db "0ns                          1600ns", 0
  1284 0000277A 202020202020202020- <1>
  1284 00002783 202020202020202020- <1>
  1284 0000278C 2020313630306E7300  <1>
  1285                              <1> 
  1286 00002795 204572726F72204C6F- <1> diag_errlog_title:  db " Error Log ", 0
  1286 0000279E 672000              <1>
  1287 000027A1 232054696D65202020- <1> diag_errlog_hdr:    db "# Time   C/H/S      Type  Cmd  Info", 0
  1287 000027AA 432F482F5320202020- <1>
  1287 000027B3 202054797065202043- <1>
  1287 000027BC 6D642020496E666F00  <1>
  1288                              <1> 
  1289 000027C5 204472697665204865- <1> diag_health_title:  db " Drive Health Monitor ", 0
  1289 000027CE 616C7468204D6F6E69- <1>
  1289 000027D7 746F722000          <1>
  1290 000027DC 4F766572616C6C2048- <1> diag_health_overall: db "Overall Health:", 0
  1290 000027E5 65616C74683A00      <1>
  1291 000027EC 4D6564696120517561- <1> diag_health_media:  db "Media Quality: ", 0
  1291 000027F5 6C6974793A2000      <1>
  1292 000027FC 4865616420436F6E64- <1> diag_health_head:   db "Head Condition:", 0
  1292 00002805 6974696F6E3A00      <1>
  1293 0000280C 5370696E646C652048- <1> diag_health_spindle: db "Spindle Health:", 0
  1293 00002815 65616C74683A00      <1>
  1294 0000281C 44726976652054656D- <1> diag_health_temp:   db "Drive Temperature:", 0
  1294 00002825 70657261747572653A- <1>
  1294 0000282E 00                  <1>
  1295 0000282F 204300              <1> diag_celsius:       db " C", 0
  1296                              <1> 
  1297 00002832 205369676E616C2051- <1> diag_signal_title:  db " Signal Quality ", 0
  1297 0000283B 75616C6974792000    <1>
  1298 00002843 5369676E616C20416D- <1> diag_sig_amplitude: db "Signal Amplitude:", 0
  1298 0000284C 706C69747564653A00  <1>
  1299 00002855 5369676E616C2F4E6F- <1> diag_sig_snr:       db "Signal/Noise Ratio:", 0
  1299 0000285E 69736520526174696F- <1>
  1299 00002867 3A00                <1>
  1300 00002869 54696D696E67204A69- <1> diag_sig_jitter:    db "Timing Jitter:   ", 0
  1300 00002872 747465723A20202000  <1>
  1301 0000287B 504C4C204C6F636B20- <1> diag_sig_pll:       db "PLL Lock Status: ", 0
  1301 00002884 5374617475733A2000  <1>
  1302 0000288D 206D5600            <1> diag_mv_suffix:     db " mV", 0
  1303 00002891 20644200            <1> diag_db_suffix:     db " dB", 0
  1304 00002895 206E7300            <1> diag_ns_suffix:     db " ns", 0
  1305 00002899 4C4F434B454400      <1> diag_locked:        db "LOCKED", 0
  1306 000028A0 554E4C4F434B454400  <1> diag_unlocked:      db "UNLOCKED", 0
  1307                              <1> 
  1308                              <1> ;==============================================================================
  1309                              <1> ; Data Buffers
  1310                              <1> ;==============================================================================
  1311 000028A9 0000<rep 40h>       <1> histogram_buf:  times 64 dw 0       ; 64 16-bit histogram values
  1312 00002929 00<rep 200h>        <1> scratch_buffer: times 512 db 0      ; Sector read buffer
  1313                              <1> 
  1314                              <1> %endif ; BUILD_16KB
   232                                  %include "monitor.asm"
     1                              <1> ;==============================================================================
     2                              <1> ; FluxRipper HDD BIOS - Real-Time Monitor
     3                              <1> ;==============================================================================
     4                              <1> ; Displays real-time drive statistics in a compact overlay.
     5                              <1> ; Accessible via F3 during normal operation (hot-key TSR).
     6                              <1> ;
     7                              <1> ; Features:
     8                              <1> ;   - Live command counter
     9                              <1> ;   - Error rate display
    10                              <1> ;   - Current seek position
    11                              <1> ;   - Data transfer rate
    12                              <1> ;   - Temperature
    13                              <1> ;
    14                              <1> ; SPDX-License-Identifier: BSD-3-Clause
    15                              <1> ; Copyright (c) 2025 FluxRipper Project
    16                              <1> ;==============================================================================
    17                              <1> 
    18                              <1> %if BUILD_16KB
    19                              <1> 
    20                              <1> ;==============================================================================
    21                              <1> ; Monitor Constants
    22                              <1> ;==============================================================================
    23                              <1> %define MON_ROW         0           ; Top row of display
    24                              <1> %define MON_COL         50          ; Right side of screen
    25                              <1> %define MON_WIDTH       28          ; Width of monitor box
    26                              <1> %define MON_HEIGHT      12          ; Height of monitor box
    27                              <1> %define MON_REFRESH     9           ; Refresh every ~0.5 sec (9 ticks)
    28                              <1> 
    29                              <1> ;==============================================================================
    30                              <1> ; Monitor State
    31                              <1> ;==============================================================================
    32 00002B29 00                  <1> monitor_active:     db 0            ; 1 = monitor visible
    33 00002B2A 00<rep 150h>        <1> monitor_saved:      times 336 db 0  ; Saved screen area (28*12*1 char+attr)
    34 00002C7A 0000                <1> last_tick:          dw 0            ; Last refresh tick
    35                              <1> 
    36                              <1> ;==============================================================================
    37                              <1> ; Toggle Monitor Display
    38                              <1> ;==============================================================================
    39                              <1> ; Called when F3 is pressed during operation.
    40                              <1> ;==============================================================================
    41                              <1> monitor_toggle:
    42 00002C7C 50                  <1>     push    ax
    43 00002C7D 1E                  <1>     push    ds
    44                              <1> 
    45 00002C7E 0E                  <1>     push    cs
    46 00002C7F 1F                  <1>     pop     ds
    47                              <1> 
    48                              <1>     ; Toggle state
    49 00002C80 8036[292B]01        <1>     xor     byte [monitor_active], 1
    50 00002C85 7408                <1>     jz      .hide
    51                              <1> 
    52                              <1>     ; Show monitor
    53 00002C87 E80B00              <1>     call    monitor_save_screen
    54 00002C8A E88800              <1>     call    monitor_draw
    55 00002C8D EB03                <1>     jmp     .done
    56                              <1> 
    57                              <1> .hide:
    58 00002C8F E84300              <1>     call    monitor_restore_screen
    59                              <1> 
    60                              <1> .done:
    61 00002C92 1F                  <1>     pop     ds
    62 00002C93 58                  <1>     pop     ax
    63 00002C94 C3                  <1>     ret
    64                              <1> 
    65                              <1> ;==============================================================================
    66                              <1> ; Save Screen Area Under Monitor
    67                              <1> ;==============================================================================
    68                              <1> monitor_save_screen:
    69 00002C95 50                  <1>     push    ax
    70 00002C96 53                  <1>     push    bx
    71 00002C97 51                  <1>     push    cx
    72 00002C98 52                  <1>     push    dx
    73 00002C99 56                  <1>     push    si
    74 00002C9A 57                  <1>     push    di
    75 00002C9B 06                  <1>     push    es
    76                              <1> 
    77                              <1>     ; Source: video memory
    78 00002C9C A1[7019]            <1>     mov     ax, [video_seg]
    79 00002C9F 8EC0                <1>     mov     es, ax
    80                              <1> 
    81                              <1>     ; Calculate starting offset
    82 00002CA1 B80000              <1>     mov     ax, MON_ROW
    83 00002CA4 B3A0                <1>     mov     bl, SCREEN_WIDTH * 2
    84 00002CA6 F6E3                <1>     mul     bl
    85 00002CA8 83C064              <1>     add     ax, MON_COL * 2
    86 00002CAB 89C6                <1>     mov     si, ax
    87                              <1> 
    88                              <1>     ; Destination: save buffer
    89 00002CAD BF[2A2B]            <1>     mov     di, monitor_saved
    90                              <1> 
    91                              <1>     ; Copy rows
    92 00002CB0 B90C00              <1>     mov     cx, MON_HEIGHT
    93                              <1> .row_loop:
    94 00002CB3 51                  <1>     push    cx
    95 00002CB4 56                  <1>     push    si
    96                              <1> 
    97                              <1>     ; Copy one row
    98 00002CB5 B91C00              <1>     mov     cx, MON_WIDTH
    99                              <1> .col_loop:
   100 00002CB8 268B04              <1>     mov     ax, [es:si]             ; Char + attr
   101 00002CBB 8905                <1>     mov     [di], ax
   102 00002CBD 83C602              <1>     add     si, 2
   103 00002CC0 83C702              <1>     add     di, 2
   104 00002CC3 E2F3                <1>     loop    .col_loop
   105                              <1> 
   106 00002CC5 5E                  <1>     pop     si
   107 00002CC6 81C6A000            <1>     add     si, SCREEN_WIDTH * 2    ; Next row
   108 00002CCA 59                  <1>     pop     cx
   109 00002CCB E2E6                <1>     loop    .row_loop
   110                              <1> 
   111 00002CCD 07                  <1>     pop     es
   112 00002CCE 5F                  <1>     pop     di
   113 00002CCF 5E                  <1>     pop     si
   114 00002CD0 5A                  <1>     pop     dx
   115 00002CD1 59                  <1>     pop     cx
   116 00002CD2 5B                  <1>     pop     bx
   117 00002CD3 58                  <1>     pop     ax
   118 00002CD4 C3                  <1>     ret
   119                              <1> 
   120                              <1> ;==============================================================================
   121                              <1> ; Restore Screen Area Under Monitor
   122                              <1> ;==============================================================================
   123                              <1> monitor_restore_screen:
   124 00002CD5 50                  <1>     push    ax
   125 00002CD6 53                  <1>     push    bx
   126 00002CD7 51                  <1>     push    cx
   127 00002CD8 52                  <1>     push    dx
   128 00002CD9 56                  <1>     push    si
   129 00002CDA 57                  <1>     push    di
   130 00002CDB 06                  <1>     push    es
   131                              <1> 
   132                              <1>     ; Destination: video memory
   133 00002CDC A1[7019]            <1>     mov     ax, [video_seg]
   134 00002CDF 8EC0                <1>     mov     es, ax
   135                              <1> 
   136                              <1>     ; Calculate starting offset
   137 00002CE1 B80000              <1>     mov     ax, MON_ROW
   138 00002CE4 B3A0                <1>     mov     bl, SCREEN_WIDTH * 2
   139 00002CE6 F6E3                <1>     mul     bl
   140 00002CE8 83C064              <1>     add     ax, MON_COL * 2
   141 00002CEB 89C7                <1>     mov     di, ax
   142                              <1> 
   143                              <1>     ; Source: save buffer
   144 00002CED BE[2A2B]            <1>     mov     si, monitor_saved
   145                              <1> 
   146                              <1>     ; Copy rows
   147 00002CF0 B90C00              <1>     mov     cx, MON_HEIGHT
   148                              <1> .row_loop:
   149 00002CF3 51                  <1>     push    cx
   150 00002CF4 57                  <1>     push    di
   151                              <1> 
   152 00002CF5 B91C00              <1>     mov     cx, MON_WIDTH
   153                              <1> .col_loop:
   154 00002CF8 8B04                <1>     mov     ax, [si]
   155 00002CFA 268905              <1>     mov     [es:di], ax
   156 00002CFD 83C602              <1>     add     si, 2
   157 00002D00 83C702              <1>     add     di, 2
   158 00002D03 E2F3                <1>     loop    .col_loop
   159                              <1> 
   160 00002D05 5F                  <1>     pop     di
   161 00002D06 81C7A000            <1>     add     di, SCREEN_WIDTH * 2
   162 00002D0A 59                  <1>     pop     cx
   163 00002D0B E2E6                <1>     loop    .row_loop
   164                              <1> 
   165 00002D0D 07                  <1>     pop     es
   166 00002D0E 5F                  <1>     pop     di
   167 00002D0F 5E                  <1>     pop     si
   168 00002D10 5A                  <1>     pop     dx
   169 00002D11 59                  <1>     pop     cx
   170 00002D12 5B                  <1>     pop     bx
   171 00002D13 58                  <1>     pop     ax
   172 00002D14 C3                  <1>     ret
   173                              <1> 
   174                              <1> ;==============================================================================
   175                              <1> ; Draw Monitor Box
   176                              <1> ;==============================================================================
   177                              <1> monitor_draw:
   178 00002D15 50                  <1>     push    ax
   179 00002D16 53                  <1>     push    bx
   180 00002D17 51                  <1>     push    cx
   181 00002D18 52                  <1>     push    dx
   182 00002D19 56                  <1>     push    si
   183                              <1> 
   184                              <1>     ; Draw box frame
   185 00002D1A B600                <1>     mov     dh, MON_ROW
   186 00002D1C B232                <1>     mov     dl, MON_COL
   187 00002D1E B50B                <1>     mov     ch, MON_ROW + MON_HEIGHT - 1
   188 00002D20 B14D                <1>     mov     cl, MON_COL + MON_WIDTH - 1
   189 00002D22 B41F                <1>     mov     ah, ATTR_TITLE
   190 00002D24 E822ED              <1>     call    video_draw_box
   191                              <1> 
   192                              <1>     ; Fill interior with spaces
   193 00002D27 B601                <1>     mov     dh, MON_ROW + 1
   194                              <1> .fill_loop:
   195 00002D29 80FE0B              <1>     cmp     dh, MON_ROW + MON_HEIGHT - 1
   196 00002D2C 7D14                <1>     jge     .fill_done
   197                              <1> 
   198 00002D2E B233                <1>     mov     dl, MON_COL + 1
   199 00002D30 B91A00              <1>     mov     cx, MON_WIDTH - 2
   200                              <1> .space_loop:
   201 00002D33 B020                <1>     mov     al, ' '
   202 00002D35 B407                <1>     mov     ah, ATTR_NORMAL
   203 00002D37 E8C0EC              <1>     call    video_putc_at
   204 00002D3A FEC2                <1>     inc     dl
   205 00002D3C E2F5                <1>     loop    .space_loop
   206                              <1> 
   207 00002D3E FEC6                <1>     inc     dh
   208 00002D40 EBE7                <1>     jmp     .fill_loop
   209                              <1> .fill_done:
   210                              <1> 
   211                              <1>     ; Title
   212 00002D42 B600                <1>     mov     dh, MON_ROW
   213 00002D44 B234                <1>     mov     dl, MON_COL + 2
   214 00002D46 B41F                <1>     mov     ah, ATTR_TITLE
   215 00002D48 BE[F82F]            <1>     mov     si, mon_title
   216 00002D4B E8DDEC              <1>     call    video_puts_at
   217                              <1> 
   218                              <1>     ; Update values
   219 00002D4E E80600              <1>     call    monitor_update
   220                              <1> 
   221 00002D51 5E                  <1>     pop     si
   222 00002D52 5A                  <1>     pop     dx
   223 00002D53 59                  <1>     pop     cx
   224 00002D54 5B                  <1>     pop     bx
   225 00002D55 58                  <1>     pop     ax
   226 00002D56 C3                  <1>     ret
   227                              <1> 
   228                              <1> ;==============================================================================
   229                              <1> ; Update Monitor Values
   230                              <1> ;==============================================================================
   231                              <1> monitor_update:
   232 00002D57 50                  <1>     push    ax
   233 00002D58 53                  <1>     push    bx
   234 00002D59 51                  <1>     push    cx
   235 00002D5A 52                  <1>     push    dx
   236 00002D5B 56                  <1>     push    si
   237                              <1> 
   238                              <1>     ; Commands executed
   239 00002D5C B83000              <1>     mov     ax, INSTR_CMD_COUNT
   240                              <1>     INSTR_SET_ADDR
   175 00002D5F 52                  <2>  push dx
   176 00002D60 8B16[C931]          <2>  mov dx, [current_base]
   177 00002D64 81C2C000            <2>  add dx, INSTR_REG_BASE + INSTR_ADDR_LO
   178 00002D68 EE                  <2>  out dx, al
   179 00002D69 42                  <2>  inc dx
   180 00002D6A 88E0                <2>  mov al, ah
   181 00002D6C EE                  <2>  out dx, al
   182 00002D6D 5A                  <2>  pop dx
   241                              <1>     INSTR_READ_DATA                 ; DX:AX = command count
   189 00002D6E 53                  <2>  push bx
   190 00002D6F 8B16[C931]          <2>  mov dx, [current_base]
   191 00002D73 81C2C200            <2>  add dx, INSTR_REG_BASE + INSTR_DATA_0
   192 00002D77 EC                  <2>  in al, dx
   193 00002D78 88C3                <2>  mov bl, al
   194 00002D7A 42                  <2>  inc dx
   195 00002D7B EC                  <2>  in al, dx
   196 00002D7C 88C7                <2>  mov bh, al
   197 00002D7E 42                  <2>  inc dx
   198 00002D7F EC                  <2>  in al, dx
   199 00002D80 88C1                <2>  mov cl, al
   200 00002D82 42                  <2>  inc dx
   201 00002D83 EC                  <2>  in al, dx
   202 00002D84 88C5                <2>  mov ch, al
   203                              <2> 
   204 00002D86 89D8                <2>  mov ax, bx
   205 00002D88 89CA                <2>  mov dx, cx
   206 00002D8A 5B                  <2>  pop bx
   242                              <1> 
   243 00002D8B B602                <1>     mov     dh, MON_ROW + 2
   244 00002D8D B234                <1>     mov     dl, MON_COL + 2
   245 00002D8F B407                <1>     mov     ah, ATTR_NORMAL
   246 00002D91 BE[0530]            <1>     mov     si, mon_commands
   247 00002D94 E894EC              <1>     call    video_puts_at
   248 00002D97 80C20A              <1>     add     dl, 10
   249 00002D9A E8C601              <1>     call    mon_print_dec32
   250                              <1> 
   251                              <1>     ; Read count
   252 00002D9D B83400              <1>     mov     ax, INSTR_READ_COUNT
   253                              <1>     INSTR_SET_ADDR
   175 00002DA0 52                  <2>  push dx
   176 00002DA1 8B16[C931]          <2>  mov dx, [current_base]
   177 00002DA5 81C2C000            <2>  add dx, INSTR_REG_BASE + INSTR_ADDR_LO
   178 00002DA9 EE                  <2>  out dx, al
   179 00002DAA 42                  <2>  inc dx
   180 00002DAB 88E0                <2>  mov al, ah
   181 00002DAD EE                  <2>  out dx, al
   182 00002DAE 5A                  <2>  pop dx
   254                              <1>     INSTR_READ_DATA
   189 00002DAF 53                  <2>  push bx
   190 00002DB0 8B16[C931]          <2>  mov dx, [current_base]
   191 00002DB4 81C2C200            <2>  add dx, INSTR_REG_BASE + INSTR_DATA_0
   192 00002DB8 EC                  <2>  in al, dx
   193 00002DB9 88C3                <2>  mov bl, al
   194 00002DBB 42                  <2>  inc dx
   195 00002DBC EC                  <2>  in al, dx
   196 00002DBD 88C7                <2>  mov bh, al
   197 00002DBF 42                  <2>  inc dx
   198 00002DC0 EC                  <2>  in al, dx
   199 00002DC1 88C1                <2>  mov cl, al
   200 00002DC3 42                  <2>  inc dx
   201 00002DC4 EC                  <2>  in al, dx
   202 00002DC5 88C5                <2>  mov ch, al
   203                              <2> 
   204 00002DC7 89D8                <2>  mov ax, bx
   205 00002DC9 89CA                <2>  mov dx, cx
   206 00002DCB 5B                  <2>  pop bx
   255                              <1> 
   256 00002DCC B603                <1>     mov     dh, MON_ROW + 3
   257 00002DCE B234                <1>     mov     dl, MON_COL + 2
   258 00002DD0 BE[0F30]            <1>     mov     si, mon_reads
   259 00002DD3 E855EC              <1>     call    video_puts_at
   260 00002DD6 80C20A              <1>     add     dl, 10
   261 00002DD9 E88701              <1>     call    mon_print_dec32
   262                              <1> 
   263                              <1>     ; Write count
   264 00002DDC B83800              <1>     mov     ax, INSTR_WRITE_COUNT
   265                              <1>     INSTR_SET_ADDR
   175 00002DDF 52                  <2>  push dx
   176 00002DE0 8B16[C931]          <2>  mov dx, [current_base]
   177 00002DE4 81C2C000            <2>  add dx, INSTR_REG_BASE + INSTR_ADDR_LO
   178 00002DE8 EE                  <2>  out dx, al
   179 00002DE9 42                  <2>  inc dx
   180 00002DEA 88E0                <2>  mov al, ah
   181 00002DEC EE                  <2>  out dx, al
   182 00002DED 5A                  <2>  pop dx
   266                              <1>     INSTR_READ_DATA
   189 00002DEE 53                  <2>  push bx
   190 00002DEF 8B16[C931]          <2>  mov dx, [current_base]
   191 00002DF3 81C2C200            <2>  add dx, INSTR_REG_BASE + INSTR_DATA_0
   192 00002DF7 EC                  <2>  in al, dx
   193 00002DF8 88C3                <2>  mov bl, al
   194 00002DFA 42                  <2>  inc dx
   195 00002DFB EC                  <2>  in al, dx
   196 00002DFC 88C7                <2>  mov bh, al
   197 00002DFE 42                  <2>  inc dx
   198 00002DFF EC                  <2>  in al, dx
   199 00002E00 88C1                <2>  mov cl, al
   200 00002E02 42                  <2>  inc dx
   201 00002E03 EC                  <2>  in al, dx
   202 00002E04 88C5                <2>  mov ch, al
   203                              <2> 
   204 00002E06 89D8                <2>  mov ax, bx
   205 00002E08 89CA                <2>  mov dx, cx
   206 00002E0A 5B                  <2>  pop bx
   267                              <1> 
   268 00002E0B B604                <1>     mov     dh, MON_ROW + 4
   269 00002E0D B234                <1>     mov     dl, MON_COL + 2
   270 00002E0F BE[1930]            <1>     mov     si, mon_writes
   271 00002E12 E816EC              <1>     call    video_puts_at
   272 00002E15 80C20A              <1>     add     dl, 10
   273 00002E18 E84801              <1>     call    mon_print_dec32
   274                              <1> 
   275                              <1>     ; Error total
   276 00002E1B B85000              <1>     mov     ax, INSTR_ERR_TOTAL
   277                              <1>     INSTR_SET_ADDR
   175 00002E1E 52                  <2>  push dx
   176 00002E1F 8B16[C931]          <2>  mov dx, [current_base]
   177 00002E23 81C2C000            <2>  add dx, INSTR_REG_BASE + INSTR_ADDR_LO
   178 00002E27 EE                  <2>  out dx, al
   179 00002E28 42                  <2>  inc dx
   180 00002E29 88E0                <2>  mov al, ah
   181 00002E2B EE                  <2>  out dx, al
   182 00002E2C 5A                  <2>  pop dx
   278                              <1>     INSTR_READ_DATA
   189 00002E2D 53                  <2>  push bx
   190 00002E2E 8B16[C931]          <2>  mov dx, [current_base]
   191 00002E32 81C2C200            <2>  add dx, INSTR_REG_BASE + INSTR_DATA_0
   192 00002E36 EC                  <2>  in al, dx
   193 00002E37 88C3                <2>  mov bl, al
   194 00002E39 42                  <2>  inc dx
   195 00002E3A EC                  <2>  in al, dx
   196 00002E3B 88C7                <2>  mov bh, al
   197 00002E3D 42                  <2>  inc dx
   198 00002E3E EC                  <2>  in al, dx
   199 00002E3F 88C1                <2>  mov cl, al
   200 00002E41 42                  <2>  inc dx
   201 00002E42 EC                  <2>  in al, dx
   202 00002E43 88C5                <2>  mov ch, al
   203                              <2> 
   204 00002E45 89D8                <2>  mov ax, bx
   205 00002E47 89CA                <2>  mov dx, cx
   206 00002E49 5B                  <2>  pop bx
   279 00002E4A 52                  <1>     push    dx
   280 00002E4B 50                  <1>     push    ax
   281                              <1> 
   282 00002E4C B605                <1>     mov     dh, MON_ROW + 5
   283 00002E4E B234                <1>     mov     dl, MON_COL + 2
   284 00002E50 BE[2330]            <1>     mov     si, mon_errors
   285 00002E53 E8D5EB              <1>     call    video_puts_at
   286 00002E56 80C20A              <1>     add     dl, 10
   287                              <1> 
   288 00002E59 58                  <1>     pop     ax
   289 00002E5A 5A                  <1>     pop     dx
   290                              <1>     ; Color code errors
   291 00002E5B 85D2                <1>     test    dx, dx
   292 00002E5D 7504                <1>     jnz     .err_red
   293 00002E5F 85C0                <1>     test    ax, ax
   294 00002E61 7404                <1>     jz      .err_green
   295                              <1> .err_red:
   296 00002E63 B44F                <1>     mov     ah, ATTR_ERROR
   297 00002E65 EB02                <1>     jmp     .show_err
   298                              <1> .err_green:
   299 00002E67 B42F                <1>     mov     ah, ATTR_SUCCESS
   300                              <1> .show_err:
   301 00002E69 8826[7419]          <1>     mov     [current_attr], ah
   302 00002E6D E8F300              <1>     call    mon_print_dec32
   303 00002E70 C606[7419]07        <1>     mov     byte [current_attr], ATTR_NORMAL
   304                              <1> 
   305                              <1>     ; Data rate
   306 00002E75 B82000              <1>     mov     ax, INSTR_DATA_RATE
   307                              <1>     INSTR_SET_ADDR
   175 00002E78 52                  <2>  push dx
   176 00002E79 8B16[C931]          <2>  mov dx, [current_base]
   177 00002E7D 81C2C000            <2>  add dx, INSTR_REG_BASE + INSTR_ADDR_LO
   178 00002E81 EE                  <2>  out dx, al
   179 00002E82 42                  <2>  inc dx
   180 00002E83 88E0                <2>  mov al, ah
   181 00002E85 EE                  <2>  out dx, al
   182 00002E86 5A                  <2>  pop dx
   308                              <1>     INSTR_READ_DATA
   189 00002E87 53                  <2>  push bx
   190 00002E88 8B16[C931]          <2>  mov dx, [current_base]
   191 00002E8C 81C2C200            <2>  add dx, INSTR_REG_BASE + INSTR_DATA_0
   192 00002E90 EC                  <2>  in al, dx
   193 00002E91 88C3                <2>  mov bl, al
   194 00002E93 42                  <2>  inc dx
   195 00002E94 EC                  <2>  in al, dx
   196 00002E95 88C7                <2>  mov bh, al
   197 00002E97 42                  <2>  inc dx
   198 00002E98 EC                  <2>  in al, dx
   199 00002E99 88C1                <2>  mov cl, al
   200 00002E9B 42                  <2>  inc dx
   201 00002E9C EC                  <2>  in al, dx
   202 00002E9D 88C5                <2>  mov ch, al
   203                              <2> 
   204 00002E9F 89D8                <2>  mov ax, bx
   205 00002EA1 89CA                <2>  mov dx, cx
   206 00002EA3 5B                  <2>  pop bx
   309                              <1> 
   310 00002EA4 B607                <1>     mov     dh, MON_ROW + 7
   311 00002EA6 B234                <1>     mov     dl, MON_COL + 2
   312 00002EA8 BE[2D30]            <1>     mov     si, mon_datarate
   313 00002EAB E87DEB              <1>     call    video_puts_at
   314 00002EAE 80C20C              <1>     add     dl, 12
   315                              <1> 
   316                              <1>     ; Convert to KB/s (divide by 1024)
   317 00002EB1 B90A00              <1>     mov     cx, 10
   318                              <1> .rate_shift:
   319 00002EB4 D1EA                <1>     shr     dx, 1
   320 00002EB6 D1D8                <1>     rcr     ax, 1
   321 00002EB8 E2FA                <1>     loop    .rate_shift
   322                              <1> 
   323 00002EBA 31D2                <1>     xor     dx, dx                  ; Just show low word
   324 00002EBC E8A400              <1>     call    mon_print_dec32
   325 00002EBF BE[3930]            <1>     mov     si, mon_kbs
   326 00002EC2 E866EB              <1>     call    video_puts_at
   327                              <1> 
   328                              <1>     ; Spindle RPM
   329 00002EC5 B82400              <1>     mov     ax, INSTR_RPM
   330                              <1>     INSTR_SET_ADDR
   175 00002EC8 52                  <2>  push dx
   176 00002EC9 8B16[C931]          <2>  mov dx, [current_base]
   177 00002ECD 81C2C000            <2>  add dx, INSTR_REG_BASE + INSTR_ADDR_LO
   178 00002ED1 EE                  <2>  out dx, al
   179 00002ED2 42                  <2>  inc dx
   180 00002ED3 88E0                <2>  mov al, ah
   181 00002ED5 EE                  <2>  out dx, al
   182 00002ED6 5A                  <2>  pop dx
   331                              <1>     INSTR_READ_DATA
   189 00002ED7 53                  <2>  push bx
   190 00002ED8 8B16[C931]          <2>  mov dx, [current_base]
   191 00002EDC 81C2C200            <2>  add dx, INSTR_REG_BASE + INSTR_DATA_0
   192 00002EE0 EC                  <2>  in al, dx
   193 00002EE1 88C3                <2>  mov bl, al
   194 00002EE3 42                  <2>  inc dx
   195 00002EE4 EC                  <2>  in al, dx
   196 00002EE5 88C7                <2>  mov bh, al
   197 00002EE7 42                  <2>  inc dx
   198 00002EE8 EC                  <2>  in al, dx
   199 00002EE9 88C1                <2>  mov cl, al
   200 00002EEB 42                  <2>  inc dx
   201 00002EEC EC                  <2>  in al, dx
   202 00002EED 88C5                <2>  mov ch, al
   203                              <2> 
   204 00002EEF 89D8                <2>  mov ax, bx
   205 00002EF1 89CA                <2>  mov dx, cx
   206 00002EF3 5B                  <2>  pop bx
   332                              <1> 
   333 00002EF4 B608                <1>     mov     dh, MON_ROW + 8
   334 00002EF6 B234                <1>     mov     dl, MON_COL + 2
   335 00002EF8 BE[3F30]            <1>     mov     si, mon_rpm
   336 00002EFB E82DEB              <1>     call    video_puts_at
   337 00002EFE 80C20C              <1>     add     dl, 12
   338                              <1> 
   339                              <1>     ; RPM is *10, so divide
   340 00002F01 BB0A00              <1>     mov     bx, 10
   341 00002F04 F7F3                <1>     div     bx
   342 00002F06 31D2                <1>     xor     dx, dx
   343 00002F08 E85800              <1>     call    mon_print_dec32
   344 00002F0B BE[4B30]            <1>     mov     si, mon_rpm_unit
   345 00002F0E E81AEB              <1>     call    video_puts_at
   346                              <1> 
   347                              <1>     ; Temperature
   348 00002F11 B81001              <1>     mov     ax, INSTR_TEMP_DRIVE
   349                              <1>     INSTR_SET_ADDR
   175 00002F14 52                  <2>  push dx
   176 00002F15 8B16[C931]          <2>  mov dx, [current_base]
   177 00002F19 81C2C000            <2>  add dx, INSTR_REG_BASE + INSTR_ADDR_LO
   178 00002F1D EE                  <2>  out dx, al
   179 00002F1E 42                  <2>  inc dx
   180 00002F1F 88E0                <2>  mov al, ah
   181 00002F21 EE                  <2>  out dx, al
   182 00002F22 5A                  <2>  pop dx
   350                              <1>     INSTR_READ_DATA
   189 00002F23 53                  <2>  push bx
   190 00002F24 8B16[C931]          <2>  mov dx, [current_base]
   191 00002F28 81C2C200            <2>  add dx, INSTR_REG_BASE + INSTR_DATA_0
   192 00002F2C EC                  <2>  in al, dx
   193 00002F2D 88C3                <2>  mov bl, al
   194 00002F2F 42                  <2>  inc dx
   195 00002F30 EC                  <2>  in al, dx
   196 00002F31 88C7                <2>  mov bh, al
   197 00002F33 42                  <2>  inc dx
   198 00002F34 EC                  <2>  in al, dx
   199 00002F35 88C1                <2>  mov cl, al
   200 00002F37 42                  <2>  inc dx
   201 00002F38 EC                  <2>  in al, dx
   202 00002F39 88C5                <2>  mov ch, al
   203                              <2> 
   204 00002F3B 89D8                <2>  mov ax, bx
   205 00002F3D 89CA                <2>  mov dx, cx
   206 00002F3F 5B                  <2>  pop bx
   351                              <1> 
   352 00002F40 B609                <1>     mov     dh, MON_ROW + 9
   353 00002F42 B234                <1>     mov     dl, MON_COL + 2
   354 00002F44 BE[5030]            <1>     mov     si, mon_temp
   355 00002F47 E8E1EA              <1>     call    video_puts_at
   356 00002F4A 80C20C              <1>     add     dl, 12
   357                              <1> 
   358                              <1>     ; Temp is *10
   359 00002F4D BB0A00              <1>     mov     bx, 10
   360 00002F50 F7F3                <1>     div     bx
   361 00002F52 31D2                <1>     xor     dx, dx
   362 00002F54 E80C00              <1>     call    mon_print_dec32
   363 00002F57 BE[5C30]            <1>     mov     si, mon_celsius
   364 00002F5A E8CEEA              <1>     call    video_puts_at
   365                              <1> 
   366 00002F5D 5E                  <1>     pop     si
   367 00002F5E 5A                  <1>     pop     dx
   368 00002F5F 59                  <1>     pop     cx
   369 00002F60 5B                  <1>     pop     bx
   370 00002F61 58                  <1>     pop     ax
   371 00002F62 C3                  <1>     ret
   372                              <1> 
   373                              <1> ;==============================================================================
   374                              <1> ; Print 32-bit Decimal
   375                              <1> ;==============================================================================
   376                              <1> ; Input: DX:AX = 32-bit value
   377                              <1> ;        DH = row, DL = column (position)
   378                              <1> ;==============================================================================
   379                              <1> mon_print_dec32:
   380 00002F63 50                  <1>     push    ax
   381 00002F64 53                  <1>     push    bx
   382 00002F65 51                  <1>     push    cx
   383 00002F66 52                  <1>     push    dx
   384 00002F67 56                  <1>     push    si
   385 00002F68 57                  <1>     push    di
   386                              <1> 
   387                              <1>     ; Save position
   388 00002F69 89D3                <1>     mov     bx, dx                  ; BH=row, BL=col
   389                              <1> 
   390                              <1>     ; Handle 32-bit to decimal conversion
   391                              <1>     ; For simplicity, just print low 16 bits if high is 0
   392 00002F6B 85D2                <1>     test    dx, dx
   393 00002F6D 7519                <1>     jnz     .full_32
   394                              <1> 
   395                              <1>     ; Just 16-bit
   396 00002F6F BE[B22F]            <1>     mov     si, .buffer + 10
   397 00002F72 C60400              <1>     mov     byte [si], 0
   398                              <1> 
   399 00002F75 B90A00              <1>     mov     cx, 10
   400                              <1> .conv16:
   401 00002F78 4E                  <1>     dec     si
   402 00002F79 31D2                <1>     xor     dx, dx
   403 00002F7B F7F1                <1>     div     cx
   404 00002F7D 80C230              <1>     add     dl, '0'
   405 00002F80 8814                <1>     mov     [si], dl
   406 00002F82 85C0                <1>     test    ax, ax
   407 00002F84 75F2                <1>     jnz     .conv16
   408 00002F86 EB05                <1>     jmp     .print
   409                              <1> 
   410                              <1> .full_32:
   411                              <1>     ; Full 32-bit (simplified - just show "99999+")
   412 00002F88 BE[5F30]            <1>     mov     si, mon_overflow
   413 00002F8B EB00                <1>     jmp     .print
   414                              <1> 
   415                              <1> .print:
   416 00002F8D 88FE                <1>     mov     dh, bh
   417 00002F8F 88DA                <1>     mov     dl, bl
   418 00002F91 8A26[7419]          <1>     mov     ah, [current_attr]
   419                              <1> .print_loop:
   420 00002F95 AC                  <1>     lodsb
   421 00002F96 84C0                <1>     test    al, al
   422 00002F98 7407                <1>     jz      .done
   423 00002F9A E85DEA              <1>     call    video_putc_at
   424 00002F9D FEC2                <1>     inc     dl
   425 00002F9F EBF4                <1>     jmp     .print_loop
   426                              <1> 
   427                              <1> .done:
   428 00002FA1 5F                  <1>     pop     di
   429 00002FA2 5E                  <1>     pop     si
   430 00002FA3 5A                  <1>     pop     dx
   431 00002FA4 59                  <1>     pop     cx
   432 00002FA5 5B                  <1>     pop     bx
   433 00002FA6 58                  <1>     pop     ax
   434 00002FA7 C3                  <1>     ret
   435                              <1> 
   436 00002FA8 00<rep Ch>          <1> .buffer: times 12 db 0
   437                              <1> 
   438                              <1> ;==============================================================================
   439                              <1> ; Check for Monitor Refresh
   440                              <1> ;==============================================================================
   441                              <1> ; Call this periodically (e.g., from timer hook or INT 13h).
   442                              <1> ; Updates display if monitor is active and enough time has passed.
   443                              <1> ;==============================================================================
   444                              <1> monitor_check_refresh:
   445 00002FB4 50                  <1>     push    ax
   446 00002FB5 53                  <1>     push    bx
   447 00002FB6 1E                  <1>     push    ds
   448 00002FB7 06                  <1>     push    es
   449                              <1> 
   450 00002FB8 0E                  <1>     push    cs
   451 00002FB9 1F                  <1>     pop     ds
   452                              <1> 
   453                              <1>     ; Check if active
   454 00002FBA 803E[292B]00        <1>     cmp     byte [monitor_active], 0
   455 00002FBF 7419                <1>     je      .done
   456                              <1> 
   457                              <1>     ; Check tick count
   458 00002FC1 31C0                <1>     xor     ax, ax
   459 00002FC3 8EC0                <1>     mov     es, ax
   460 00002FC5 26A16C04            <1>     mov     ax, [es:0x046C]         ; BIOS tick counter
   461 00002FC9 8B1E[7A2C]          <1>     mov     bx, [last_tick]
   462 00002FCD 29D8                <1>     sub     ax, bx
   463 00002FCF 83F809              <1>     cmp     ax, MON_REFRESH
   464 00002FD2 7206                <1>     jb      .done
   465                              <1> 
   466                              <1>     ; Time to refresh
   467 00002FD4 A3[7A2C]            <1>     mov     [last_tick], ax
   468 00002FD7 E87DFD              <1>     call    monitor_update
   469                              <1> 
   470                              <1> .done:
   471 00002FDA 07                  <1>     pop     es
   472 00002FDB 1F                  <1>     pop     ds
   473 00002FDC 5B                  <1>     pop     bx
   474 00002FDD 58                  <1>     pop     ax
   475 00002FDE C3                  <1>     ret
   476                              <1> 
   477                              <1> ;==============================================================================
   478                              <1> ; Keyboard Interrupt Hook (for F3 detection)
   479                              <1> ;==============================================================================
   480                              <1> ; This would be installed as a hook to INT 9 or INT 16h to detect F3.
   481                              <1> ; For now, this is called from the INT 13h handler to check for F3.
   482                              <1> ;==============================================================================
   483                              <1> monitor_check_f3:
   484 00002FDF 50                  <1>     push    ax
   485 00002FE0 1E                  <1>     push    ds
   486                              <1> 
   487 00002FE1 0E                  <1>     push    cs
   488 00002FE2 1F                  <1>     pop     ds
   489                              <1> 
   490                              <1>     ; Quick keyboard check
   491 00002FE3 B401                <1>     mov     ah, 0x01
   492 00002FE5 CD16                <1>     int     0x16
   493 00002FE7 740C                <1>     jz      .no_key
   494                              <1> 
   495                              <1>     ; Check if F3
   496 00002FE9 80FC3D              <1>     cmp     ah, KEY_F3
   497 00002FEC 7507                <1>     jne     .no_key
   498                              <1> 
   499                              <1>     ; Consume the key
   500 00002FEE B400                <1>     mov     ah, 0x00
   501 00002FF0 CD16                <1>     int     0x16
   502                              <1> 
   503                              <1>     ; Toggle monitor
   504 00002FF2 E887FC              <1>     call    monitor_toggle
   505                              <1> 
   506                              <1> .no_key:
   507 00002FF5 1F                  <1>     pop     ds
   508 00002FF6 58                  <1>     pop     ax
   509 00002FF7 C3                  <1>     ret
   510                              <1> 
   511                              <1> ;==============================================================================
   512                              <1> ; Monitor Strings
   513                              <1> ;==============================================================================
   514 00002FF8 20466C757852697070- <1> mon_title:      db " FluxRipper ", 0
   514 00003001 65722000            <1>
   515 00003005 436F6D6D616E64733A- <1> mon_commands:   db "Commands:", 0
   515 0000300E 00                  <1>
   516 0000300F 52656164733A202020- <1> mon_reads:      db "Reads:   ", 0
   516 00003018 00                  <1>
   517 00003019 5772697465733A2020- <1> mon_writes:     db "Writes:  ", 0
   517 00003022 00                  <1>
   518 00003023 4572726F72733A2020- <1> mon_errors:     db "Errors:  ", 0
   518 0000302C 00                  <1>
   519 0000302D 446174612052617465- <1> mon_datarate:   db "Data Rate: ", 0
   519 00003036 3A2000              <1>
   520 00003039 204B422F7300        <1> mon_kbs:        db " KB/s", 0
   521 0000303F 5370696E646C653A20- <1> mon_rpm:        db "Spindle:   ", 0
   521 00003048 202000              <1>
   522 0000304B 2052504D00          <1> mon_rpm_unit:   db " RPM", 0
   523 00003050 54656D703A20202020- <1> mon_temp:       db "Temp:      ", 0
   523 00003059 202000              <1>
   524 0000305C 204300              <1> mon_celsius:    db " C", 0
   525 0000305F 39393939392B00      <1> mon_overflow:   db "99999+", 0
   526                              <1> 
   527                              <1> %endif ; BUILD_16KB
   233                                  %endif
   234                                  %if ENABLE_SETUP
   235                                  %include "setup.asm"
     1                              <1> ;==============================================================================
     2                              <1> ; FluxRipper HDD BIOS - Setup Utility
     3                              <1> ;==============================================================================
     4                              <1> ; Interactive setup for configuring drive parameters.
     5                              <1> ;
     6                              <1> ; Features:
     7                              <1> ;   - Drive type override
     8                              <1> ;   - Geometry override
     9                              <1> ;   - Translation mode selection
    10                              <1> ;   - Save to flash
    11                              <1> ;
    12                              <1> ; SPDX-License-Identifier: BSD-3-Clause
    13                              <1> ; Copyright (c) 2025 FluxRipper Project
    14                              <1> ;==============================================================================
    15                              <1> 
    16                              <1> %if BUILD_16KB && ENABLE_SETUP
    17                              <1> 
    18                              <1> ;==============================================================================
    19                              <1> ; Setup Entry Point
    20                              <1> ;==============================================================================
    21                              <1> setup_enter:
    22 00003066 6660                <1>     pushad
    23 00003068 1E                  <1>     push    ds
    24 00003069 06                  <1>     push    es
    25                              <1> 
    26 0000306A 0E                  <1>     push    cs
    27 0000306B 1F                  <1>     pop     ds
    28                              <1> 
    29 0000306C E85AE9              <1>     call    video_clear_screen
    30                              <1> 
    31                              <1>     ; Title
    32 0000306F B41F                <1>     mov     ah, ATTR_TITLE
    33 00003071 B600                <1>     mov     dh, 0
    34 00003073 BE[2331]            <1>     mov     si, setup_title
    35 00003076 E885EA              <1>     call    video_puts_centered
    36                              <1> 
    37                              <1>     ; Instructions
    38 00003079 B602                <1>     mov     dh, 2
    39 0000307B B205                <1>     mov     dl, 5
    40 0000307D B407                <1>     mov     ah, ATTR_NORMAL
    41 0000307F BE[3E31]            <1>     mov     si, setup_info
    42 00003082 E8A6E9              <1>     call    video_puts_at
    43                              <1> 
    44                              <1>     ; Show current settings
    45 00003085 E80800              <1>     call    setup_show_current
    46                              <1> 
    47                              <1>     ; Main menu
    48 00003088 E84B00              <1>     call    setup_menu
    49                              <1> 
    50 0000308B 07                  <1>     pop     es
    51 0000308C 1F                  <1>     pop     ds
    52 0000308D 6661                <1>     popad
    53 0000308F C3                  <1>     ret
    54                              <1> 
    55                              <1> ;==============================================================================
    56                              <1> ; Show Current Settings
    57                              <1> ;==============================================================================
    58                              <1> setup_show_current:
    59 00003090 50                  <1>     push    ax
    60 00003091 52                  <1>     push    dx
    61 00003092 56                  <1>     push    si
    62                              <1> 
    63 00003093 B605                <1>     mov     dh, 5
    64 00003095 B205                <1>     mov     dl, 5
    65 00003097 B40E                <1>     mov     ah, ATTR_HIGHLIGHT
    66 00003099 BE[6F31]            <1>     mov     si, setup_current_hdr
    67 0000309C E88CE9              <1>     call    video_puts_at
    68                              <1> 
    69                              <1>     ; Drive 0 settings
    70 0000309F B607                <1>     mov     dh, 7
    71 000030A1 B205                <1>     mov     dl, 5
    72 000030A3 B407                <1>     mov     ah, ATTR_NORMAL
    73 000030A5 BE[8131]            <1>     mov     si, setup_drive0
    74 000030A8 E880E9              <1>     call    video_puts_at
    75                              <1> 
    76                              <1>     ; Show auto-detected geometry
    77 000030AB 80C20C              <1>     add     dl, 12
    78 000030AE A1[9831]            <1>     mov     ax, [drive0_params + 0]  ; Cylinders
    79 000030B1 E83100              <1>     call    setup_print_dec16
    80 000030B4 B02F                <1>     mov     al, '/'
    81 000030B6 E841E9              <1>     call    video_putc_at
    82 000030B9 FEC2                <1>     inc     dl
    83 000030BB 30E4                <1>     xor     ah, ah
    84 000030BD A0[9A31]            <1>     mov     al, [drive0_params + 2]  ; Heads
    85 000030C0 E82200              <1>     call    setup_print_dec16
    86 000030C3 B02F                <1>     mov     al, '/'
    87 000030C5 E832E9              <1>     call    video_putc_at
    88 000030C8 FEC2                <1>     inc     dl
    89 000030CA 30E4                <1>     xor     ah, ah
    90 000030CC A0[9B31]            <1>     mov     al, [drive0_params + 3]  ; Sectors
    91 000030CF E81300              <1>     call    setup_print_dec16
    92                              <1> 
    93 000030D2 5E                  <1>     pop     si
    94 000030D3 5A                  <1>     pop     dx
    95 000030D4 58                  <1>     pop     ax
    96 000030D5 C3                  <1>     ret
    97                              <1> 
    98                              <1> ;==============================================================================
    99                              <1> ; Setup Menu
   100                              <1> ;==============================================================================
   101                              <1> setup_menu:
   102 000030D6 50                  <1>     push    ax
   103 000030D7 53                  <1>     push    bx
   104                              <1> 
   105                              <1> .menu_loop:
   106 000030D8 E84FEA              <1>     call    kbd_get
   107                              <1> 
   108 000030DB 80FC01              <1>     cmp     ah, KEY_ESC
   109 000030DE 7402                <1>     je      .exit
   110                              <1> 
   111                              <1>     ; Menu options would be handled here
   112 000030E0 EBF6                <1>     jmp     .menu_loop
   113                              <1> 
   114                              <1> .exit:
   115 000030E2 5B                  <1>     pop     bx
   116 000030E3 58                  <1>     pop     ax
   117 000030E4 C3                  <1>     ret
   118                              <1> 
   119                              <1> ;==============================================================================
   120                              <1> ; Print 16-bit Decimal
   121                              <1> ;==============================================================================
   122                              <1> setup_print_dec16:
   123 000030E5 50                  <1>     push    ax
   124 000030E6 53                  <1>     push    bx
   125 000030E7 51                  <1>     push    cx
   126 000030E8 52                  <1>     push    dx
   127 000030E9 56                  <1>     push    si
   128                              <1> 
   129 000030EA 89C3                <1>     mov     bx, ax
   130 000030EC BE[2231]            <1>     mov     si, .buffer + 5
   131 000030EF C60400              <1>     mov     byte [si], 0
   132                              <1> 
   133 000030F2 89D8                <1>     mov     ax, bx
   134 000030F4 B90A00              <1>     mov     cx, 10
   135                              <1> .convert:
   136 000030F7 4E                  <1>     dec     si
   137 000030F8 31D2                <1>     xor     dx, dx
   138 000030FA F7F1                <1>     div     cx
   139 000030FC 80C230              <1>     add     dl, '0'
   140 000030FF 8814                <1>     mov     [si], dl
   141 00003101 85C0                <1>     test    ax, ax
   142 00003103 75F2                <1>     jnz     .convert
   143                              <1> 
   144 00003105 5A                  <1>     pop     dx
   145 00003106 52                  <1>     push    dx
   146 00003107 8A26[7419]          <1>     mov     ah, [current_attr]
   147                              <1> .print:
   148 0000310B AC                  <1>     lodsb
   149 0000310C 84C0                <1>     test    al, al
   150 0000310E 7407                <1>     jz      .done
   151 00003110 E8E7E8              <1>     call    video_putc_at
   152 00003113 FEC2                <1>     inc     dl
   153 00003115 EBF4                <1>     jmp     .print
   154                              <1> 
   155                              <1> .done:
   156 00003117 5E                  <1>     pop     si
   157 00003118 5A                  <1>     pop     dx
   158 00003119 59                  <1>     pop     cx
   159 0000311A 5B                  <1>     pop     bx
   160 0000311B 58                  <1>     pop     ax
   161 0000311C C3                  <1>     ret
   162                              <1> 
   163 0000311D 00<rep 6h>          <1> .buffer: times 6 db 0
   164                              <1> 
   165                              <1> ;==============================================================================
   166                              <1> ; Setup Strings
   167                              <1> ;==============================================================================
   168 00003123 20466C757852697070- <1> setup_title:        db " FluxRipper Setup Utility ", 0
   168 0000312C 657220536574757020- <1>
   168 00003135 5574696C6974792000  <1>
   169 0000313E 436F6E666967757265- <1> setup_info:         db "Configure drive parameters and translation mode.", 0
   169 00003147 206472697665207061- <1>
   169 00003150 72616D657465727320- <1>
   169 00003159 616E64207472616E73- <1>
   169 00003162 6C6174696F6E206D6F- <1>
   169 0000316B 64652E00            <1>
   170 0000316F 43757272656E742053- <1> setup_current_hdr:  db "Current Settings:", 0
   170 00003178 657474696E67733A00  <1>
   171 00003181 447269766520302043- <1> setup_drive0:       db "Drive 0 C/H/S:", 0
   171 0000318A 2F482F533A00        <1>
   172                              <1> 
   173                              <1> %endif ; BUILD_16KB && ENABLE_SETUP
   236                                  %endif
   237                                  %endif
   238                                  
   239                                  ;==============================================================================
   240                                  ; Data Section
   241                                  ;==============================================================================
   242                                  
   243                                  ;------------------------------------------------------------------------------
   244                                  ; Saved INT 13h Vector
   245                                  ;------------------------------------------------------------------------------
   246                                  old_int13h:
   247 00003190 0000                        dw      0                       ; Offset
   248 00003192 0000                        dw      0                       ; Segment
   249                                  
   250                                  %if ENABLE_PNP
   251                                  old_int19:
   252 00003194 0000                        dw      0                       ; Offset
   253 00003196 0000                        dw      0                       ; Segment
   254                                  %endif
   255                                  
   256                                  ;------------------------------------------------------------------------------
   257                                  ; Drive Parameter Storage (2 drives max)
   258                                  ;------------------------------------------------------------------------------
   259                                  ; These are populated from FPGA discovery registers
   260                                  
   261                                  drive0_params:
   262 00003198 0000                        .cylinders  dw  0               ; Detected cylinders
   263 0000319A 00                          .heads      db  0               ; Detected heads
   264 0000319B 00                          .sectors    db  0               ; Detected sectors per track
   265 0000319C 00                          .flags      db  0               ; Feature flags (bit 0=ESDI, bit 1=RLL)
   266 0000319D 000000                      .reserved   db  0,0,0           ; Padding to 8 bytes
   267                                  
   268                                  drive1_params:
   269 000031A0 0000                        .cylinders  dw  0
   270 000031A2 00                          .heads      db  0
   271 000031A3 00                          .sectors    db  0
   272 000031A4 00                          .flags      db  0
   273 000031A5 000000                      .reserved   db  0,0,0
   274                                  
   275                                  ;------------------------------------------------------------------------------
   276                                  ; Fixed Disk Parameter Tables (INT 41h/46h format)
   277                                  ;------------------------------------------------------------------------------
   278                                  ; These are 16-byte tables pointed to by INT 41h (drive 0) and INT 46h (drive 1)
   279                                  
   280                                  fdpt_drive0:
   281 000031A8 0000                        dw      0                       ; +00: Maximum cylinders
   282 000031AA 00                          db      0                       ; +02: Maximum heads
   283 000031AB 0000                        dw      0                       ; +03: Reserved
   284 000031AD FFFF                        dw      0xFFFF                  ; +05: Write precomp (0xFFFF = none)
   285 000031AF 00                          db      0                       ; +07: Reserved
   286 000031B0 08                          db      0x08                    ; +08: Control byte (>8 heads flag set if needed)
   287 000031B1 00                          db      0                       ; +09: Standard timeout (use default)
   288 000031B2 00                          db      0                       ; +0A: Format timeout
   289 000031B3 00                          db      0                       ; +0B: Check timeout
   290 000031B4 0000                        dw      0                       ; +0C: Landing zone (same as max cyl)
   291 000031B6 00                          db      0                       ; +0E: Sectors per track
   292 000031B7 00                          db      0                       ; +0F: Reserved
   293                                  
   294                                  fdpt_drive1:
   295 000031B8 0000                        dw      0
   296 000031BA 00                          db      0
   297 000031BB 0000                        dw      0
   298 000031BD FFFF                        dw      0xFFFF
   299 000031BF 00                          db      0
   300 000031C0 08                          db      0x08
   301 000031C1 00                          db      0
   302 000031C2 00                          db      0
   303 000031C3 00                          db      0
   304 000031C4 0000                        dw      0
   305 000031C6 00                          db      0
   306 000031C7 00                          db      0
   307                                  
   308                                  ;------------------------------------------------------------------------------
   309                                  ; Controller State
   310                                  ;------------------------------------------------------------------------------
   311                                  num_drives:
   312 000031C8 00                          db      0                       ; Number of detected drives (0-2)
   313                                  
   314                                  current_base:
   315 000031C9 F001                        dw      WD_BASE_PRIMARY         ; Current WD I/O base address
   316                                  
   317                                  personality:
   318 000031CB 01                          db      PERSONALITY_WD1003      ; Detected personality (WD1002/3/6/7)
   319                                  
   320                                  ;==============================================================================
   321                                  ; ROM Padding and Checksum
   322                                  ;==============================================================================
   323                                  ; Pad to ROM size minus 1 byte, then add checksum byte
   324                                  
   325                                  %if BUILD_8KB
   326                                      times (8192 - 1 - ($ - $$)) db 0xFF
   327                                  %else
   328 000031CC FF<rep E33h>                times (16384 - 1 - ($ - $$)) db 0xFF
   329                                  %endif
   330                                  
   331                                  ; Final byte will be set by romsum.py to make total sum = 0
   332                                  rom_checksum:
   333 00003FFF 00                          db      0
   334                                  
   335                                  ;==============================================================================
   336                                  ; End of ROM
   337                                  ;==============================================================================
